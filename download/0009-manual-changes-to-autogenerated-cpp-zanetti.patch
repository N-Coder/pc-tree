From fc781825848a9324cab4af2d58e6d1d0c79e4d37 Mon Sep 17 00:00:00 2001
From: Simon Dominik Niko Fink <simon.fink@uni-passau.de>
Date: Wed, 2 Mar 2022 16:41:55 +0100
Subject: [PATCH 9/9] manual changes to autogenerated cpp zanetti

---
 libraries/zanettiPQR/Leaf.h    |  18 +-
 libraries/zanettiPQR/Node.h    | 136 +++++-----
 libraries/zanettiPQR/PQRNode.h | 190 +++++++-------
 libraries/zanettiPQR/PQRTree.h | 451 +++++++++++++++++----------------
 libraries/zanettiPQR/PQRType.h |   4 +-
 5 files changed, 415 insertions(+), 384 deletions(-)

diff --git a/libraries/zanettiPQR/Leaf.h b/libraries/zanettiPQR/Leaf.h
index 4a4b0cc..1f81a08 100644
--- a/libraries/zanettiPQR/Leaf.h
+++ b/libraries/zanettiPQR/Leaf.h
@@ -14,24 +14,24 @@ struct Leaf : Node {
          */
     const int value;
 
+    int arrayIndex;
+
     /**
          * Initializes a new leaf.
          * 
          * @param i The leaf label.
          */
-    Leaf(int i) {
-        super();
-
-        this->value = i;
-    }
+    explicit Leaf(int i) : value(i){
+                                   //            std::cout << "creating " << this << ": Leaf " << value << std::endl;
+                           };
 
     // @Override
     /**
          * Returns a string representation of the leaf. It is simply the string
          * representation of the leaf label.
          */
-    std::string &toString() {
-        return Integer.toString(value);
+    std::string toString() {
+        return std::to_string(value);
     }
 
     // @Override
@@ -41,7 +41,9 @@ struct Leaf : Node {
 
     // @Override
     Bigint getPossibleOrders(bool root) {
-        return Bigint.ONE;
+        return 1;
     }
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/Node.h b/libraries/zanettiPQR/Node.h
index 8f7ef79..82eca02 100644
--- a/libraries/zanettiPQR/Node.h
+++ b/libraries/zanettiPQR/Node.h
@@ -1,6 +1,14 @@
 #pragma once
 
 #include "Color.h"
+#include "NodeRef.hpp"
+#include <ogdf/basic/memory.h>
+
+#include <array>
+#include <bigInt/bigint.h>
+#include <set>
+
+using namespace Dodecahedron;
 
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
@@ -12,63 +20,64 @@ struct Node {
     /**
          * Stores the color of the node when it is defined.
          */
-    Color color;
+    Color color = Color::WHITE;
 
     /**
-         * The parent of the node. It is only set if the parent is a P-node or
-         * if this node is the representative node among all its siblings in
-         * the union-find structure.
+         * The parent of the node. It is only set if the parent is a P-node or if this
+         * node is the representative node among all its siblings in the union-find
+         * structure.
          */
-    Node *parent;
+    PQRNode *parent = nullptr;
     /**
-         * If this is a non-representative child of a Q/R-node, 
-         * points to a sibling node above it in the union-find tree.
-         * Otherwise, points to itself.
+         * If this is a non-representative child of a Q/R-node, points to a sibling node
+         * above it in the union-find tree. Otherwise, points to itself.
          */
-    Node *representant;
+    NodeRef representant;
     /**
-         * Rank of the node in the union-find tree. It is zero if the node is not
-         * part of a union-find structure.
+         * Rank of the node in the union-find tree. It is zero if the node is not part
+         * of a union-find structure.
          */
-    int rank;
+    int rank = 0;
 
     /**
-         * Holds the two immediate siblings of this node. This forms a symmetric 
-         * list. No assumption at all can be made from siblings. The only way of
-         * knowing which is "previous" and which is "next" is while traversing the
-         * list. "Previous" is the one the traversal came from, "next" is the
-         * opposite.
+         * Holds the two immediate siblings of this node. This forms a symmetric list.
+         * No assumption at all can be made from siblings. The only way of knowing which
+         * is "previous" and which is "next" is while traversing the list. "Previous" is
+         * the one the traversal came from, "next" is the opposite.
          */
-    std::array<Node *, 2> sibling;
+    std::array<Node *, 2> sibling{nullptr, nullptr};
 
     /**
          * Marks whether the node has been visited during the reduction.
          */
-    bool visited;
+    bool visited = false;
     /**
          * The number of pertinent children of this.
          */
-    int pertinentChildCount;
+    int pertinentChildCount = 0;
     /**
          * the number of pertinent leaves in the subtree rooted by this.
          */
-    int pertinentLeafCount;
+    int pertinentLeafCount = 0;
 
-    Node() {
-        super();
-
-        this->color = Color::WHITE;
-
-        this->parent = nullptr;
-        this->representant = this;
-        this->rank = 0;
+    /**
+         * How many children in the Union Find data structure point to us.
+         */
+    int cNodeRefs = 0;
+#ifdef OGDF_DEBUG
+    std::set<void *> cNodeRefObjs;
+#endif
+    /**
+         * Whether the node has been deleted from the tree. Nodes can be removed from
+         * the tree but still be needed for the union-find tree structure. In this case
+         * they are removed from the tree, marked as deleted, but kept in the union-find
+         * tree.
+         */
+    bool deleted = false;
 
-        this->sibling = new Node[2];
+    Node() : representant(this) { representant = this; };
 
-        this->visited = false;
-        this->pertinentChildCount = 0;
-        this->pertinentLeafCount = 0;
-    }
+    virtual ~Node() = default;
 
     Color getColor() {
         return color;
@@ -81,13 +90,13 @@ struct Node {
          * @return The representative sibling of this node.
          */
     Node *find() {
-        if (this->representant != this) {
-            this->representant = this->representant->find();
+        if (representant != this) {
+            setRepresentant(this->representant->find());
         }
         return this->representant;
     }
 
-    Node *getParent() {
+    PQRNode *getParent() {
         if (this->representant == this) {
             return parent;
         } else {
@@ -95,37 +104,22 @@ struct Node {
         }
     }
 
-    void setColor(Color color) {
-        this->color = color;
+    void setColor(Color color);
 
-        if (color == Color::GRAY) {
-            this->getParent()->addGrayChild(this);
-        }
-        if (color == Color::BLACK) {
-            this->getParent()->addBlackChild(this);
-        }
-    }
-
-    void setParent(Node *parent) {
-        if (parent == nullptr) {
-            this->parent = nullptr;
-            this->representant = this;
-        } else if (parent->getType() == PQRType::P) {
-            this->parent = parent;
-            this->representant = this;
-        } else if (parent->getChildCount() == 0) {
-            this->parent = parent;
-            this->representant = this;
-        } else {
-            this->parent = nullptr;
-            this->representant = parent->getRepresentativeChild();
-        }
-    }
+    void setParent(PQRNode *parent);
 
     void setRepresentant(Node *v) {
         this->representant = v;
     }
 
+    /**
+         * Remove the node from its parent and mark it as deleted. Nodes are not
+         * actually destroyed because they might be part of a union-find tree.
+         */
+    void destroy(bool remove = true);
+
+    void maybeDeleteSelf();
+
     int getRank() {
         return this->rank;
     }
@@ -135,15 +129,15 @@ struct Node {
     }
 
     /**
-         * Tests whether every children of the node are colored black. A leaf
-         * has no children, so it always tests true.
+         * Tests whether every children of the node are colored black. A leaf has no
+         * children, so it always tests true.
          * 
-         * @return true if all the children of the node are colored black 
-         * (of if the node is a leaf), false otherwise.
+         * @return true if all the children of the node are colored black (of if the
+         *         node is a leaf), false otherwise.
          */
-    bool areAllChildrenBlack();
+    virtual bool areAllChildrenBlack() = 0;
 
-    void cleanUp() {
+    virtual void cleanUp() {
         this->color = Color::WHITE;
         this->visited = false;
         this->pertinentChildCount = 0;
@@ -174,6 +168,10 @@ struct Node {
         this->pertinentLeafCount = n;
     }
 
-    Bigint getPossibleOrders(bool root);
+    virtual Bigint getPossibleOrders(bool root) = 0;
+
+    virtual std::string toString() = 0;
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/PQRNode.h b/libraries/zanettiPQR/PQRNode.h
index 4373385..98b0cc3 100644
--- a/libraries/zanettiPQR/PQRNode.h
+++ b/libraries/zanettiPQR/PQRNode.h
@@ -4,6 +4,9 @@
 
 #include "Node.h"
 
+#include <deque>
+#include <sstream>
+
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
 
@@ -11,61 +14,51 @@ namespace cpp_zanetti {
 // import java.util.Iterator;
 // import java.util.std::deque;
 
+template<typename Node>
+Node *poll(std::deque<Node *> &queue) {
+    if (queue.empty()) return nullptr;
+    Node *val = queue.front();
+    queue.pop_front();
+    return val;
+}
+
 struct PQRNode : Node {
 
     /**
          * The first child of the node.
          */
-    Node *firstChild;
+    Node *firstChild = nullptr;
     /**
          * The last child of the node.
          */
-    Node *lastChild;
+    Node *lastChild = nullptr;
     /**
-         * The child that is the representant of the union-find structure of 
-         * this node's children. It is only set if this node has type Q or R.
+         * The child that is the representant of the union-find structure of this node's
+         * children. It is only set if this node has type Q or R.
          */
-    Node *representativeChild;
+    Node *representativeChild = nullptr;
     /**
          * Number of children of the node.
          */
-    int childCount;
+    int childCount = 0;
 
     /**
          * The type of the node --- P, Q or R.
          */
     PQRType type;
-    /**
-         * Whether the node has been deleted from the tree.
-         * Nodes can be removed from the tree but still be needed for the union-find
-         * tree structure. In this case they are removed from the tree, marked as
-         * deleted, but kept in the union-find tree.
-         */
-    bool deleted;
 
     /**
          * A list that stores the gray children of the node.
          */
-    const std::deque<Node> grayChildren;
+    std::deque<Node *> grayChildren;
     /**
          * A list that stores the black children of the node.
          */
-    const std::deque<Node> blackChildren;
-
-    PQRNode(PQRType type) {
-        super();
-
-        this->firstChild = nullptr;
-        this->lastChild = nullptr;
-        this->representativeChild = nullptr;
-        this->childCount = 0;
-
-        this->type = type;
-        this->deleted = false;
+    std::deque<Node *> blackChildren;
 
-        this->grayChildren = new std::deque<>();
-        this->blackChildren = new std::deque<>();
-    }
+    explicit PQRNode(PQRType type) : type(type){
+                                             //            std::cout << "creating " << this << ": " << (type == PQRType::P ? "P" : "Q") << " node" << std::endl;
+                                     };
 
     /**
          * Returns the type of the node.
@@ -85,10 +78,6 @@ struct PQRNode : Node {
         this->type = type;
     }
 
-    bool isDeleted() {
-        return deleted;
-    }
-
     int getChildCount() {
         return this->childCount;
     }
@@ -110,13 +99,13 @@ struct PQRNode : Node {
     }
 
     PQRNode *getGrayChild() {
-        return (PQRNode) poll(this->grayChildren);
+        return dynamic_cast<PQRNode *>(poll(this->grayChildren));
     }
 
     /**
-         * Add a node as a child of this node, without caring about its position.
-         * Use it when this node has type P or R. Assumes v was already completely 
-         * removed from any other parent node.
+         * Add a node as a child of this node, without caring about its position. Use it
+         * when this node has type P or R. Assumes v was already completely removed from
+         * any other parent node.
          * 
          * @param v The node to be added as a child.
          */
@@ -125,9 +114,8 @@ struct PQRNode : Node {
     }
 
     /**
-         * Add a node as the first child of this node. Use it when this node is a 
-         * Q-node. Assumes v was already completely removed from any other parent
-         * node.
+         * Add a node as the first child of this node. Use it when this node is a
+         * Q-node. Assumes v was already completely removed from any other parent node.
          * 
          * @param v The node to be added as a child.
          */
@@ -165,13 +153,12 @@ struct PQRNode : Node {
     }
 
     /**
-         * Add a node as the last child of this node. Use it when this node is a 
-         * Q-node Assumes v was already completely removed from any other parent 
-         * node.
+         * Add a node as the last child of this node. Use it when this node is a Q-node
+         * Assumes v was already completely removed from any other parent node.
          * 
          * @param v The node to be added as a child.
          * 
-         * @see PQRNode#insertBeginning(java_evaluation.jppzanetti.Node) 
+         * @see PQRNode#insertBeginning(pqrtree.Node)
          */
     void insertEnd(Node *v) {
         v->setParent(this);
@@ -207,14 +194,14 @@ struct PQRNode : Node {
     }
 
     /**
-         * Insert node v as a child of this node, between nodes i and j. Nodes i and
-         * j have to consecutive siblings.
+         * Insert node v as a child of this node, between nodes i and j. Nodes i and j
+         * have to consecutive siblings.
          * 
          * @param v The new child.
          * @param i Child of this node, linked to j.
          * @param j Child of this node, linked to i.
          * 
-         * @see PQRNode#insertBeginning(java_evaluation.jppzanetti.Node) 
+         * @see PQRNode#insertBeginning(pqrtree.Node)
          */
     void insertBetween(Node *v, Node *i, Node *j) {
         v->sibling[0] = i;
@@ -295,18 +282,6 @@ struct PQRNode : Node {
         v->sibling[1] = nullptr;
     }
 
-    /**
-         * Remove the node from its parent and mark it as deleted. Nodes are not 
-         * actually destroyed because they might be part of a union-find tree.
-         */
-    void destroy() {
-        PQRNode *p = this->getParent();
-        if (p != nullptr) {
-            p->removeChild(this);
-        }
-        this->deleted = true;
-    }
-
     /**
          * Invert the order of the children of the node.
          */
@@ -415,9 +390,24 @@ struct PQRNode : Node {
         if (this->getChildCount() == 1) {
             this->removeChild(v);
             if (this->getParent() != nullptr) {
-                this->getParent().insertEnd(v);
+                dynamic_cast<PQRNode *>(this->getParent())->insertEnd(v);
             }
             this->destroy();
+            // FIXME:
+            //            PQRNode         * parent = this.getParent();
+            //            System.out.println("weird1");
+            //            if (parent != nullptr) {
+            //                System.out.println("weird2");
+            //                parent.replaceChild(this, v);
+            //                if (parent.type == PQRType::Q && parent.representativeChild == this) {
+            //                    System.out.println("weird3");
+            //                    parent.representativeChild = v;
+            //                    v.parent = parent;
+            //                    v.representant = v;
+            //                    this.representant = v;
+            //                }
+            //            }
+            //            this.deleted = true;
         }
     }
 
@@ -430,7 +420,7 @@ struct PQRNode : Node {
     }
 
     bool mergeIntoLCA() {
-        PQRNode *r = this->getParent();
+        PQRNode *r = dynamic_cast<PQRNode *>(this->getParent());
 
         // Union
         Node *thisRep = this->getRepresentativeChild();
@@ -525,8 +515,8 @@ struct PQRNode : Node {
 
         // Update LCA child count and colored children lists
         r->childCount = r->childCount + this->childCount;
-        r->blackChildren.addAll(this->blackChildren);
-        r->grayChildren.addAll(this->grayChildren);
+        r->blackChildren.insert(r->blackChildren.end(), this->blackChildren.begin(), this->blackChildren.end());
+        r->grayChildren.insert(r->grayChildren.end(), this->grayChildren.begin(), this->grayChildren.end());
 
         // Destroy this node
         this->sibling[0] = nullptr;
@@ -536,7 +526,7 @@ struct PQRNode : Node {
     }
 
     void mergePNode() {
-        PQRNode *r = this->getParent();
+        PQRNode *r = dynamic_cast<PQRNode *>(this->getParent());
 
         // Determine darkest direction
         Node *lightestDir = this->sibling[0];
@@ -591,8 +581,7 @@ struct PQRNode : Node {
 
     /*
          **************************************
-         * Operations to adjust the LCA         *
-         * after repairing all gray children.         *
+         * Operations to adjust the LCA         * after repairing all gray children.         *
          **************************************
          */
     bool adjust() {
@@ -614,10 +603,10 @@ struct PQRNode : Node {
     bool adjustQ() {
         int whiteCount = 0;
         for (Node *b : this->blackChildren) {
-            if ((b->sibling[0] == nullptr) || (b->sibling[0].getColor() == Color::WHITE)) {
+            if ((b->sibling[0] == nullptr) || (b->sibling[0]->getColor() == Color::WHITE)) {
                 whiteCount++;
             }
-            if ((b->sibling[1] == nullptr) || (b->sibling[1].getColor() == Color::WHITE)) {
+            if ((b->sibling[1] == nullptr) || (b->sibling[1]->getColor() == Color::WHITE)) {
                 whiteCount++;
             }
         }
@@ -632,7 +621,7 @@ struct PQRNode : Node {
 
     // @Override
     void cleanUp() {
-        super.cleanUp();
+        Node::cleanUp();
 
         this->grayChildren.clear();
         this->blackChildren.clear();
@@ -651,8 +640,8 @@ struct PQRNode : Node {
          * @see PQRTree.toString()
          */
     // @Override
-    std::string &toString() {
-        std::string &s = "";
+    std::string toString() {
+        std::stringstream s;
 
         switch (this->type) {
             case PQRType::P:
@@ -707,7 +696,7 @@ struct PQRNode : Node {
                 break;
         }
 
-        return s;
+        return s.str();
     }
 
     // @Override
@@ -738,19 +727,20 @@ struct PQRNode : Node {
 
     // @Override
     Bigint getPossibleOrders(bool root) {
-        Bigint orders = Bigint.ONE;
+        Bigint orders = 1;
         switch (type) {
-            case PQRType::P:
+            case PQRType::P: {
                 int num = root ? getChildCount() - 1 : getChildCount();
                 for (int i = 2; i <= num; i++) {
-                    orders = orders.multiply(Bigint.valueOf(i));
+                    orders *= i;
                 }
                 break;
+            }
             case PQRType::Q:
-                orders = orders.multiply(Bigint.valueOf(2));
+                orders *= 2;
                 break;
             case PQRType::R:
-                return Bigint.ZERO;
+                return 0;
             default:
                 break;
         }
@@ -760,7 +750,7 @@ struct PQRNode : Node {
         Node *prevChild = nullptr;
         int nextChild;
         while (child != nullptr) {
-            orders = orders.multiply(child->getPossibleOrders(false));
+            orders *= child->getPossibleOrders(false);
 
             // Get next child
             if (child->sibling[0] == prevChild) {
@@ -775,23 +765,29 @@ struct PQRNode : Node {
         return orders;
     }
 
-    template<>
-    static struct ChildIterator {
-        Node *pred;
+    struct ChildIterator {
+        using iterator_category = std::forward_iterator_tag;
+        using value_type = PQRNode;
+        using pointer = PQRNode *;
+        using reference = PQRNode &;
+        using difference_type = std::ptrdiff_t;
+
+        Node *pred = nullptr;
         Node *next;
 
-        ChildIterator(Node *next) {
-            this->pred = nullptr;
-            this->next = next;
-        }
+        ChildIterator(Node *next, Node *pred = nullptr) : next(next), pred(pred) {}
 
         // @Override
         bool hasNext() {
             return next != nullptr;
         }
 
+        Node *operator*() const {
+            return next;
+        }
+
         // @Override
-        Node *next() {
+        ChildIterator &operator++() {
             if (pred == next->sibling[0]) {
                 pred = next;
                 next = pred->sibling[1];
@@ -799,14 +795,26 @@ struct PQRNode : Node {
                 pred = next;
                 next = pred->sibling[0];
             }
-            return pred;
+            return *this;
+        }
+
+        bool operator==(const ChildIterator &rhs) const {
+            return next == rhs.next;
+        }
+
+        bool operator!=(const ChildIterator &rhs) const {
+            return !(rhs == *this);
         }
     };
 
-    // @Override
-    Iterator<Node>;
-    iterator() {
-        return new ChildIterator(firstChild);
+    ChildIterator begin() const {
+        return ChildIterator(firstChild);
     }
+
+    ChildIterator end() const {
+        return ChildIterator(nullptr, lastChild);
+    }
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/PQRTree.h b/libraries/zanettiPQR/PQRTree.h
index f224649..a0895f0 100644
--- a/libraries/zanettiPQR/PQRTree.h
+++ b/libraries/zanettiPQR/PQRTree.h
@@ -4,6 +4,17 @@
 
 #include "PQRNode.h"
 
+#include <list>
+#include <queue>
+#include <set>
+#include <stack>
+#include <variant>
+
+#define MY_ASSERT(expr)                                                        \
+    if (!(expr)) {                                                             \
+        throw std::runtime_error("Assertion failed while computing uniqueID"); \
+    }
+
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
 
@@ -15,12 +26,12 @@ namespace cpp_zanetti {
          * updates a PQR-tree according to the given constraint sets.
          * <p>
          * <b>Usage:</b>
-         * 
-         * The first step is to build a initial (universal) tree, with 
+         *
+         * The first step is to build a initial (universal) tree, with
          * PQRTree.PQRTree(n). This tree has n leaves, labeled from 0 to n - 1.
-         * 
+         *
          * Then, constraints can be added to the tree one by one using PQRTree.reduce().
-         * 
+         *
          * @author Joao
          */
 struct PQRTree {
@@ -33,76 +44,86 @@ struct PQRTree {
     /**
          * An array of all the leaves.
          */
-    const std::vector<Leaf> leaf;
+    std::vector<Leaf *> leaf;
 
     /**
          * A list to hold all nodes that are visited during the reduction process.
          */
-    const std::deque<PQRNode> visitedNodes;
+    std::deque<NodeRef> visitedNodes;
 
     /**
          * Builds and returns an universal tree with n leaves.
-         * 
-         * @param n The number of leaves in the tree. 
+         *
+         * @param n The number of leaves in the tree.
          */
-    PQRTree(int n) {
-        super();
-
+    PQRTree(int n, std::vector<Leaf *> &newLeaves) {
         // Create root
         this->root = new PQRNode(PQRType::P);
 
-        // Create the leaf list
-        this->leaf = new std::vector<>(n);
-
         // Create and insert leaves
+        leaf.reserve(n);
         for (int i = 0; i < n; i++) {
-            this->leaf.push_back(i, new Leaf(i));
-            this->root->insertEnd(leaf.get(i));
-            //            // assert this.leaf.get(i).value == i;
+            Leaf *l = new Leaf(i);
+            l->arrayIndex = this->leaf.size();
+            this->leaf.push_back(l);
+            this->root->insertEnd(l);
+            newLeaves.push_back(l);
+            // assert this.leaf.get(i).value == i;
         }
+    }
 
-        this->visitedNodes = new std::deque<>();
+    virtual ~PQRTree() {
+        std::vector<Node *> toDelete(leaf.begin(), leaf.end());
+        while (!toDelete.empty()) {
+            Node *l = toDelete.back();
+            toDelete.pop_back();
+            PQRNode *p = dynamic_cast<PQRNode *>(l->getParent());
+            l->destroy();
+            if (p != nullptr && p->childCount == 0) {
+                toDelete.push_back(p);
+            }
+        }
     }
 
     /**
          * Adds one constraint set to the tree, updating its structure as necessary.
-         * 
+         *
          * @param c An array of integers that must be consecutive.
          */
-    bool reduce(std::vector<Leaf *> &c) {
+    bool reduce(const std::vector<Leaf *> &c) {
         if (c.size() < 2) {
             return true;
         }
 
+        //OGDF_ASSERT(checkValid());
         PQRNode *r = this->bubble(c);
         r = this->repairGray(r);
         if (r == nullptr) return false;
         if (!r->adjust()) return false;
         this->uncolor(c);
+        //OGDF_ASSERT(checkValid());
         return true;
     }
 
     /**
          * Colors the tree with regards to the new constraint.
-         * 
+         *
          * @param c The constraint being added.
-         * @return The least common ancestor (LCA) of all the pertinent nodes.
-         *         This is the node that serves as the start for the updates to the
-         *         tree.
+         * @return The least common ancestor (LCA) of all the pertinent nodes. This is
+         *         the node that serves as the start for the updates to the tree.
          */
-    PQRNode *bubble(std::vector<Leaf *> &c) {
-        std::deque<Node> queue = new std::deque<>();
+    PQRNode *bubble(const std::vector<Leaf *> &c) {
+        std::deque<Node *> queue;
         int offTheTop = 0;
 
         // First phase: count the pertinent children of each node
-        for (int i : c) {
-            //            // assert this.leaf.get(i).value == i;
-            this->leaf.get(i).visit();
-            queue.push_back(this->leaf.get(i));
+        for (Leaf *l : c) {
+            l->visit();
+            queue.push_back(l);
         }
         while (queue.size() + offTheTop > 1) {
             Node *v = poll(queue);
-            PQRNode *p = v.getParent();
+            Node *p = v->getParent();
 
             if (p == nullptr) {
                 offTheTop = 1;
@@ -110,7 +131,7 @@ struct PQRTree {
                 if (!p->isVisited()) {
                     queue.push_back(p);
                     p->visit();
-                    this->visitedNodes.push_back(p);
+                    this->visitedNodes.emplace_back(nullptr, p);
                 }
                 p->setPertinentChildCount(p->getPertinentChildCount() + 1);
             }
@@ -118,16 +139,16 @@ struct PQRTree {
 
         // Second phase: color the nodes and find the LCA
         queue.clear();
-        for (int i : c) {
-            this->leaf.get(i).setPertinentLeafCount(1);
-            queue.push_back(this->leaf.get(i));
+        for (Leaf *l : c) {
+            l->setPertinentLeafCount(1);
+            queue.push_back(l);
         }
         while (!queue.empty()) {
             Node *v = poll(queue);
             Node *p = v->getParent();
 
             if (v->getPertinentLeafCount() == c.size()) {
-                return (PQRNode) v;
+                return (PQRNode *) v;
             }
 
             if (v->areAllChildrenBlack()) {
@@ -142,13 +163,13 @@ struct PQRTree {
                 queue.push_back(p);
             }
         }
-        throw new AssertionError();
-        //        return nullptr;
+        throw std::runtime_error("bubble didn't find apex");
+        //		return nullptr;
     }
 
     /**
          * Updates the colored tree, eliminating all gray nodes.
-         * 
+         *
          * @param r The LCA.
          * @return The LCA after the repair.
          */
@@ -190,64 +211,64 @@ struct PQRTree {
 
     /**
          * Resets the tree after the reduction.
-         * 
+         *
          * @param c The constraint just added.
          */
-    void uncolor(std::vector<Leaf *> &c) {
-        for (int i : c) {
-            this->leaf.get(i).cleanUp();
+    void uncolor(const std::vector<Leaf *> &c) {
+        for (Leaf *l : c) {
+            l->cleanUp();
 
-            PQRNode *p = this->leaf.get(i).getParent();
+            Node *p = l->getParent();
             if ((p != nullptr) && (p->isVisited())) {
                 p->cleanUp();
-                this->visitedNodes.push_back(p);
+                this->visitedNodes.emplace_back(nullptr, p);
             }
         }
         while (!this->visitedNodes.empty()) {
-            PQRNode *v = poll(this->visitedNodes);
+            Node *v = this->visitedNodes.front();
             v->cleanUp();
 
-            PQRNode *p = v->getParent();
+            Node *p = v->getParent();
             if ((p != nullptr) && (p->isVisited())) {
                 p->cleanUp();
-                this->visitedNodes.push_back(p);
+                this->visitedNodes.emplace_back(nullptr, p);
             }
+            this->visitedNodes.pop_front();
         }
     }
 
     /**
-         * Returns a string representation of the PQR tree. It uses a variant of
-         * the nested parenthesis method of representing trees in text, in which
-         * the type of the node is denoted by the type of brackets used: 
-         * 
+         * Returns a string representation of the PQR tree. It uses a variant of the
+         * nested parenthesis method of representing trees in text, in which the type of
+         * the node is denoted by the type of brackets used:
+         *
          * <ul>
          * <li>P-nodes are represented by parenthesis ()
          * <li>Q-nodes are represented by square brackets []
          * <li>R-nodes are represented by curly braces {}
          * </ul>
-         * 
+         *
          * Examples:
-         * 
-         * A universal tree with 5 leaves is represented by the string
-         * "(0 1 2 3 4)".
-         * 
+         *
+         * A universal tree with 5 leaves is represented by the string "(0 1 2 3 4)".
+         *
          * @return The string representation of the tree.
          */
     // @Override
-    std::string &toString() {
+    std::string toString() {
         return root->toString();
     }
 
-    std::string &uniqueID() {
-        return uniqueID(true, true);
+    Bigint getPossibleOrders() {
+        return root->getPossibleOrders(true);
     }
 
     Node *getNeighbor(Node *node, Node *neighbor) {
-        if (neighbor instanceof Leaf || neighbor == nullptr) {
+        if (dynamic_cast<Leaf *>(neighbor) || neighbor == nullptr) {
             return neighbor;
         }
 
-        PQRNode *n = (PQRNode) neighbor;
+        PQRNode *n = dynamic_cast<PQRNode *>(neighbor);
         int deg = n->getChildCount();
         if (n != root)
             deg++;
@@ -256,229 +277,240 @@ struct PQRTree {
         if (deg != 2) {
             return neighbor;
         } else {
-            List<Node> neighbors = new std::deque<>();
-            n->iterator().forEachRemaining(neighbors::add);
+            std::list<Node *> neighbors(n->begin(), n->end());
+
             if (n != root)
                 neighbors.push_back(n->getParent());
-            // assert neighbors.size() == 2;
+            MY_ASSERT(neighbors.size() == 2);
 
-            if (neighbors.get(0) == node) {
-                return getNeighbor(neighbor, neighbors.get(1));
+            if (neighbors.front() == node) {
+                return getNeighbor(neighbor, neighbors.back());
             } else {
-                // assert neighbors.get(1) == node;
-                return getNeighbor(neighbor, neighbors.get(0));
+                MY_ASSERT(neighbors.back() == node);
+                return getNeighbor(neighbor, neighbors.front());
             }
         }
     }
 
-    std::string &uniqueID(bool normalizeLeafIDs, bool includeInnerNodeOrder) {
+    std::string uniqueID() {
         if (root == nullptr) {
             return "empty";
         }
-        std::stringstream sb = new std::stringstream();
-
-        List<Node> labelingQueue = new std::deque<>(leaf);
-        labelingQueue.sort(Comparator.comparingInt(a->a == nullptr ? Integer.MAX_VALUE : ((Leaf) a).value));
-        while (labelingQueue.get(labelingQueue.size() - 1) == nullptr)
-            labelingQueue.remove(labelingQueue.size() - 1);
-        Leaf *lastLeaf = (Leaf) labelingQueue.get(labelingQueue.size() - 1);
-
-        List<Node> fullNodeOrder = new std::deque<>();
-        HashMap<Node, Integer> order = new HashMap<>();
-        HashMap<Node, Integer> fullNeighborCount = new HashMap<>();
+        std::stringstream sb;
+
+        std::deque<Node *> labelingQueue;
+        std::copy_if(leaf.begin(), leaf.end(), std::back_inserter(labelingQueue),
+                     [](Leaf *l) { return l != nullptr; });
+        std::sort(labelingQueue.begin(), labelingQueue.end(),
+                  [](Node *a, Node *b) { return dynamic_cast<Leaf *>(a)->value < dynamic_cast<Leaf *>(b)->value; });
+        Leaf *lastLeaf = dynamic_cast<Leaf *>(labelingQueue.back());
+
+        std::vector<Node *> fullNodeOrder;
+        std::map<Node *, int> order;
+        std::map<Node *, int> fullNeighborCount;
         while (!labelingQueue.empty()) {
-            Node *node = labelingQueue.remove(0);
+            Node *node = labelingQueue.front();
+            labelingQueue.pop_front();
             Node *parent = getNeighbor(node, node->getParent());
 
-            order.put(node, fullNodeOrder.size());
+            order[node] = fullNodeOrder.size();
             fullNodeOrder.push_back(node);
 
             if (node == lastLeaf) continue;
 
-            if (node == root || parent == nullptr || order.containsKey(parent)) {
+            if (node == root || parent == nullptr || order.count(parent) != 0) {
                 parent = nullptr;
-                for (Node *curr : (PQRNode) node) {
-                    if (!order.containsKey(curr)) {
-                        parent = (PQRNode) curr;
+                for (Node *curr : *dynamic_cast<PQRNode *>(node)) {
+                    if (order.count(curr) == 0) {
+                        parent = dynamic_cast<PQRNode *>(curr);
                         break;
                     }
                 }
                 if (parent == nullptr) {
-                    // assert labelingQueue.empty();
+                    MY_ASSERT(labelingQueue.empty());
                     continue;
                 }
             }
-            // assert parent != nullptr;
-            // assert !order.containsKey(parent);
+            MY_ASSERT(parent != nullptr);
+            MY_ASSERT(order.count(parent) == 0);
 
-            fullNeighborCount.put(parent, fullNeighborCount.getOrDefault(parent, 0) + 1);
-            int pDeg = parent;
-            instanceof Leaf ? 1 : ((PQRNode) parent).getChildCount();
+            ++fullNeighborCount[parent];
+            int pDeg = dynamic_cast<Leaf *>(parent) ? 1 : (dynamic_cast<PQRNode *>(parent))->getChildCount();
             if (parent != root) pDeg++;
-            if (fullNeighborCount.get(parent) == pDeg - 1) {
+            if (fullNeighborCount[parent] == pDeg - 1) {
                 labelingQueue.push_back(parent);
             } else {
-                // assert fullNeighborCount.get(parent) < pDeg - 1;
+                MY_ASSERT(fullNeighborCount[parent] < pDeg - 1);
             }
         }
 
-        List<Object> stack = new std::deque<>();
-        stack.push_back(fullNodeOrder.get(fullNodeOrder.size() - 1));
+        std::vector<std::variant<std::string, Node *>> stack{fullNodeOrder.back()};
         while (!stack.empty()) {
-            Object next = stack.remove(stack.size() - 1);
-            if (next instanceof std::string &) {
-                sb << (next);
+            auto next = stack.back();
+            stack.pop_back();
+
+            if (std::holds_alternative<std::string>(next)) {
+                sb << std::get<std::string>(next);
                 continue;
-            } else if (next instanceof Leaf) {
-                if (normalizeLeafIDs)
-                    sb << (order.get(next));
-                else
-                    sb << (((Leaf) next).value);
+            } else if (Leaf *l = dynamic_cast<Leaf *>(std::get<Node *>(next))) {
+                sb << order[l];
                 continue;
             }
 
-            PQRNode *node = (PQRNode) next;
-            List<Node> children = new std::deque<>();
-            node->iterator().forEachRemaining(child->children.push_back(getNeighbor(node, child)));
-            // assert children.size() == node.getChildCount();
+            auto *node = dynamic_cast<PQRNode *>(std::get<Node *>(next));
+            std::deque<Node *> children;
+            for (Node *child : *node) {
+                children.push_back(getNeighbor(node, child));
+            }
+            MY_ASSERT(children.size() == node->getChildCount());
             if (node != root)
                 children.push_back(getNeighbor(node, node->getParent()));
             int degree = children.size();
 
             PQRNode *informedNeighbor = nullptr;
-            if (node != fullNodeOrder.get(fullNodeOrder.size() - 1)) {
-                for (int j = 0; order.get(children.get(0)) < order.get(node); j++) {
-                    // assert j <= node.getChildCount() + 1;
-                    children.push_back(children.remove(0));
+            if (node != fullNodeOrder.back()) {
+                for (int j = 0; order[children.front()] < order[node]; j++) {
+                    MY_ASSERT(j <= node->getChildCount() + 1);
+                    children.push_back(children.front());
+                    children.pop_front();
                 }
-                informedNeighbor = (PQRNode) children.remove(0);
-                // assert order.get(informedNeighbor) > order.get(node);
+                informedNeighbor = dynamic_cast<PQRNode *>(children.front());
+                children.pop_front();
+                MY_ASSERT(order[informedNeighbor] > order[node]);
             }
 
-            if (includeInnerNodeOrder) sb << (order.get(node)) << (":");
+            sb << order[node] << ":";
             if (node->getType() == PQRType::Q) {
-                sb << ("[");
-                stack.push_back("]");
-                if (node == fullNodeOrder.get(fullNodeOrder.size() - 1)) {
-                    Node *minChild = Collections.min(children, Comparator.comparingInt(order::get));
-                    for (int j = 0; children.get(0) != minChild; j++) {
-                        // assert j <= node.getChildCount() + 1;
-                        children.push_back(children.remove(0));
+                sb << "[";
+                stack.emplace_back("]");
+                if (node == fullNodeOrder.back()) {
+                    Node *minChild = *std::min_element(children.begin(), children.end(),
+                                                       [&](Node *n1, Node *n2) { return order[n1] < order[n2]; });
+                    for (int j = 0; children.front() != minChild; j++) {
+                        MY_ASSERT(j <= node->getChildCount() + 1);
+                        children.push_back(children.front());
+                        children.pop_front();
                     }
-                    Node *second = children.get(1);
-                    if (order.get(second) > order.get(children.get(children.size() - 1))) {
-                        children.push_back(children.remove(0));
-                        Collections.reverse(children);
+                    Node *second = *std::next(children.begin());
+                    if (order[second] > order[children.back()]) {
+                        children.push_back(children.front());
+                        children.pop_front();
+                        std::reverse(children.begin(), children.end());
                     }
-                    second = children.get(1);
-                    // assert (children.get(0) == minChild);
-                    // assert (order.get(second) < order.get(children.get(children.size() - 1)));
+                    second = *std::next(children.begin());
+                    MY_ASSERT(children.front() == minChild);
+                    MY_ASSERT(order[second] < order[children.back()]);
                 } else {
-                    if (order.get(children.get(0)) > order.get(children.get(children.size() - 1))) {
-                        Collections.reverse(children);
+                    if (order[children.front()] > order[children.back()]) {
+                        std::reverse(children.begin(), children.end());
                     }
                 }
             } else {
                 if (node->getType() == PQRType::R) {
-                    sb << ("XXX{");
-                    stack.push_back("}XXX");
+                    sb << "XXX{";
+                    stack.emplace_back("}XXX");
                 } else if (degree <= 3) {
-                    sb << ("[");
-                    stack.push_back("]");
+                    sb << "[";
+                    stack.emplace_back("]");
                 } else {
-                    sb << ("(");
-                    stack.push_back(")");
+                    sb << "(";
+                    stack.emplace_back(")");
                 }
-                children.sort(Comparator.comparingInt(order::get));
+                std::sort(children.begin(), children.end(),
+                          [&](auto *n1, auto *n2) { return order[n1] < order[n2]; });
             }
 
-            //            // assert (node == fullNodeOrder.get(fullNodeOrder.size() - 1)) == (lastLeaf.getParent() == node);
-            // assert (order.get(children.get(0)) < order.get(children.get(children.size() - 1)));
+            //                MY_ASSERT(node == fullNodeOrder.back() == (lastLeaf->getParent() == node));
+            MY_ASSERT(order[children.front()] < order[children.back()]);
 
             bool space = false;
             for (Node *child : children) {
                 if (space)
-                    stack.push_back(", ");
+                    stack.emplace_back(", ");
                 stack.push_back(child);
                 space = true;
             }
         }
 
-        return sb.toString();
+        return sb.str();
     }
 
-    Bigint getPossibleOrders() {
-        return root->getPossibleOrders(true);
+    void deleteLeaf(Leaf *l, PQRNode *p) {
+        Node *c = p->firstChild;
+        if (p->representativeChild == l) {
+            p->setRepresentativeChild(c);
+            l->setParent(p);
+            c->setParent(p);
+        }
+        l->destroy(false);
+        if (leaf.size() > 1) {
+            auto last = leaf.end() - 1;
+            (*last)->arrayIndex = l->arrayIndex;
+            std::iter_swap(leaf.begin() + l->arrayIndex, last);
+            leaf.pop_back();
+        } else {
+            leaf.clear();
+        }
+        if (p->getChildCount() == 1) {
+            PQRNode *pp = dynamic_cast<PQRNode *>(p->getParent());
+            pp->replaceChild(p, c);
+            if (pp->representativeChild == p) {
+                pp->setRepresentativeChild(c);
+                p->setParent(pp);
+                c->setParent(pp);
+            }
+            p->destroy(false);
+        }
     }
 
-    void mergeAndReplaceLeaves(int[] oldLeaves, int[] newLeaves) {
-        //        {
-        //            PQRNode         * parent = leaf.get(oldLeaves[0]).getParent();
-        //            System.out.println("replace " + Arrays.toString(oldLeaves) + " with " + Arrays.toString(newLeaves) + " on parent " + parent.getType() + " " + parent);
-        //        }
-        for (int i = 0; i < oldLeaves.size() - 1; i++) {
-            Leaf *l = leaf.get(oldLeaves[i]);
-            leaf.set(oldLeaves[i], nullptr);
-            //            System.out.println("remove " + i + " = " + l.toString());
-            PQRNode *p = l->getParent();
+    void mergeAndReplaceLeaves(const std::vector<Leaf *> &oldLeaves, const std::vector<int> &newLeafIDs, std::vector<Leaf *> &newLeaves) {
+        Leaf *remainingLeaf = oldLeaves.back();
+        for (Leaf *l : oldLeaves) {
+            if (l == remainingLeaf) continue;
+            PQRNode *p = dynamic_cast<PQRNode *>(l->getParent());
             p->removeChild(l);
-            if (p->getChildCount() == 1) {
-                PQRNode *pp = p->getParent();
-                //                System.out.println("flatten deg-1 " + p + " into " + pp);
-                pp->replaceChild(p, p->firstChild);
-                p->firstChild->parent = pp;
-                p->firstChild->representant = p->firstChild;
-                //                System.out.println("\t" + pp);
-                //            } else {
-                //                System.out.println("\t" + p);
-            }
+            deleteLeaf(l, p);
         }
 
-        Leaf *remainingLeaf = leaf.get(oldLeaves[oldLeaves.size() - 1]);
-        leaf.set(oldLeaves[oldLeaves.size() - 1], nullptr);
         Node *newNode;
-        if (newLeaves.size() > 1) {
+        if (newLeafIDs.size() > 1) {
             newNode = new PQRNode(PQRType::P);
-            for (int i : newLeaves) {
-                while (i >= leaf.size()) {
-                    leaf.push_back(nullptr);
-                }
-                leaf.set(i, new Leaf(i));
-                ((PQRNode) newNode).insertEnd(leaf.get(i));
+            newLeaves.reserve(newLeafIDs.size());
+            for (int i : newLeafIDs) {
+                Leaf *l = new Leaf(i);
+                l->arrayIndex = leaf.size();
+                leaf.push_back(l);
+                newLeaves.push_back(l);
+                ((PQRNode *) newNode)->insertEnd(l);
             }
         } else {
-            int i = newLeaves[0];
-            newNode = new Leaf(i);
-            while (i >= leaf.size()) {
-                leaf.push_back(nullptr);
-            }
-            this->leaf.set(i, (Leaf) newNode);
+            int i = newLeafIDs[0];
+            Leaf *l = new Leaf(i);
+            l->arrayIndex = leaf.size();
+            newLeaves.push_back(l);
+            leaf.push_back(l);
+            newNode = l;
         }
-        PQRNode *parent = remainingLeaf->getParent();
-        //        System.out.println("replace " + remainingLeaf + " => " + newNode + " in " + parent);
+        PQRNode *parent = dynamic_cast<PQRNode *>(remainingLeaf->getParent());
         parent->replaceChild(remainingLeaf, newNode);
-        //        System.out.println("\t" + parent);
+        deleteLeaf(remainingLeaf, parent);
 
         fixParent(parent, newNode);
-        visitedNodes.clear();
     }
 
     void fixParent(PQRNode *parent, Node *newNode) {
         while (parent->getType() == PQRType::Q || parent->getChildCount() == 1) {
             if (parent->getChildCount() == 1) {
-                PQRNode *newParent = parent->getParent();
-                //                System.out.println("flatten deg-1 " + parent + " into " + newParent);
+                PQRNode *newParent = dynamic_cast<PQRNode *>(parent->getParent());
                 newParent->replaceChild(parent, newNode);
+                parent->destroy(false);
                 parent = newParent;
             } else if (parent->getChildCount() == 2) {
-                //                System.out.println("convert deg-2 " + parent + " into P");
                 parent->setType(PQRType::P);
-                parent->representativeChild = newNode;
-                newNode->parent = parent;
-                newNode->representant = newNode;
+                parent->setRepresentativeChild(newNode);
+                newNode->setParent(parent);
                 Node *sib = newNode->sibling[0] != nullptr ? newNode->sibling[0] : newNode->sibling[1];
-                sib->parent = parent;
-                sib->representant = newNode;
+                sib->setParent(parent);
             } else {
                 fixTree(parent, 0);
                 break;
@@ -493,37 +525,28 @@ struct PQRTree {
         Node *curr = parent->firstChild;
         int count = 0;
         while (curr != nullptr) {
-            if (parent->getType() == PQRType::P) {
-                curr->parent = parent;
-                curr->representant = curr;
-                curr->rank = 0;
+            curr->setParent(parent);
+            if (dynamic_cast<PQRNode *>(curr) && depth > 0) {
+                fixTree((PQRNode *) curr, depth - 1);
             } else {
-                curr->parent = nullptr;
-                curr->representant = parent->firstChild;
-                curr->rank = 1;
+                curr->cleanUp();
             }
-            if (curr instanceof PQRNode && depth > 0) {
-                fixTree((PQRNode) curr, depth - 1);
-            } else {
-                if (curr instanceof Leaf) {
-                    // assert leaf.get(((Leaf) curr).value) == curr;
+            if (pred == nullptr) {
+                if (parent->getType() == PQRType::Q) {
+                    parent->setRepresentativeChild(parent->firstChild);
+                    parent->firstChild->setParent(parent);
+                    parent->firstChild->rank = 0;
+                } else {
+                    parent->setRepresentativeChild(nullptr);
                 }
-                curr->cleanUp();
             }
             Node *next = curr->sibling[0] == pred ? curr->sibling[1] : curr->sibling[0];
             pred = curr;
             curr = next;
             count++;
         }
-        // assert pred == parent.lastChild;
-        // assert count == parent.getChildCount();
-        if (parent->getType() == PQRType::Q) {
-            parent->firstChild->parent = parent;
-            parent->firstChild->rank = 0;
-            parent->representativeChild = parent->firstChild;
-        } else {
-            parent->representativeChild = nullptr;
-        }
+        OGDF_ASSERT(pred == parent->lastChild);
+        OGDF_ASSERT(count == parent->childCount);
     }
 };
 }
diff --git a/libraries/zanettiPQR/PQRType.h b/libraries/zanettiPQR/PQRType.h
index 76c1cd2..e9f8271 100644
--- a/libraries/zanettiPQR/PQRType.h
+++ b/libraries/zanettiPQR/PQRType.h
@@ -4,8 +4,8 @@ namespace cpp_zanetti {
 // package java_evaluation.jppzanetti
 
 /**
-         * A simple enum class to define the types an internal node can have:
-         * P, Q, or R.
+         * A simple enum class to define the types an internal node can have: P, Q, or R.
+         * 
          * @author Joao
          */
 enum class PQRType {
-- 
2.35.1

