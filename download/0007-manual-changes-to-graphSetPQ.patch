From 4f4747cff2a5c41d5b0f09c39ff3a15a1eefaedb Mon Sep 17 00:00:00 2001
From: Simon Dominik Niko Fink <simon.fink@uni-passau.de>
Date: Sun, 27 Feb 2022 10:56:40 +0100
Subject: [PATCH 7/8] manual changes to graphSetPQ

---
 libraries/graphSetPQ/LeafNode.cpp |  141 +---
 libraries/graphSetPQ/LeafNode.h   |   19 +-
 libraries/graphSetPQ/Node.cpp     |   58 +-
 libraries/graphSetPQ/Node.h       |   43 +-
 libraries/graphSetPQ/PQtree.cpp   | 1098 ++++++++---------------------
 libraries/graphSetPQ/PQtree.h     |   55 +-
 libraries/graphSetPQ/Pnode.cpp    |  371 +---------
 libraries/graphSetPQ/Pnode.h      |   13 +-
 libraries/graphSetPQ/Qnode.cpp    |  239 +------
 libraries/graphSetPQ/Qnode.h      |   10 +-
 10 files changed, 360 insertions(+), 1687 deletions(-)

diff --git a/libraries/graphSetPQ/LeafNode.cpp b/libraries/graphSetPQ/LeafNode.cpp
index b659eec..ea89ef5 100644
--- a/libraries/graphSetPQ/LeafNode.cpp
+++ b/libraries/graphSetPQ/LeafNode.cpp
@@ -1,162 +1,37 @@
-#include ".\leafnode.h"
-#include "stdafx.h"
+#include "LeafNode.h"
 
-IMPLEMENT_DYNAMIC(CLeafnode, CNode)
-
-CLeafnode::CLeafnode(CVertex *pV, int Color) {
-    iWidth = 0;
+CLeafnode::CLeafnode() {
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
-    pNode = pV;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = Color;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 
     saved_st_N = 0;
 }
 
-CLeafnode::CLeafnode(CLeafnode *pNode) {
-    // constructor for copying
-    iWidth = pNode->iWidth;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    this->pNode = pNode->pNode;
-    saved_st_N = pNode->saved_st_N;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-}
-
-CLeafnode::~CLeafnode(void) {
-    if (pNode == NULL)
-        return;
-
-    POSITION dPos = pNode->pl_S.Find(this);
-    if (dPos)
-        pNode->pl_S.RemoveAt(dPos);
-
-    pNode = NULL;
-}
-
-int CLeafnode::CalculateWidth() {
-    iWidth = LEAFWIDTH;
-
-    return iWidth;
-}
-
-int CLeafnode::CalculateLevel(int level) {
-    iLevel = level;
-
-    return iLevel;
-}
-
-void CLeafnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    char alfa[MAX_ALFA];
-
-    // If the node is pertinent, draw it blue
-    // Choose the node depending of the type of node
-    if (LABEL == FULL)
-        pDC->SetTextColor(RGB(0, 0, 255));
-    else
-        pDC->SetTextColor(RGB(0, 0, 0));
-
-    // Draw vertex st-number
-    CRect drawRect = CRect(0, 10, LEAFWIDTH, LEVELHEIGHT);
-    drawRect.OffsetRect(Offset);
-    CRect calcRect = CRect(drawRect);
-
-    if (DEBUG_PQTREE)
-        sprintf_s(alfa, "%d (%p)\nc(%d)\nl(%d)", pNode->nST, pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-    else
-        sprintf_s(alfa, "%d", saved_st_N);
-    pDC->DrawText(CString(alfa), calcRect, DT_CENTER | DT_CALCRECT);
-
-    // If the nood is the root of the pertinent subtree, draw a gray background
-    int closer = (drawRect.Width() - calcRect.Width() > 0) ? ((drawRect.Width() - calcRect.Width()) / 2) : 0;
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        CRect ellipseRect = CRect(calcRect);
-        if (ellipseRect.Height() > ellipseRect.Width())
-            ellipseRect.InflateRect((ellipseRect.Height() - ellipseRect.Width()) / 2, 0,
-                                    (ellipseRect.Height() - ellipseRect.Width()) / 2, 0);
-        ellipseRect.OffsetRect(closer, 0);
-        pDC->Ellipse(ellipseRect);
-    }
 
-    // Draw the label for this Leaf node
-    pDC->SelectStockObject(NULL_BRUSH);
-    pDC->SetBkMode(TRANSPARENT);
-    pDC->DrawText(CString(alfa), drawRect, DT_CENTER);
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = calcRect.left + closer - 5;
-        int arrowY = calcRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // Cleaning
-    pDC->SetTextColor(RGB(0, 0, 0));
-}
-
-void CLeafnode::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CLeafnode::FindLeaves(std::list<CLeafnode *> *plQueue) {
     // This is not a leaf, add it to queue
-    plQueue->AddTail(this);
+    plQueue->push_back(this);
 }
 
 void CLeafnode::UnMatch() {
     LABEL = EMPTY;
     MARK = UNMARKED;
     bRoot = false;
-    bCurrent = false;
     bInPruned = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
 }
 
-void CLeafnode::ClearPointers() {
-    if (pNode == NULL)
-        return;
-
-    saved_st_N = pNode->nST;
-    pNode = NULL;
-}
-
-void CLeafnode::GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier) {
+void CLeafnode::GetFrontier(std::list<CNode *> *pFrontier) {
     // Include this leaf in the frontier
-    pFrontier->AddTail(this);
+    pFrontier->push_back(this);
 }
 
 
@@ -167,7 +42,7 @@ CNode *CLeafnode::SearchParent(CNode *pChild) {
 
 CNode *CLeafnode::SearchPertinentLeaf(int v) {
     // Check if this leaf is pertinent
-    if (pNode->nST == v)
+    if (saved_st_N == v)
         return this;
     else
         return NULL;
@@ -177,7 +52,7 @@ int CLeafnode::CountPertinentLeaves(int v) {
     int ret = 0;
 
     // if the leaf is pertinent, count it
-    if (pNode->nST == v)
+    if (saved_st_N == v)
         ret = 1;
     else
         ret = 0;
diff --git a/libraries/graphSetPQ/LeafNode.h b/libraries/graphSetPQ/LeafNode.h
index c76e8f7..d7d5975 100644
--- a/libraries/graphSetPQ/LeafNode.h
+++ b/libraries/graphSetPQ/LeafNode.h
@@ -1,28 +1,17 @@
 #pragma once
-#include "Vertex.h"
-#include "node.h"
+#include "Node.h"
 
 class CLeafnode : public CNode {
-    DECLARE_DYNAMIC(CLeafnode)
-
 public:
-    CVertex *pNode;
     int saved_st_N;
 
 public:
-    CLeafnode(CVertex *pV, int Color);
-    CLeafnode(CLeafnode *pNode);
+    CLeafnode();
 
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
-    virtual void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    virtual void FindLeaves(std::list<CLeafnode *> *plQueue);
     virtual void UnMatch();
-    virtual void ClearPointers();
-    virtual void GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier);
+    virtual void GetFrontier(std::list<CNode *> *pFrontier);
     virtual CNode *SearchParent(CNode *pChild);
     virtual CNode *SearchPertinentLeaf(int v);
     virtual int CountPertinentLeaves(int v);
-
-    virtual ~CLeafnode(void);
 };
diff --git a/libraries/graphSetPQ/Node.cpp b/libraries/graphSetPQ/Node.cpp
index ba9682f..8be195a 100644
--- a/libraries/graphSetPQ/Node.cpp
+++ b/libraries/graphSetPQ/Node.cpp
@@ -1,20 +1,11 @@
-#include ".\node.h"
-#include "Leafnode.h"
-#include "Pnode.h"
-#include "Qnode.h"
-#include "stdafx.h"
+#include "Node.h"
 
-IMPLEMENT_DYNAMIC(CNode, CObject)
-
-CNode::~CNode(void) {
+CNode::~CNode() {
 }
 
-void CNode::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CNode::FindLeaves(std::list<CLeafnode *> *plQueue) {
     // This is not a leaf, recurse to child to keep searching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->FindLeaves(plQueue);
     }
 }
@@ -24,54 +15,32 @@ void CNode::UnMatch() {
     LABEL = EMPTY;
     MARK = UNMARKED;
     bRoot = false;
-    bCurrent = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
 
     // This is not a leaf, recurse to child to keep unmatching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->UnMatch();
     }
 }
 
-void CNode::ClearPointers() {
-    // This is not a leaf, recurse to children
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
-        pNode->ClearPointers();
-    }
-}
-
-void CNode::GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier) {
+void CNode::GetFrontier(std::list<CNode *> *pFrontier) {
     // This node is not a leaf,  recurse on the children of this node to keep searching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->GetFrontier(pFrontier);
     }
 }
 
 CNode *CNode::SearchParent(CNode *pChild) {
     // This is not a leaf, check if one the children is pChild
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
 
+    for (CNode *pNode : pl_Children) {
         if (pNode == pChild)
             return this;
     }
 
     // We couldn't fint pChild among children, search recursively
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         CNode *pParent = pNode->SearchParent(pChild);
 
         if (pParent != NULL)
@@ -84,10 +53,7 @@ CNode *CNode::SearchParent(CNode *pChild) {
 
 CNode *CNode::SearchPertinentLeaf(int v) {
     // This is not a leaf, search recursively
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         CNode *pLeaf = pNode->SearchPertinentLeaf(v);
 
         if (pLeaf != NULL)
@@ -105,9 +71,7 @@ int CNode::CountPertinentLeaves(int v) {
     int nPertinentLeaves = 0;
 
     // This is not a leaf, search recursively
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
+    for (CNode *pNode : pl_Children) {
         nPertinentLeaves = 0;
 
         // Count pertinent leaves recursively
diff --git a/libraries/graphSetPQ/Node.h b/libraries/graphSetPQ/Node.h
index e11a012..95102f2 100644
--- a/libraries/graphSetPQ/Node.h
+++ b/libraries/graphSetPQ/Node.h
@@ -1,11 +1,25 @@
 #pragma once
 
-class CNode : public CObject {
-    DECLARE_DYNAMIC(CNode);
+#include <list>
+
+// LABEL
+const int EMPTY = 0;
+const int FULL = 1;
+const int PARTIAL = 2;
+const int SINGLY_PARTIAL = 3;
+const int DOUBLY_PARTIAL = 4;
+
+// MARK
+const int UNMARKED = 0;
+const int QUEUED = 1;
+const int BLOCKED = 2;
+const int UNBLOCKED = 3;
+
+class CLeafnode;
+
+class CNode {
 
 public:
-    int iWidth;
-    int iLevel;
     bool bVirtual;// true only for virtual node, it's used to disable destructor of virtual node
 
     // FIELDS as described in Booth and Lueker
@@ -13,34 +27,21 @@ public:
     int MARK; // this is UNMARKED, QUEUED, BLOCKED or UNBLOCKED
     int PERTINENT_CHILD_COUNT;
     int PERTINENT_LEAF_COUNT;
-    bool bCurrent; // true for the current node being matched (to display an arrow in PQtree view)
     bool bRoot;    // true if the current node is the root of the pertinent subtree
     bool bInPruned;// true if this node is part of the pruned pertinent subtree
 
-    // For simultaneous embedding
-    int EdgeColor;
-
 public:
-    CTypedPtrList<CObList, CNode *> pl_Children;
+    std::list<CNode *> pl_Children;
     CNode *pParent;
     CNode *pLeftSibling;
     CNode *pRightSibling;
 
-    CNode *pOriginalNode;  // This pointers are to display the address of the original node
-    CNode *pOriginalParent;// from which a copy for PQTreeView was made, should not be used
-    CNode *pOriginalLeft;  // to deference the node.
-    CNode *pOriginalRight;
-
 public:
-    CNode(void){};
+    CNode(){};
     CNode(CNode *pNode){};
-    virtual int CalculateWidth() { return 0; };
-    virtual int CalculateLevel(int level) { return level; };
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets){};
-    virtual void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    virtual void FindLeaves(std::list<CLeafnode *> *plQueue);
     virtual void UnMatch();
-    virtual void ClearPointers();
-    virtual void GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier);
+    virtual void GetFrontier(std::list<CNode *> *pFrontier);
     virtual CNode *SearchParent(CNode *pChild);
     virtual CNode *SearchPertinentLeaf(int v);
     virtual int CountPertinentLeaves(int v);
diff --git a/libraries/graphSetPQ/PQtree.cpp b/libraries/graphSetPQ/PQtree.cpp
index 37bbb15..b6ee546 100644
--- a/libraries/graphSetPQ/PQtree.cpp
+++ b/libraries/graphSetPQ/PQtree.cpp
@@ -1,74 +1,38 @@
 #include "PQtree.h"
-#include "GraphToolDoc.h"
-#include "Leafnode.h"
+#include "LeafNode.h"
 #include "Pnode.h"
 #include "Qnode.h"
-#include "stdafx.h"
+#include <algorithm>
+#include <queue>
+#include <variant>
 
-IMPLEMENT_DYNAMIC(CPQtree, CObject)
-
-CPQtree::CPQtree(CDocument *pDoc, CVertex *pStart) {
+CPQtree::CPQtree(int numLeaves) {
     // This constructor creates the tree with a first P-Node with its virtual edges
     // new nodes are added to pl_S
-    CPnode *pPnode = new CPnode(pStart, BLACK);
+    CPnode *pPnode = new CPnode();
 
     // root is the unique P-node
     pRoot = (CNode *) pPnode;
 
     // initialize variables
-    iLevels = 0;
-    iWidth = 0;
-    pVirtual = NULL;
-    pLastPertinentRoot = NULL;
-    bSets = false;
-
-    // set document
-    this->pDoc = pDoc;
-}
-
-CPQtree::CPQtree(CDocument *pDoc, CNode *pNode) {
-    // Root is the node given
-    pRoot = pNode;
-
-    // initialize variables
-    iLevels = 0;
-    iWidth = 0;
     pVirtual = NULL;
     pLastPertinentRoot = NULL;
     bSets = false;
 
-    // set document
-    this->pDoc = pDoc;
-}
-
+    for (int i = 0; i < numLeaves; i++) {
+        CLeafnode *newLeaf = new CLeafnode;
+        pPnode->pl_Children.push_back(newLeaf);
+        newLeaf->pParent = pRoot;
 
-CPQtree::CPQtree(CPQtree *pqTree) {
-    if (pqTree->pRoot != NULL) {
-        // This constructor creates a copy of the provided pqTree
-        if (pqTree->pRoot->IsKindOf(RUNTIME_CLASS(CPnode)))
-            pRoot = new CPnode((CPnode *) pqTree->pRoot);
-
-        else if (pqTree->pRoot->IsKindOf(RUNTIME_CLASS(CQnode)))
-            pRoot = new CQnode((CQnode *) pqTree->pRoot);
-
-        else
-            pRoot = new CLeafnode((CLeafnode *) pqTree->pRoot);
-    } else {
-        pRoot = NULL;
+        if (i != 0) {
+            pPnode->pl_Children.back()->pRightSibling = newLeaf;
+            newLeaf->pLeftSibling = pPnode->pl_Children.back();
+        }
     }
-
-    iLevels = pqTree->iLevels;
-    iWidth = pqTree->iWidth;
-    iHeight = pqTree->iHeight;
-    pVirtual = NULL;
-    pLastPertinentRoot = NULL;
-    bSets = false;
-
-    pDoc = pqTree->pDoc;
-    ClearPointers();
 }
 
-CPQtree::~CPQtree(void) {
+
+CPQtree::~CPQtree() {
     if (pRoot != NULL)
         delete pRoot;
 
@@ -91,31 +55,7 @@ void CPQtree::CountPertinentNodes(int v) {
     }
 }
 
-CRect CPQtree::Draw(CDC *pDC, CPoint Offset) {
-    if (pRoot == NULL)
-        return CRect(0, 0, 0, 0);
-
-    // Draw info message
-    CRect calcRect = CRect(0, 0, PQTREE_TEXTH, PQTREE_TEXTV);
-    pDC->SetTextColor(RGB(0, 0, 0));
-    calcRect.OffsetRect(Offset);
-    pDC->DrawText(sComment, calcRect, DT_SINGLELINE);
-
-    // Calculate nodes width (in pixels) and tree height (in # levels)
-    iWidth = pRoot->CalculateWidth();
-    iLevels = pRoot->CalculateLevel(1);
-
-    // Draw the tree beginning in the root
-    Offset.y += 30;
-    pRoot->Draw(pDC, Offset, bSets);
-
-    iHeight = LEVELHEIGHT * (iLevels + 1);
-
-    CRect size(0, 0, iWidth, iHeight);
-    return size;
-}
-
-void CPQtree::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CPQtree::FindLeaves(std::list<CLeafnode *> *plQueue) {
     pRoot->FindLeaves(plQueue);
 }
 
@@ -123,399 +63,106 @@ void CPQtree::SetAllUnmatched() {
     pRoot->UnMatch();
 }
 
-void CPQtree::ClearPointers() {
-    if (pRoot != NULL)
-        pRoot->ClearPointers();
-}
-
-bool CPQtree::ArePertinentConsecutive(int v) {
-    // Get Frontier
-    CTypedPtrList<CObList, CNode *> Frontier;
-    pRoot->GetFrontier(&Frontier);
-
-    // Now check if pertinent leaves are consecutive
-    int State = 0;// little automata: 0 before pertinent nodes
-                  //					1 in pertinent nodes
-                  //					2 after pertinent nodes
-                  //					3 error
-    POSITION aPos = Frontier.GetHeadPosition();
-    while (aPos && State != 3) {
-        CLeafnode *pLeaf = (CLeafnode *) Frontier.GetNext(aPos);
-
-        switch (State) {
-            case 0: {
-                if (pLeaf->pNode->nST == v)// Begin of pertinent leaves
-                    State = 1;
-                break;
-            }
-            case 1: {
-                if (pLeaf->pNode->nST != v)// End of pertinent leaves
-                    State = 2;
-                break;
-            }
-            case 2: {
-                if (pLeaf->pNode->nST == v)// Pertinent leaf again?... error
-                    State = 3;
-                break;
-            }
-        }
-    }
-
-    if (State != 3)
-        return true;
-    else
-        return false;
-}
-
-void CPQtree::VertexAddition(CVertex *pV, CVertex *pU) {
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
-    TRACE("\nVertex addition over vertex %d\n", pV->nST);
-    CNode *pSavedLeftSibling = NULL;
-    CNode *pSavedRightSibling = NULL;
-
-    CNode *pParent;
-    bool bFullNode;
-    if (pLastPertinentRoot->LABEL == FULL) {
-        pParent = pLastPertinentRoot->pParent;
-        bFullNode = true;
-    } else {
-        pParent = pLastPertinentRoot;
-        bFullNode = false;
-    }
-
-    // Prune pertinent subtree and store the position
-    CNode *pSavedPrev = NULL;
-    bool bBlue = false;
-    bool bRed = false;
-    bool bBlack = false;
-    if (pParent != NULL) {
-        POSITION aPos = pParent->pl_Children.GetHeadPosition();
-        POSITION prevPos;
-        while (aPos) {
-            // Get next node on the list
-            prevPos = aPos;
-            CNode *pNode = pParent->pl_Children.GetNext(aPos);
-
-            // remove pertinent nodes
-            if (pNode->LABEL == FULL) {
-                if (pNode->EdgeColor == BLUE)
-                    bBlue = true;
-                else if (pNode->EdgeColor == RED)
-                    bRed = true;
-                else
-                    bBlack = true;
-
-                // remove this pertinent node
-                if (pNode->pLeftSibling != NULL)
-                    pNode->pLeftSibling->pRightSibling = pNode->pRightSibling;
-                if (pNode->pRightSibling != NULL)
-                    pNode->pRightSibling->pLeftSibling = pNode->pLeftSibling;
-
-                pSavedLeftSibling = pNode->pLeftSibling;
-                pSavedRightSibling = pNode->pRightSibling;
-
-                delete pNode;
-                pParent->pl_Children.RemoveAt(prevPos);
-            }
-        }
-    } else {
-        // the node itself is the pertinent subtree, delete it
-        if (pLastPertinentRoot == pRoot)
-            pRoot = NULL;
-        delete pLastPertinentRoot;
-        pLastPertinentRoot = NULL;
-    }
-
-    // Create a new P-node with all neighbors of v
-    int newColor;
-    if ((bBlue && bRed) || (bBlack))
-        newColor = BLACK;
-    else if (bBlue)
-        newColor = BLUE;
-    else
-        newColor = RED;
-    CPnode *pPnode = new CPnode(pV, newColor);
-
-    // Insert the new cut vertex on saved position
-    if (pPnode->pl_Children.GetCount() == 0) {
-        // nothing to insert;
-        delete pPnode;
-        pPnode = NULL;
-    } else {
-        if (pParent == NULL) {
-            // no place to insert
-            pRoot = pPnode;
-            pPnode->pParent = NULL;
-            pPnode->pLeftSibling = NULL;
-            pPnode->pRightSibling = NULL;
-        } else {
-            // Normal case
-            if (pSavedLeftSibling != NULL) {
-                POSITION insertPos = pParent->pl_Children.Find(pSavedLeftSibling);
-                pParent->pl_Children.InsertAfter(insertPos, pPnode);
-            } else {
-                pParent->pl_Children.AddHead(pPnode);
-            }
-            pPnode->pParent = pParent;
-            pPnode->pLeftSibling = pSavedLeftSibling;
-            pPnode->pRightSibling = pSavedRightSibling;
-            if (pPnode->pLeftSibling != NULL)
-                pPnode->pLeftSibling->pRightSibling = pPnode;
-            if (pPnode->pRightSibling != NULL)
-                pPnode->pRightSibling->pLeftSibling = pPnode;
-        }
-    }
-
-    // Check for special cases: an improper tree may be produced...
-
-    // The new P-node is empty
-    if (pPnode == NULL)
-        return;
-
-    // The new P-node contains only one child
-    if (pPnode->pl_Children.GetCount() == 1) {
-        // Do the insertion
-        if (pPnode->pParent == NULL) {
-            // pNode is now the root, no insertion needed
-            CNode *pChild = pPnode->pl_Children.GetHead();
-            pRoot = pChild;
-            pChild->pParent = NULL;
-            pChild->pLeftSibling = NULL;
-            pChild->pRightSibling = NULL;
-        } else {
-            // have to insert pNode on its GrandFather
-            CNode *pGrandFather = pPnode->pParent;
-            CNode *pChild = pPnode->pl_Children.GetHead();
-            if (pPnode->pLeftSibling != NULL) {
-                POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-                pGrandFather->pl_Children.InsertAfter(insertPos, pChild);
-            } else {
-                pGrandFather->pl_Children.AddHead(pChild);
-            }
-            pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
-            pChild->pParent = pGrandFather;
-            pChild->pLeftSibling = pPnode->pLeftSibling;
-            pChild->pRightSibling = pPnode->pRightSibling;
-            if (pPnode->pLeftSibling != NULL)
-                pPnode->pLeftSibling->pRightSibling = pChild;
-            if (pPnode->pRightSibling != NULL)
-                pPnode->pRightSibling->pLeftSibling = pChild;
-        }
-
-        pPnode->pl_Children.RemoveAll();
-        delete pPnode;
-    }
-
-    // A parent node with just one child
-    if (pParent != NULL) {
-        if (pParent->pl_Children.GetCount() == 1) {
-            CNode *pChild = pParent->pl_Children.GetHead();
-
-            // Do the insertion
-            if (pParent->pParent == NULL) {
-                // pChild is now the root, no insertion needed
-                pRoot = pChild;
-                pChild->pParent = NULL;
-            } else {
-                // have to insert pNode on its GrandFather
-                CNode *pGrandFather = pParent->pParent;
-                if (pParent->pLeftSibling != NULL) {
-                    POSITION insertPos = pGrandFather->pl_Children.Find(pParent->pLeftSibling);
-                    pGrandFather->pl_Children.InsertAfter(insertPos, pChild);
-                } else {
-                    pGrandFather->pl_Children.AddHead(pChild);
-                }
-                pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pParent));
-                pChild->pParent = pGrandFather;
-                pChild->pLeftSibling = pParent->pLeftSibling;
-                pChild->pRightSibling = pParent->pRightSibling;
-                if (pParent->pLeftSibling != NULL)
-                    pParent->pLeftSibling->pRightSibling = pChild;
-                if (pParent->pRightSibling != NULL)
-                    pParent->pRightSibling->pLeftSibling = pChild;
-            }
-
-            pParent->pl_Children.RemoveAll();
-            delete pParent;
-            pParent = NULL;
-        }
-    }
-
-    // A Q-node with less than 3 children
-    if (pParent != NULL) {
-        if (pParent->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            // If after removing pertinent subtree, parent node is a Q-node with <3 children... fix it
-            if (pParent->pl_Children.GetCount() == 2) {
-                // A Q-node with 2 children is actually a P-node
-                CNode *pNewPnode = new CPnode();
-
-                if (pParent->pParent == NULL) {
-                    // No insertion needed, since pParent was root of pqTree, now pNewPnode is the new root
-                    pRoot = pNewPnode;
-                } else {
-                    // Find the position of the Q-node
-                    POSITION aPos = pParent->pParent->pl_Children.Find(pParent);
-
-                    // insert new P-node in the place of Q-node
-                    pParent->pParent->pl_Children.InsertAfter(aPos, pNewPnode);
-                    pNewPnode->pParent = pParent->pParent;
-                    pNewPnode->pLeftSibling = pParent->pLeftSibling;
-                    pNewPnode->pRightSibling = pParent->pRightSibling;
-                    if (pNewPnode->pLeftSibling != NULL)
-                        pNewPnode->pLeftSibling->pRightSibling = pNewPnode;
-                    if (pNewPnode->pRightSibling != NULL)
-                        pNewPnode->pRightSibling->pLeftSibling = pNewPnode;
-
-                    // remove link to Q-node from parent
-                    pParent->pParent->pl_Children.RemoveAt(aPos);
-                }
-
-                // copy the children of Q-node into the new P-node
-                CNode *pChild1 = pParent->pl_Children.GetHead();
-                CNode *pChild2 = pParent->pl_Children.GetTail();
-                pNewPnode->pl_Children.AddTail(pChild1);
-                pNewPnode->pl_Children.AddTail(pChild2);
-                pChild1->pParent = pNewPnode;
-                pChild2->pParent = pNewPnode;
-                pChild1->pRightSibling = pChild2;
-                pChild2->pRightSibling = NULL;
-                pChild2->pLeftSibling = pChild1;
-                pChild1->pLeftSibling = NULL;
-
-                // remove unnecessary Q-node
-                pParent->pl_Children.RemoveAll();
-                delete pParent;
-            }
-        }
-    }
-}
-
-void CPQtree::CopyFullChildren(CVertex *pU, CNode *pNode) {
-    if (pNode->IsKindOf(RUNTIME_CLASS(CLeafnode)) && pNode->LABEL == FULL) {
-        CLeafnode *pChLeaf = (CLeafnode *) pNode;
-        pU->pl_Outlist.AddHead(pChLeaf->pNode);
-    } else {
-        POSITION chPos = pNode->pl_Children.GetHeadPosition();
-        while (chPos) {
-            CNode *pChNode = pNode->pl_Children.GetNext(chPos);
-            CopyFullChildren(pU, pChNode);
-        }
-    }
-}
-
-bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
-    CTypedPtrList<CObList, CNode *> pl_Blocked;
-    QUEUE.RemoveAll();
+bool CPQtree::Bubble(std::list<CLeafnode *> *pl_S) {
+    std::list<CNode *> pl_Blocked;
+    QUEUE.clear();
     BLOCK_COUNT = 0;
     BLOCKED_NODES = 0;
     OFF_THE_TOP = 0;
 
     // for X e S do place X onto QUEUE
-    POSITION aPos = pl_S->GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_S->GetNext(aPos);
-        QUEUE.AddTail(pNode);
+    for (CNode *pNode : *pl_S) {
+        QUEUE.push_back(pNode);
     }
 
-    while (QUEUE.GetCount() + BLOCK_COUNT + OFF_THE_TOP > 1) {
-        if (QUEUE.GetCount() == 0) {
+    while (QUEUE.size() + BLOCK_COUNT + OFF_THE_TOP > 1) {
+        if (QUEUE.empty()) {
             return false;
         }
 
         // remove X from the front of the QUEUE
-        CNode *pX = QUEUE.GetHead();
-        QUEUE.RemoveHead();
+        CNode *pX = QUEUE.front();
+        QUEUE.pop_front();
 
         // mark X blocked
         pX->MARK = BLOCKED;
-        pl_Blocked.AddTail(pX);
+        pl_Blocked.push_back(pX);
 
         // BS = {Y e INMEDIATE_SIBLINGS(X), MARK(Y)="blocked"}
         // US = {Y e INMEDIATE_SIBLINGS(X), MARK(Y)="blocked"}
-        CTypedPtrList<CObList, CNode *> pl_BS;
-        CTypedPtrList<CObList, CNode *> pl_US;
+        std::list<CNode *> pl_BS;
+        std::list<CNode *> pl_US;
 
         // Add left sibling to the proper list
         if (pX->pLeftSibling != NULL) {
             if (pX->pLeftSibling->MARK == BLOCKED)
-                pl_BS.AddTail(pX->pLeftSibling);
+                pl_BS.push_back(pX->pLeftSibling);
             else if (pX->pLeftSibling->MARK == UNBLOCKED)
-                pl_US.AddTail(pX->pLeftSibling);
+                pl_US.push_back(pX->pLeftSibling);
         }
 
         // Add right sibling to the proper list
         if (pX->pRightSibling != NULL) {
             if (pX->pRightSibling->MARK == BLOCKED)
-                pl_BS.AddTail(pX->pRightSibling);
+                pl_BS.push_back(pX->pRightSibling);
             else if (pX->pRightSibling->MARK == UNBLOCKED)
-                pl_US.AddTail(pX->pRightSibling);
+                pl_US.push_back(pX->pRightSibling);
         }
 
-        if (pl_US.GetCount() > 0) {
+        if (!pl_US.empty()) {
             // choose any Y e US
-            CNode *pY = pl_US.GetHead();
+            CNode *pY = pl_US.front();
 
             pX->pParent = pY->pParent;
             pX->MARK = UNBLOCKED;
         } else if (pX->pLeftSibling == NULL || pX->pRightSibling == NULL)// |SIBLINGS| < 2
         {
             pX->MARK = UNBLOCKED;
-            pl_Blocked.RemoveAt(pl_Blocked.Find(pX));
+            pl_Blocked.remove(pX);
         } else {
             // Deviation from paper algorithm, if the parent node is a P-node
             // then unblock the node
             if (pX->pParent != NULL) {
-                if (pX->pParent->IsKindOf(RUNTIME_CLASS(CPnode))) {
+                if (dynamic_cast<CPnode *>(pX->pParent)) {
                     pX->MARK = UNBLOCKED;
-                    pl_Blocked.RemoveAt(pl_Blocked.Find(pX));
+                    pl_Blocked.remove(pX);
                 }
             }
         }
 
         if (pX->MARK == UNBLOCKED) {
             // LIST := the maximal consecutive set of blocked siblings adjacent to X
-            CTypedPtrList<CObList, CNode *> pl_LIST, pl_LIST_R, pl_LIST_L;
+            std::list<CNode *> pl_LIST, pl_LIST_R, pl_LIST_L;
 
             CNode *pY = pX->pParent;
 
-            if (pl_BS.GetCount() > 0) {
+            if (!pl_BS.empty()) {
                 // search blocked nodes to the right
                 CNode *pPrev = pX->pLeftSibling;
                 while (pPrev != NULL && pPrev->MARK == BLOCKED) {
-                    pl_LIST_L.AddTail(pPrev);
+                    pl_LIST_L.push_back(pPrev);
                     pPrev = pPrev->pLeftSibling;
                 }
 
                 // search blocked nodes to the right
                 CNode *pNext = pX->pRightSibling;
                 while (pNext != NULL && pNext->MARK == BLOCKED) {
-                    pl_LIST_R.AddTail(pNext);
+                    pl_LIST_R.push_back(pNext);
                     pNext = pNext->pRightSibling;
                 }
 
                 // copy the list of maximum size
-                if (pl_LIST_R.GetCount() > pl_LIST_L.GetCount()) {
-                    POSITION lPos = pl_LIST_R.GetHeadPosition();
-                    while (lPos) {
-                        CNode *pCopy = pl_LIST_R.GetNext(lPos);
-                        pl_LIST.AddTail(pCopy);
+                if (pl_LIST_R.size() > pl_LIST_L.size()) {
+                    for (CNode *pCopy : pl_LIST_R) {
+                        pl_LIST.push_back(pCopy);
                     }
                 } else {
-                    POSITION lPos = pl_LIST_L.GetHeadPosition();
-                    while (lPos) {
-                        CNode *pCopy = pl_LIST_L.GetNext(lPos);
-                        pl_LIST.AddTail(pCopy);
+                    for (CNode *pCopy : pl_LIST_L) {
+                        pl_LIST.push_back(pCopy);
                     }
                 }
 
-                // for Z e LIST do
-                POSITION zPos = pl_LIST.GetHeadPosition();
-                while (zPos) {
-                    CNode *pZ = pl_LIST.GetNext(zPos);
-
+                for (CNode *pZ : pl_LIST) {
                     pZ->MARK = UNBLOCKED;
                     pZ->pParent = pY;
                     pZ->PERTINENT_CHILD_COUNT += 1;
@@ -528,15 +175,15 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
             } else {
                 pY->PERTINENT_CHILD_COUNT += 1;
                 if (pY->MARK == UNMARKED) {
-                    QUEUE.AddTail(pY);
+                    QUEUE.push_back(pY);
                     pY->MARK = QUEUED;
                 }
             }
 
-            BLOCK_COUNT = BLOCK_COUNT - (int) pl_BS.GetCount();
-            BLOCKED_NODES = BLOCKED_NODES - (int) pl_LIST.GetCount();
+            BLOCK_COUNT = BLOCK_COUNT - (int) pl_BS.size();
+            BLOCKED_NODES = BLOCKED_NODES - (int) pl_LIST.size();
         } else {
-            BLOCK_COUNT = BLOCK_COUNT + 1 - (int) pl_BS.GetCount();
+            BLOCK_COUNT = BLOCK_COUNT + 1 - (int) pl_BS.size();
             BLOCKED_NODES = BLOCKED_NODES += 1;
         }
     }
@@ -546,7 +193,7 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
 	{
 		if (pVirtual!=NULL)
 		{
-			pVirtual->pl_Children.RemoveAll();
+			pVirtual->pl_Children.clear();
 			delete pVirtual;
 		}
 		pVirtual = new CQnode();
@@ -580,35 +227,44 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
     return true;
 }
 
-bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
+void CPQtree::prepareReduction(std::list<CLeafnode *> *pl_S, int v) {
+    if (pl_S->size() <= 1) {
+        return;
+    }
+
+    for (CLeafnode *leaf : *pl_S) {
+        leaf->saved_st_N = v;
+    }
+
+    CountPertinentNodes(v);
+}
+
+bool CPQtree::Reduce(std::list<CLeafnode *> *pl_S, int v) {
+    if (pl_S->size() <= 1) {
+        return true;
+    }
+
     int nCount = 0;
     // Initialize queue to empty
-    QUEUE.RemoveAll();
+    QUEUE.clear();
 
     // for X e S do place X onto QUEUE
-    POSITION aPos = pl_S->GetHeadPosition();
-    TRACE("\n\nDisplaying set for %d: S = {", v);
-    while (aPos) {
-        CNode *pX = pl_S->GetNext(aPos);
-        QUEUE.AddTail(pX);
+    for (CNode *pX : *pl_S) {
+        QUEUE.push_back(pX);
         pX->PERTINENT_LEAF_COUNT = 1;
         nCount++;
-        if (aPos)
-            TRACE("%p, ", pX);
-        else
-            TRACE("%p} and the total is %d", pX, nCount);
     }
 
     // Safety for first match
     pLastPertinentRoot = pRoot;
 
-    while (QUEUE.GetCount() > 0) {
+    while (!QUEUE.empty()) {
         // remove X from the front of the QUEUE
-        CNode *pX = QUEUE.GetTail();
-        QUEUE.RemoveTail();
+        CNode *pX = QUEUE.back();
+        QUEUE.pop_back();
         CountNodeTypes(pX);
 
-        if ((pX->PERTINENT_LEAF_COUNT) < (pl_S->GetCount())) {
+        if ((pX->PERTINENT_LEAF_COUNT) < (pl_S->size())) {
             // By the way... X is not the ROOT(T, S)
             CNode *pY = pX->pParent;
 
@@ -616,7 +272,7 @@ bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
 
             if (pY->PERTINENT_CHILD_COUNT == 0) {
                 // place Y onto QUEUE
-                QUEUE.AddHead(pY);
+                QUEUE.push_front(pY);
             }
 
             // try to apply templates for X not being the ROOT(T, S)
@@ -647,56 +303,30 @@ bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
     return true;
 }
 
-bool CPQtree::Template_L1(CNode *pX, bool bRoot, int v, CString sText) {
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
-    if (!pX->IsKindOf(RUNTIME_CLASS(CLeafnode)))
+bool CPQtree::Template_L1(CNode *pX, bool bRoot, int v) {
+    if (!dynamic_cast<CLeafnode *>(pX))
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN L1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template L1\n");
     CLeafnode *pLeafnode = (CLeafnode *) pX;
 
     // Pertinent leaves are marked full, or empty otherwise
-    if (pLeafnode->pNode->nST == v)
+    if (pLeafnode->saved_st_N == v)
         pLeafnode->LABEL = FULL;
     else
         pLeafnode->LABEL = EMPTY;
 
 
-    // Save PQ-tree for later viewing
-    pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pX->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN L1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_P1(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P1(CNode *pX, bool bRoot) {
     // The pattern is with X being a P-node and all children full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -705,41 +335,15 @@ bool CPQtree::Template_P1(CNode *pX, bool bRoot, CString sText) {
     if (mFull != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P1\n");
     pX->LABEL = FULL;
 
-    // Save PQ-tree for later viewing
     pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
-    // Pattern is with pX root of pertinent subtree and all children are either full or empty)
-    TRACE("\nTrying P2...\n");
-
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
+bool CPQtree::Template_P2(CNode *pX, bool bRoot) {
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -752,32 +356,18 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
     if (mFull + mEmpty != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree = new CPQtree(this);
     pX->bRoot = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P2 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P2\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
 
     // Move all full children to the new P node
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos;
+    auto it = pPnode->pl_Children.begin();
     CNode *pPrevFullNode = NULL;
-    while (aPos) {
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -792,10 +382,10 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
                     pTempNode->pLeftSibling->pRightSibling = pTempNode->pRightSibling;
                 if (pTempNode->pRightSibling != NULL)
                     pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
-                pPnode->pl_Children.RemoveAt(prevPos);
+                pPnode->pl_Children.erase(std::prev(it));
             } else {
                 // Add the node to the new P-node
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes on the previous position
@@ -803,7 +393,7 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
                     pTempNode->pLeftSibling->pRightSibling = pTempNode->pRightSibling;
                 if (pTempNode->pRightSibling != NULL)
                     pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
-                pPnode->pl_Children.RemoveAt(prevPos);
+                pPnode->pl_Children.erase(std::prev(it));
 
                 // update the linked list of nodes in the new position
                 pTempNode->pLeftSibling = pPrevFullNode;
@@ -817,37 +407,26 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
 
     // Add full subtree to the current node
     pNewFullPnode->pParent = pX;
-    CNode *pLeft = pX->pl_Children.GetTail();
+    CNode *pLeft = pX->pl_Children.back();
     if (pLeft != NULL)
         pLeft->pRightSibling = pNewFullPnode;
     pNewFullPnode->pLeftSibling = pLeft;
     pNewFullPnode->pRightSibling = NULL;
-    pPnode->pl_Children.AddTail(pNewFullPnode);
+    pPnode->pl_Children.push_back(pNewFullPnode);
 
     // Label the replacement tree
     pNewFullPnode->LABEL = FULL;
     pNewFullPnode->bRoot = true;
     pLastPertinentRoot = pNewFullPnode;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P2");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P3(CNode *pX, bool bRoot) {
     // Pattern is with pX NOT root of pertinent subtree and all children are either full or empty)
-    TRACE("\nTrying P3...\n");
-
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -860,32 +439,16 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
     if (mFull + mEmpty != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P3 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P3\n");
-
     // Create a new Q-node and two P-nodes for full and empty subtrees
     CQnode *pNewQnode = new CQnode();
     CNode *pNewFullPnode = new CPnode();
     CNode *pNewEmptyPnode = new CPnode();
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    for (CNode *pTempNode : pPnode->pl_Children) {
         // Get next node on the list
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -900,7 +463,7 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -916,7 +479,7 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
                 delete pNewEmptyPnode;// we don't need a P-node for just one element
                 pNewEmptyPnode = pTempNode;
             } else {
-                pNewEmptyPnode->pl_Children.AddTail(pTempNode);
+                pNewEmptyPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewEmptyPnode;
 
                 // update the linked list of nodes
@@ -931,12 +494,12 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
 
     // Find the parent of current node
     CNode *pParent = pPnode->pParent;
-    POSITION savedPos;
+    std::list<CNode *>::iterator savedPos;
 
     // Insert the new Q-node
     if (pParent != NULL) {
-        savedPos = pParent->pl_Children.Find(pPnode);
-        pParent->pl_Children.InsertAfter(savedPos, pNewQnode);
+        savedPos = std::find(pParent->pl_Children.begin(), pParent->pl_Children.end(), pPnode);
+        pParent->pl_Children.insert(std::next(savedPos), pNewQnode);
     } else {
         // if there is no parent, then the node we are replacing was the root of the pqTree
         pRoot = pNewQnode;
@@ -952,14 +515,14 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
 
     // Remove previous P-node
     if (pParent != NULL)
-        pParent->pl_Children.RemoveAt(savedPos);
-    pPnode->pl_Children.RemoveAll();
-    delete pPnode;
+        pParent->pl_Children.erase(savedPos);
+    pPnode->pl_Children.clear();
+    //	delete pPnode; // Removing this avoids invalid writes affecting the evaluation scaffolding
     pPnode = NULL;
 
     // Add subtrees to new Q-node
-    pNewQnode->pl_Children.AddTail(pNewEmptyPnode);
-    pNewQnode->pl_Children.AddTail(pNewFullPnode);
+    pNewQnode->pl_Children.push_back(pNewEmptyPnode);
+    pNewQnode->pl_Children.push_back(pNewFullPnode);
     pNewEmptyPnode->pParent = pNewQnode;
     pNewFullPnode->pParent = pNewQnode;
     pNewEmptyPnode->pLeftSibling = NULL;
@@ -977,27 +540,17 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
     //       there is at least one pertinent leaf which is not descendant of this
     //       Q-node, so this new children will be added. (maybe)
 
-    // Save PQ-tree for later viewing
-    pNewQnode->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pNewQnode->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P3");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P4(CNode *pX, bool bRoot) {
     // Pattern is with pX root of pertinent subtree and exactly one partial child, rest of children doesn't matter)
-    TRACE("\nTrying P4...\n");
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1006,33 +559,19 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
     if (mPartial != 1)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P4 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P4\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
     CNode *pPartial = NULL;
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -1048,7 +587,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -1060,7 +599,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
         } else if (pTempNode->LABEL == PARTIAL || pTempNode->LABEL == SINGLY_PARTIAL || pTempNode->LABEL == DOUBLY_PARTIAL) {
             // Find the Q-node (partial)
             pPartial = pTempNode;
@@ -1073,7 +612,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
         delete pNewFullPnode;
     } else {
         // Check if p-node will have only one child, and fix it
-        if (pPnode->pl_Children.GetCount() == 1) {
+        if (pPnode->pl_Children.size() == 1) {
             // p-node is the roor of the pqTree?
             if (pRoot == pPnode) {
                 // we don't need to insert anything, just make this node root of pqTree
@@ -1084,13 +623,13 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             } else {
                 // Before removing the p-node, insert the q-node in the parent of the p-node
                 CNode *pGrandFather = pPnode->pParent;
-                pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+                pGrandFather->pl_Children.remove(pPnode);
                 if (pPnode->pLeftSibling != NULL)
                     pPnode->pLeftSibling->pRightSibling = pPnode->pRightSibling;
                 if (pPnode->pRightSibling != NULL)
                     pPnode->pRightSibling->pLeftSibling = pPnode->pLeftSibling;
-                CNode *pUncle = pGrandFather->pl_Children.GetTail();
-                pGrandFather->pl_Children.AddTail(pPartial);
+                CNode *pUncle = pGrandFather->pl_Children.back();
+                pGrandFather->pl_Children.push_back(pPartial);
                 pPartial->pParent = pGrandFather;
                 pPartial->pLeftSibling = pUncle;
                 pPartial->pRightSibling = NULL;
@@ -1099,15 +638,15 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             }
 
             // Now remove the p-node, otherwise will produce a linnear chain of nodes
-            pPnode->pl_Children.RemoveAll();
+            pPnode->pl_Children.clear();
             delete pPnode;
         } else {
             pPnode->LABEL = PARTIAL;
         }
 
         // Add full subtree to q-node
-        CNode *pLeft = pPartial->pl_Children.GetTail();
-        pPartial->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial->pl_Children.back();
+        pPartial->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial;
         pNewFullPnode->pLeftSibling = pLeft;
         pNewFullPnode->pRightSibling = NULL;
@@ -1121,24 +660,14 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
     pPartial->bRoot = true;
     pLastPertinentRoot = pPartial;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P4");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P5(CNode *pX, bool bRoot) {
     // Pattern is with pX NOT root of pertinent subtree and exactly one partial child
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1147,34 +676,19 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     if (mPartial != 1)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P5 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P5\n");
-
     // Create a new P-node for full subtree and one for empty subtree
     CNode *pNewFullPnode = new CPnode();
     CNode *pNewEmptyPnode = new CPnode();
     CNode *pPartial = NULL;
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // Check if we are going to move this subtree
         if (pTempNode->LABEL == FULL || pTempNode->LABEL == EMPTY) {
@@ -1192,7 +706,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
                     delete pNewFullPnode;
                     pNewFullPnode = pTempNode;
                 } else {
-                    pNewFullPnode->pl_Children.AddTail(pTempNode);
+                    pNewFullPnode->pl_Children.push_back(pTempNode);
                     pTempNode->pParent = pNewFullPnode;
 
                     // update the linked list of nodes
@@ -1210,7 +724,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
                     delete pNewEmptyPnode;
                     pNewEmptyPnode = pTempNode;
                 } else {
-                    pNewEmptyPnode->pl_Children.AddTail(pTempNode);
+                    pNewEmptyPnode->pl_Children.push_back(pTempNode);
                     pTempNode->pParent = pNewEmptyPnode;
 
                     // update the linked list of nodes
@@ -1223,7 +737,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
 
         } else if (pTempNode->LABEL == PARTIAL || pTempNode->LABEL == SINGLY_PARTIAL || pTempNode->LABEL == DOUBLY_PARTIAL) {
             // Find the Q-node (partial)
@@ -1240,12 +754,12 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
         // Before removing the p-node, insert the q-node in the parent of the p-node
         CNode *pGrandFather = pPnode->pParent;
         if (pPnode->pLeftSibling != NULL) {
-            POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-            pGrandFather->pl_Children.InsertAfter(insertPos, pPartial);
+            auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pPnode->pLeftSibling);
+            pGrandFather->pl_Children.insert(std::next(insertPos), pPartial);
         } else {
-            pGrandFather->pl_Children.AddHead(pPartial);
+            pGrandFather->pl_Children.push_front(pPartial);
         }
-        pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+        pGrandFather->pl_Children.remove(pPnode);
         pPartial->pParent = pGrandFather;
         pPartial->pLeftSibling = pPnode->pLeftSibling;
         pPartial->pRightSibling = pPnode->pRightSibling;
@@ -1256,13 +770,13 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Now remove the p-node
-    pPnode->pl_Children.RemoveAll();
+    pPnode->pl_Children.clear();
     delete pPnode;
 
     // Add full subtree to q-node if necessary
     if (mFull > 0) {
-        CNode *pLeft = pPartial->pl_Children.GetTail();
-        pPartial->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial->pl_Children.back();
+        pPartial->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial;
         pNewFullPnode->pLeftSibling = pLeft;
         pNewFullPnode->pRightSibling = NULL;
@@ -1274,8 +788,8 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
 
     // Add empty subtree to q-node if necessary
     if (mEmpty > 0) {
-        CNode *pRight = pPartial->pl_Children.GetHead();
-        pPartial->pl_Children.AddHead(pNewEmptyPnode);
+        CNode *pRight = pPartial->pl_Children.front();
+        pPartial->pl_Children.push_front(pNewEmptyPnode);
         pNewEmptyPnode->pParent = pPartial;
         pNewEmptyPnode->pLeftSibling = NULL;
         pNewEmptyPnode->pRightSibling = pRight;
@@ -1289,24 +803,15 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     pPartial->bRoot = false;
     pLastPertinentRoot = pPartial;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P5");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P6(CNode *pX, bool bRoot) {
     // Pattern is with pX root of pertinent subtree and exactly TWO partial children)
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1316,12 +821,9 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
         return false;
 
     // Find two singly partial nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
     CNode *pPartial1 = NULL;
     CNode *pPartial2 = NULL;
-    while (aPos) {
-        CNode *pSearchNode = pPnode->pl_Children.GetNext(aPos);
-
+    for (CNode *pSearchNode : pPnode->pl_Children) {
         if (pSearchNode->LABEL == SINGLY_PARTIAL) {
             if (pPartial1 == NULL)
                 pPartial1 = pSearchNode;
@@ -1334,31 +836,17 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     if (pPartial1 == NULL || pPartial2 == NULL)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P6 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P6\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
 
     // Move all full children to the new P nodes
-    aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -1374,7 +862,7 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -1386,15 +874,15 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
         }
     }
 
     // Add full subtree to q-node (partial of the left)
     CNode *pPrevNode;
     if (mFull > 0) {
-        CNode *pLeft = pPartial1->pl_Children.GetTail();
-        pPartial1->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial1->pl_Children.back();
+        pPartial1->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial1;
         pLeft->pRightSibling = pNewFullPnode;
         pNewFullPnode->pLeftSibling = pLeft;
@@ -1403,7 +891,7 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     } else {
         // Empty P-node
         delete pNewFullPnode;
-        pPrevNode = pPartial1->pl_Children.GetTail();
+        pPrevNode = pPartial1->pl_Children.back();
     }
 
     // Label the replacement tree
@@ -1414,14 +902,12 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     pLastPertinentRoot = pPartial1;
 
     // Copy partial2 to partial1 in reverse order
-    aPos = pPartial2->pl_Children.GetTailPosition();
-    while (aPos) {
+    for (auto rit = pPartial2->pl_Children.rbegin(); rit != pPartial2->pl_Children.rend(); ++rit) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetPrev(aPos);
+        CNode *pTempNode = *rit;
 
-        // Add it to partial1
-        pPartial1->pl_Children.AddTail(pTempNode);
+        // Add rit to partial1
+        pPartial1->pl_Children.push_back(pTempNode);
         pTempNode->pParent = pPartial1;
 
         pTempNode->pLeftSibling = pPrevNode;
@@ -1433,17 +919,16 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Erase partial2
-    POSITION dPos = pPnode->pl_Children.Find(pPartial2);
-    pPnode->pl_Children.RemoveAt(dPos);
+    pPnode->pl_Children.remove(pPartial2);
     if (pPartial2->pLeftSibling != NULL)
         pPartial2->pLeftSibling->pRightSibling = pPartial2->pRightSibling;
     if (pPartial2->pRightSibling != NULL)
         pPartial2->pRightSibling->pLeftSibling = pPartial2->pLeftSibling;
-    pPartial2->pl_Children.RemoveAll();
-    delete pPartial2;
+    pPartial2->pl_Children.clear();
+    //	delete pPartial2; // Removing this avoids invalid writes affecting the evaluation scaffolding
 
     // Check for special case: A parent node with just one child
-    if (pPnode->pl_Children.GetCount() == 1) {
+    if (pPnode->pl_Children.size() == 1) {
         // p-node is the roor of the pqTree?
         if (pRoot == pPnode) {
             // we don't need to insert anything, just make this node root of pqTree
@@ -1455,12 +940,12 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
             // Before removing the p-node, insert the q-node in the parent of the p-node
             CNode *pGrandFather = pPnode->pParent;
             if (pPnode->pLeftSibling != NULL) {
-                POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-                pGrandFather->pl_Children.InsertAfter(insertPos, pPartial1);
+                auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pPnode->pLeftSibling);
+                pGrandFather->pl_Children.insert(std::next(insertPos), pPartial1);
             } else {
-                pGrandFather->pl_Children.AddHead(pPartial1);
+                pGrandFather->pl_Children.push_front(pPartial1);
             }
-            pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+            pGrandFather->pl_Children.remove(pPnode);
             pPartial1->pParent = pGrandFather;
             pPartial1->pLeftSibling = pPnode->pLeftSibling;
             pPartial1->pRightSibling = pPnode->pRightSibling;
@@ -1471,29 +956,21 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
         }
 
         // Now remove the p-node, otherwise will produce a linnear chain of nodes
-        pPnode->pl_Children.RemoveAll();
+        pPnode->pl_Children.clear();
         delete pPnode;
     }
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pPartial1->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P6");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_Q1(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q1(CNode *pX, bool bRoot) {
     // The pattern is with X being a Q-node and all children full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1503,40 +980,20 @@ bool CPQtree::Template_Q1(CNode *pX, bool bRoot, CString sText) {
         return false;
 
     // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q1\n");
     pX->LABEL = FULL;
 
     // Save PQ-tree for later viewing
     pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q2(CNode *pX, bool bRoot) {
     // Pattern is a Q-node with 0 or 1 singly partial child, and not all children are labeled
     // identically (all full is Q1, and all empty is "Q0")
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1556,11 +1013,11 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     // Check node order:   a) Empty nodes -> Partial node -> Full nodes, or
     //					   b) Full nodes -> Partial node -> Empty nodes
 
-    CNode *pFirst = pQnode->pl_Children.GetHead();
+    CNode *pFirst = pQnode->pl_Children.front();
     bool bReversed = false;// this is to know how to insert nodes later
-    const WORD FORWARD = 0;
-    const WORD REVERSE = 1;
-    const WORD MIDDLE = 2;
+    const int FORWARD = 0;
+    const int REVERSE = 1;
+    const int MIDDLE = 2;
     int nScanning;
     int nState = 0;
     if (pFirst->LABEL == EMPTY) {
@@ -1574,9 +1031,10 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     }
 
     CNode *pPartial = NULL;
-    POSITION sPos = pQnode->pl_Children.GetHeadPosition();
-    while (sPos && nState != 4) {
-        CNode *pChild = pQnode->pl_Children.GetNext(sPos);
+    for (CNode *pChild : pQnode->pl_Children) {
+        if (nState == 4) {
+            break;
+        }
 
         // use this oportunity to get partial node
         if (pChild->LABEL == SINGLY_PARTIAL)
@@ -1683,43 +1141,36 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     if (nState == 4)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q2 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q2\n");
-
     // Manage the posibility of no partial node
     CNode *pPrevFullNode;
     if (pPartial == NULL) {
         pPartial = new CQnode();
         pPrevFullNode = NULL;
     } else {
-        pPrevFullNode = pPartial->pl_Children.GetTail();
+        pPrevFullNode = pPartial->pl_Children.back();
     }
 
     // Move all full children to the partial node
-    POSITION aPos, prevPos;
+    using forward_it = std::list<CNode *>::iterator;
+    using reverse_it = std::list<CNode *>::reverse_iterator;
+    std::variant<forward_it, reverse_it> aPos, prevPos;
     CNode *pTempNode;
-    if (!bReversed)
-        aPos = pQnode->pl_Children.GetHeadPosition();
-    else
-        aPos = pQnode->pl_Children.GetTailPosition();
-    while (aPos) {
+    if (!bReversed) {
+        aPos = pQnode->pl_Children.begin();
+    } else {
+        aPos = pQnode->pl_Children.rbegin();
+    }
+
+    while ((bReversed && std::get<reverse_it>(aPos) != pQnode->pl_Children.rend()) ||
+           (!bReversed && std::get<forward_it>(aPos) != pQnode->pl_Children.end())) {
         // Get next node on the list
         prevPos = aPos;
-        if (!bReversed)
-            pTempNode = pQnode->pl_Children.GetNext(aPos);
-        else
-            pTempNode = pQnode->pl_Children.GetPrev(aPos);
+        if (!bReversed) {
+            pTempNode = *(std::get<forward_it>(aPos)++);
+        } else {
+            pTempNode = *(std::get<reverse_it>(aPos)++);
+        }
+
 
         // Insertion for full or for empty node?
         if (pTempNode->LABEL == FULL) {
@@ -1730,7 +1181,7 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
                 pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
 
             // Insert the full node
-            pPartial->pl_Children.AddTail(pTempNode);
+            pPartial->pl_Children.push_back(pTempNode);
             pTempNode->pParent = pPartial;
 
             // update the linked list of nodes
@@ -1741,24 +1192,30 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
             pPrevFullNode = pTempNode;
 
             // remove the full node for the list
-            pQnode->pl_Children.RemoveAt(prevPos);
+            if (!bReversed) {
+                pQnode->pl_Children.erase(std::prev(std::get<forward_it>(aPos)));
+            } else {
+                aPos = std::make_reverse_iterator(pQnode->pl_Children.erase(std::get<reverse_it>(aPos).base()));
+            }
         }
     }
 
     // Move all empty children to the partial node
-    if (!bReversed)
-        aPos = pQnode->pl_Children.GetTailPosition();
-    else
-        aPos = pQnode->pl_Children.GetHeadPosition();
-    CNode *pNextEmptyNode = pPartial->pl_Children.GetHead();
-    POSITION nextPos;
-    while (aPos) {
+    if (!bReversed) {
+        aPos = pQnode->pl_Children.rbegin();
+    } else {
+        aPos = pQnode->pl_Children.begin();
+    }
+    CNode *pNextEmptyNode = pPartial->pl_Children.front();
+    while ((!bReversed && std::get<reverse_it>(aPos) != pQnode->pl_Children.rend()) ||
+           (bReversed && std::get<forward_it>(aPos) != pQnode->pl_Children.end())) {
         // Get next node on the list
-        nextPos = aPos;
-        if (!bReversed)
-            pTempNode = pQnode->pl_Children.GetPrev(aPos);
-        else
-            pTempNode = pQnode->pl_Children.GetNext(aPos);
+        if (!bReversed) {
+            pTempNode = *(std::get<reverse_it>(aPos)++);
+        } else {
+            pTempNode = *(std::get<forward_it>(aPos)++);
+        }
+
 
         // Insertion for full or for empty node?
         if (pTempNode->LABEL == EMPTY) {
@@ -1769,7 +1226,7 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
                 pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
 
             // insert the empty node
-            pPartial->pl_Children.AddHead(pTempNode);
+            pPartial->pl_Children.push_front(pTempNode);
             pTempNode->pParent = pPartial;
 
             // update the linked list of nodes
@@ -1780,7 +1237,11 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
             pNextEmptyNode = pTempNode;
 
             // remove the empty node for the list
-            pQnode->pl_Children.RemoveAt(nextPos);
+            if (!bReversed) {
+                aPos = std::make_reverse_iterator(pQnode->pl_Children.erase(std::get<reverse_it>(aPos).base()));
+            } else {
+                pQnode->pl_Children.erase(std::prev(std::get<forward_it>(aPos)));
+            }
         }
     }
 
@@ -1793,12 +1254,12 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
         // Before removing the Q-node, insert the partial q-node in the parent
         CNode *pGrandFather = pQnode->pParent;
         if (pQnode->pLeftSibling != NULL) {
-            POSITION insertPos = pGrandFather->pl_Children.Find(pQnode->pLeftSibling);
-            pGrandFather->pl_Children.InsertAfter(insertPos, pPartial);
+            auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pQnode->pLeftSibling);
+            pGrandFather->pl_Children.insert(std::next(insertPos), pPartial);
         } else {
-            pGrandFather->pl_Children.AddHead(pPartial);
+            pGrandFather->pl_Children.push_front(pPartial);
         }
-        pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pQnode));
+        pGrandFather->pl_Children.remove(pQnode);
         pPartial->pParent = pGrandFather;
         pPartial->pLeftSibling = pQnode->pLeftSibling;
         pPartial->pRightSibling = pQnode->pRightSibling;
@@ -1809,33 +1270,23 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Now remove the Q-node
-    pQnode->pl_Children.RemoveAll();
-    delete pQnode;
+    pQnode->pl_Children.clear();
+    //	delete pQnode; // Removing this avoids invalid writes affecting the evaluation scaffolding
 
     // label new subtree
     pPartial->bRoot = bRoot;
     pPartial->LABEL = SINGLY_PARTIAL;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q2");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q3(CNode *pX, bool bRoot) {
     // Pattern is a Q-node with 0, 1 or 2 singly partial child,
     // Endmost subtrees must be empty or partial (otherwise Q2 would apply)
     // Middle subtree must be full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1847,15 +1298,17 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
     // Check node order:  [EMPTY]->[PARTIAL]->[FULL]->[PARTIAL]->[EMPTY]
     //		      State:     0         1         2        3         4
 
-    CNode *pFirst = pQnode->pl_Children.GetHead();
+    CNode *pFirst = pQnode->pl_Children.front();
     int nState = 0;
     CNode *pPartial1 = NULL;
     CNode *pPartial2 = NULL;
     CNode *pFirstFull = NULL;
     CNode *pLastFull = NULL;
-    POSITION sPos = pQnode->pl_Children.GetHeadPosition();
-    while (sPos && nState != 5) {
-        CNode *pChild = pQnode->pl_Children.GetNext(sPos);
+
+    for (CNode *pChild : pQnode->pl_Children) {
+        if (nState == 5) {
+            break;
+        }
 
         // use this oportunity to get partial nodes
         if (pChild->LABEL == SINGLY_PARTIAL) {
@@ -1920,32 +1373,17 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
     if (nState == 5)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q3 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q3\n");
 
     // Move partial1 to the Q-node
     CNode *pLastNode = NULL;
     if (pPartial1 != NULL) {
-        POSITION insertPos = pQnode->pl_Children.Find(pPartial1);
-        POSITION aPos = pPartial1->pl_Children.GetHeadPosition();
+        auto insertPos = std::find(pQnode->pl_Children.begin(), pQnode->pl_Children.end(), pPartial1);
         CNode *pPrevNode = pPartial1->pLeftSibling;
-        while (aPos) {
+        for (CNode *pTempNode : pPartial1->pl_Children) {
             // Get next node on the list
-            CNode *pTempNode = pPartial1->pl_Children.GetNext(aPos);
 
             // Insert the node node
-            pQnode->pl_Children.InsertBefore(insertPos, pTempNode);
+            pQnode->pl_Children.insert(insertPos, pTempNode);
             pTempNode->pParent = pQnode;
 
             // update the linked list of nodes
@@ -1958,9 +1396,9 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
         pLastNode = pPrevNode;
 
         // remove partial1
-        pQnode->pl_Children.RemoveAt(insertPos);
-        pPartial1->pl_Children.RemoveAll();
-        delete pPartial1;
+        pQnode->pl_Children.erase(insertPos);
+        pPartial1->pl_Children.clear();
+        //		delete pPartial1; // Removing this avoids invalid writes affecting the evaluation scaffolding
     }
 
     // Make the links in linked list if there are full nodes
@@ -1972,16 +1410,15 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
 
     // Move partial2 to the Q-node
     if (pPartial2 != NULL) {
-        POSITION insertPos = pQnode->pl_Children.Find(pPartial2);
-        POSITION aPos = pPartial2->pl_Children.GetTailPosition();
+        auto insertPos = std::find(pQnode->pl_Children.begin(), pQnode->pl_Children.end(), pPartial2);
         CNode *pPrevNode = pLastNode;
         CNode *pTempNode = NULL;
-        while (aPos) {
+        for (auto rit = pPartial2->pl_Children.rbegin(); rit != pPartial2->pl_Children.rend(); ++rit) {
             // Get next node on the list
-            pTempNode = pPartial2->pl_Children.GetPrev(aPos);
+            pTempNode = *rit;
 
             // Insert the node node
-            pQnode->pl_Children.InsertBefore(insertPos, pTempNode);
+            pQnode->pl_Children.insert(insertPos, pTempNode);
             pTempNode->pParent = pQnode;
 
             // update the linked list of nodes
@@ -1996,21 +1433,15 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
             pPartial2->pRightSibling->pLeftSibling = pTempNode;
 
         // remove partial1
-        pQnode->pl_Children.RemoveAt(insertPos);
-        pPartial2->pl_Children.RemoveAll();
-        delete pPartial2;
+        pQnode->pl_Children.erase(insertPos);
+        pPartial2->pl_Children.clear();
+        //		delete pPartial2;   // Removing this avoids invalid writes affecting the evaluation scaffolding
     }
 
     // label new subtree
     pQnode->bRoot = bRoot;
     pQnode->LABEL = DOUBLY_PARTIAL;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q3");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
@@ -2022,13 +1453,10 @@ void CPQtree::CountNodeTypes(CNode *pX) {
     mPartial = 0;
     mTotal = 0;
 
-    if (pX->IsKindOf(RUNTIME_CLASS(CLeafnode)))
+    if (dynamic_cast<CLeafnode *>(pX))
         return;
 
-    POSITION aPos = pX->pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pChildNode = pX->pl_Children.GetNext(aPos);
-
+    for (CNode *pChildNode : pX->pl_Children) {
         if (pChildNode->LABEL == FULL)
             mFull++;
         else if (pChildNode->LABEL == EMPTY)
@@ -2039,3 +1467,29 @@ void CPQtree::CountNodeTypes(CNode *pX) {
         mTotal++;
     }
 }
+
+Bigint CPQtree::possibleOrders() {
+    Bigint orders(1);
+
+    std::queue<CNode *> queue;
+    queue.push(pRoot);
+
+    while (!queue.empty()) {
+        CNode *nextNode = queue.front();
+        queue.pop();
+
+        if (dynamic_cast<CPnode *>(nextNode) != nullptr) {
+            int childCount = nextNode == pRoot ? nextNode->pl_Children.size() - 1 : nextNode->pl_Children.size();
+            orders *= factorial(childCount);
+        } else if (dynamic_cast<CQnode *>(nextNode) != nullptr) {
+            orders *= 2;
+        } else {
+            continue;
+        }
+
+        for (CNode *child : nextNode->pl_Children) {
+            queue.push(child);
+        }
+    }
+    return orders;
+}
diff --git a/libraries/graphSetPQ/PQtree.h b/libraries/graphSetPQ/PQtree.h
index e34825f..e518ce8 100644
--- a/libraries/graphSetPQ/PQtree.h
+++ b/libraries/graphSetPQ/PQtree.h
@@ -1,27 +1,22 @@
 #pragma once
 
 #include "Node.h"
-#include "Vertex.h"
-
-class CPQtree : public CObject {
-    DECLARE_DYNAMIC(CPQtree)
+#include "bigInt/bigint.h"
+#include <list>
 
+class CLeafnode;
+using namespace Dodecahedron;
+class CPQtree {
 public:
     CNode *pRoot;
-    int iHeight;
-    int iWidth;
-    int iLevels;
     bool bSets;
 
-    CDocument *pDoc;
-    CString sComment;// Comment for PQtreeView
-    int nIndent;     // Indentation for PQtreeView
 
     // GLOBAL VARIABLES as described in Booth and Lueker
     int BLOCK_COUNT;
     int BLOCKED_NODES;
     int OFF_THE_TOP;
-    CTypedPtrList<CObList, CNode *> QUEUE;
+    std::list<CNode *> QUEUE;
     CNode *pVirtual;// virtual node to walk around blocked nodes in BUBBLE procedure
 
     int mFull;
@@ -33,37 +28,35 @@ public:
     CNode *pLastPertinentRoot;
 
 public:
-    CRect Draw(CDC *pDC, CPoint Offset);
-    void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    void FindLeaves(std::list<CLeafnode *> *plQueue);
     void SetAllUnmatched();
     void ClearPointers();
     bool ArePertinentConsecutive(int v);
 
-    void CopyFullChildren(CVertex *pU, CNode *pNode);
-
-    CPQtree(CDocument *pDoc, CVertex *pStart);
-    CPQtree(CDocument *pDoc, CNode *pNode);
+    CPQtree(int numLeaves);
+    CPQtree(CNode *pNode);
     CPQtree(CPQtree *pqTree);
-    ~CPQtree(void);
+    ~CPQtree();
 
 public:
-    bool Bubble(CTypedPtrList<CObList, CNode *> *pl_S);
-    bool Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v);
-    void VertexAddition(CVertex *pV, CVertex *pU = NULL);
+    bool Bubble(std::list<CLeafnode *> *pl_S);
+    void prepareReduction(std::list<CLeafnode *> *pl_s, int v);
+    bool Reduce(std::list<CLeafnode *> *pl_S, int v);
     void ReInitialize();
     void CountNodeTypes(CNode *pX);
     void CountPertinentNodes(int v);
+    Bigint possibleOrders();
 
     // templates
 public:
-    bool Template_L1(CNode *pX, bool bRoot, int v, CString sText = CString(""));
-    bool Template_P1(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P2(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P3(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P4(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P5(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P6(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q1(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q2(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q3(CNode *pX, bool bRoot, CString sText = CString(""));
+    bool Template_L1(CNode *pX, bool bRoot, int v);
+    bool Template_P1(CNode *pX, bool bRoot);
+    bool Template_P2(CNode *pX, bool bRoot);
+    bool Template_P3(CNode *pX, bool bRoot);
+    bool Template_P4(CNode *pX, bool bRoot);
+    bool Template_P5(CNode *pX, bool bRoot);
+    bool Template_P6(CNode *pX, bool bRoot);
+    bool Template_Q1(CNode *pX, bool bRoot);
+    bool Template_Q2(CNode *pX, bool bRoot);
+    bool Template_Q3(CNode *pX, bool bRoot);
 };
diff --git a/libraries/graphSetPQ/Pnode.cpp b/libraries/graphSetPQ/Pnode.cpp
index 5cdce06..db914c2 100644
--- a/libraries/graphSetPQ/Pnode.cpp
+++ b/libraries/graphSetPQ/Pnode.cpp
@@ -1,387 +1,24 @@
 #include "Pnode.h"
-#include "Edge.h"
-#include "Leafnode.h"
 #include "Node.h"
-#include "Qnode.h"
-#include "stdafx.h"
 
-IMPLEMENT_DYNAMIC(CPnode, CNode)
 
 CPnode::CPnode() {
     // constructor creates an empty P-node
-    iWidth = 0;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = BLUE;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 }
 
-CPnode::CPnode(CVertex *pV, int Color) {
-    // constructor creates the P-node relative to pV, with all edges incident to pV
-    // as leaf nodes and children of the current node
-
-    iWidth = 0;
-    LABEL = EMPTY;
-    MARK = UNMARKED;
-    pParent = NULL;
-    bVirtual = false;
-    PERTINENT_LEAF_COUNT = 0;
-    PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
-    bRoot = false;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = Color;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
-
-    CElement *pElement;
-    CLeafnode *pLeafNode;
-    CLeafnode *pPrevLeafNode;
-    CVertex *pW;
-    POSITION aPos;
-
-    // iterate trough all edges incident to pV
-    aPos = pV->pl_Edges.GetHeadPosition();
-    pPrevLeafNode = NULL;
-    int leafColor;
-    while (aPos) {
-        pElement = pV->pl_Edges.GetNext(aPos);
-        if (pElement->IsKindOf(RUNTIME_CLASS(CEdge))) {
-            CEdge *pEdge = (CEdge *) pElement;
-            CEdge *pEdge2 = NULL;
-
-            // Create a leaf node for each edge incident to pV, but not for already processed vertices
-            pW = (pV == pEdge->pStart) ? pEdge->pEnd : pEdge->pStart;
-
-            // only vertices that are not yet processed (reversed order)
-            if (pW->nST < pV->nST) {
-                // Set the color of the edge (stored in the child)
-                //				if (pEdge->m_Graph==GRAPH1)
-                leafColor = BLUE;
-                //				else
-                //					leafColor = RED;
-
-                // Try to find the same edge on the other graph (a black edge)
-                bool bBlackBefore = false;
-                POSITION aPos2 = pV->pl_Edges.GetHeadPosition();// search from the beggining to current position
-                while (aPos2 && aPos2 != aPos) {
-                    CElement *pElement2 = pV->pl_Edges.GetNext(aPos2);
-                    if (pElement2->IsKindOf(RUNTIME_CLASS(CEdge))) {
-                        pEdge2 = (CEdge *) pElement2;
-
-                        if (pEdge != pEdge2 && pEdge->m_Graph != pEdge2->m_Graph && ((pEdge->pStart == pEdge2->pStart && pEdge->pEnd == pEdge2->pEnd) || (pEdge->pStart == pEdge2->pEnd && pEdge->pEnd == pEdge2->pStart))) {
-                            // This is a black edge
-                            bBlackBefore = true;
-                            break;
-                        }
-                    }
-                }
-
-                // Try to find the same edge on the other graph (a black edge)
-                bool bBlackAfter = false;
-                aPos2 = aPos;// search from current position to the end
-                while (aPos2) {
-                    CElement *pElement2 = pV->pl_Edges.GetNext(aPos2);
-                    if (pElement2->IsKindOf(RUNTIME_CLASS(CEdge))) {
-                        pEdge2 = (CEdge *) pElement2;
-
-                        if (pEdge != pEdge2 && pEdge->m_Graph != pEdge2->m_Graph && ((pEdge->pStart == pEdge2->pStart && pEdge->pEnd == pEdge2->pEnd) || (pEdge->pStart == pEdge2->pEnd && pEdge->pEnd == pEdge2->pStart))) {
-                            // This is a black edge
-                            bBlackAfter = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (!bBlackBefore) {
-
-                    // create a new leaf node or set the edge black
-                    if (bBlackAfter) {
-                        pLeafNode = new CLeafnode(pW, BLACK);
-                        pLeafNode->pParent = this;
-                    } else {
-                        pLeafNode = new CLeafnode(pW, leafColor);
-                        pLeafNode->pParent = this;
-                    }
-
-                    // update the linked list of nodes
-                    pLeafNode->pLeftSibling = (CNode *) pPrevLeafNode;
-                    if (pPrevLeafNode != NULL)
-                        pPrevLeafNode->pRightSibling = (CNode *) pLeafNode;
-                    pLeafNode->pRightSibling = NULL;
-                    pPrevLeafNode = pLeafNode;
-
-                    // Add the new node to linked lists
-                    pl_Children.AddTail(pLeafNode);
-                    pLeafNode->pNode->pl_S.AddTail(pLeafNode);
-                }
-            }
-        }
-    }
-}
-
-CPnode::CPnode(CPnode *pNode) {
-    iWidth = pNode->iWidth;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-
-    CNode *pTempNode;
-    CNode *pNewNode;
-    CNode *pPrevNode;
-
-    // This constructor creates a copy of the given pNode
-    POSITION aPos = pNode->pl_Children.GetHeadPosition();
-    pPrevNode = NULL;
-    while (aPos) {
-        pTempNode = (CNode *) pNode->pl_Children.GetNext(aPos);
-
-        if (pTempNode->IsKindOf(RUNTIME_CLASS(CPnode))) {
-            pNewNode = (CNode *) new CPnode((CPnode *) pTempNode);
-            pl_Children.AddTail((CPnode *) pNewNode);
-        } else if (pTempNode->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            pNewNode = (CNode *) new CQnode((CQnode *) pTempNode);
-            pl_Children.AddTail((CQnode *) pNewNode);
-        } else {
-            pNewNode = (CNode *) new CLeafnode((CLeafnode *) pTempNode);
-            pl_Children.AddTail((CLeafnode *) pNewNode);
-        }
-
-        // update the linked list of nodes
-        pNewNode->pLeftSibling = (CNode *) pPrevNode;
-        if (pPrevNode != NULL)
-            pPrevNode->pRightSibling = (CNode *) pNewNode;
-        pNewNode->pRightSibling = NULL;
-        pPrevNode = pNewNode;
+CPnode::~CPnode() {
+    for (CNode *node : pl_Children) {
+        delete node;
     }
-}
-
-CPnode::~CPnode(void) {
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        delete pl_Children.GetNext(aPos);
-    }
-
-    pl_Children.RemoveAll();
-}
-
-int CPnode::CalculateWidth() {
-    POSITION aPos;
-    CNode *pNode;
 
-    iWidth = 0;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        iWidth += pNode->CalculateWidth();
-    }
-
-    return iWidth;
-}
-
-int CPnode::CalculateLevel(int level) {
-    POSITION aPos;
-    CNode *pNode;
-
-    iLevel = level;
-    int maxLevel = level;
-    int newLevel;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        newLevel = pNode->CalculateLevel(level + 1);
-
-        if (newLevel > maxLevel) maxLevel = newLevel;
-    }
-
-    return maxLevel;
-}
-
-void CPnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    POSITION aPos;
-    CNode *pNode;
-    int offx;
-    int childx;
-    CBrush blueBrush(RGB(0, 0, 255));
-    CBrush lightBlueBrush(RGB(40, 190, 220));
-    CBrush *pOldBrush;
-    CPen bluePen(PS_SOLID, 2, RGB(0, 0, 255));
-    CPen redPen(PS_SOLID, 2, RGB(255, 0, 0));
-
-    // Calculate the area for the node
-    int centerx = Offset.x + (iWidth / 2);
-    CRect ellipseRect = CRect(centerx - PNODERAD, Offset.y, centerx + PNODERAD + 1, Offset.y + (PNODERAD * 2) + 1);
-
-    // If the node is the root of the pertinent subtree, draw a gray background
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        ellipseRect.InflateRect(5, 5);
-        pDC->Ellipse(ellipseRect);
-        ellipseRect.DeflateRect(5, 5);
-    }
-
-    pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the edges to the children: BLUE first
-    pDC->SelectObject(bluePen);
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the edges to the children: now BLACK ones
-    pDC->SelectStockObject(BLACK_PEN);
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLACK) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the edges to the children: now RED ones
-    pDC->SelectObject(redPen);
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == RED) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Choose the node depending of the type of node
-    if (LABEL == FULL)
-        pOldBrush = pDC->SelectObject(&blueBrush);
-    else if (LABEL == PARTIAL || LABEL == SINGLY_PARTIAL || LABEL == DOUBLY_PARTIAL)
-        pOldBrush = pDC->SelectObject(&lightBlueBrush);
-    else
-        pOldBrush = (CBrush *) pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the node
-    pDC->SelectStockObject(BLACK_PEN);
-    pDC->Ellipse(ellipseRect);
-
-    // Draw the children: BLUE first
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the children: now BLACK ones
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLACK) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the children: now RED ones
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == RED) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = ellipseRect.left - ARROWSIZE;
-        int arrowY = ellipseRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // If we are debugging, display node address
-    if (DEBUG_PQTREE) {
-        char alfa[MAX_ALFA];
-        int tx = ellipseRect.CenterPoint().x + PNODERAD * 2;
-        int ty = ellipseRect.top - PNODERAD;
-        CRect drawRect = CRect(tx, ty, tx + LEAFWIDTH, ty + LEVELHEIGHT);
-        CRect calcRect = CRect(drawRect);
-
-        sprintf_s(alfa, "(%p)\nc(%d)\nl(%d)", pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-        pDC->DrawText(CString(alfa), calcRect, DT_CALCRECT);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        calcRect.InflateRect(2, 2, 2, 2);
-        pDC->Rectangle(calcRect);
-        calcRect.DeflateRect(2, 2, 2, 2);
-        pDC->DrawText(CString(alfa), drawRect, 0);
-    }
+    pl_Children.clear();
 }
diff --git a/libraries/graphSetPQ/Pnode.h b/libraries/graphSetPQ/Pnode.h
index fc5698c..2c81d9f 100644
--- a/libraries/graphSetPQ/Pnode.h
+++ b/libraries/graphSetPQ/Pnode.h
@@ -1,19 +1,10 @@
 #pragma once
 
-#include "Vertex.h"
-#include "node.h"
+#include "Node.h"
 
 class CPnode : public CNode {
-    DECLARE_DYNAMIC(CPnode)
-
 public:
     CPnode();
-    CPnode(CVertex *pV, int Color);
-    CPnode(CPnode *pNode);
-
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
 
-    virtual ~CPnode(void);
+    virtual ~CPnode();
 };
diff --git a/libraries/graphSetPQ/Qnode.cpp b/libraries/graphSetPQ/Qnode.cpp
index 9ef5220..4d83bf4 100644
--- a/libraries/graphSetPQ/Qnode.cpp
+++ b/libraries/graphSetPQ/Qnode.cpp
@@ -1,254 +1,29 @@
-#include ".\qnode.h"
-#include "Constants.h"
-#include "Leafnode.h"
+#include "Qnode.h"
+#include "LeafNode.h"
 #include "Pnode.h"
-#include "stdafx.h"
 
-IMPLEMENT_DYNAMIC(CQnode, CNode)
 
 CQnode::CQnode() {
-    iWidth = 0;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = BLUE;
-
-    // pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 }
 
-CQnode::CQnode(CQnode *pNode) {
-    // Constructor for copying
-
-    iWidth = pNode->iWidth;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-
-    CNode *pTempNode;
-    CNode *pNewNode;
-    CNode *pPrevNode;
-
-    // This constructor creates a copy of the given pNode
-    POSITION aPos = pNode->pl_Children.GetHeadPosition();
-    pPrevNode = NULL;
-    while (aPos) {
-        pTempNode = (CNode *) pNode->pl_Children.GetNext(aPos);
 
-        if (pTempNode->IsKindOf(RUNTIME_CLASS(CPnode))) {
-            pNewNode = (CNode *) new CPnode((CPnode *) pTempNode);
-            pl_Children.AddTail((CPnode *) pNewNode);
-        } else if (pTempNode->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            pNewNode = (CNode *) new CQnode((CQnode *) pTempNode);
-            pl_Children.AddTail((CQnode *) pNewNode);
-        } else {
-            pNewNode = (CNode *) new CLeafnode((CLeafnode *) pTempNode);
-            pl_Children.AddTail((CLeafnode *) pNewNode);
-        }
-
-        // update the linked list of nodes
-        pNewNode->pLeftSibling = (CNode *) pPrevNode;
-        if (pPrevNode != NULL)
-            pPrevNode->pRightSibling = (CNode *) pNewNode;
-        pNewNode->pRightSibling = NULL;
-        pPrevNode = pNewNode;
-    }
-}
-
-CQnode::~CQnode(void) {
+CQnode::~CQnode() {
     if (bVirtual)
         return;// real parent will dispose the children
 
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        delete pl_Children.GetNext(aPos);
-    }
-
-    pl_Children.RemoveAll();
-}
-
-int CQnode::CalculateWidth() {
-    POSITION aPos;
-    CNode *pNode;
-
-    iWidth = 0;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        iWidth += pNode->CalculateWidth();
-    }
-
-    return iWidth;
-}
-
-int CQnode::CalculateLevel(int level) {
-    POSITION aPos;
-    CNode *pNode;
-
-    iLevel = level;
-    int maxLevel = level;
-    int newLevel;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        newLevel = pNode->CalculateLevel(level + 1);
 
-        if (newLevel > maxLevel) maxLevel = newLevel;
+    for (CNode *node : pl_Children) {
+        delete node;
     }
 
-    return maxLevel;
-}
-
-void CQnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    POSITION aPos;
-    CNode *pNode;
-    int offx;
-    int childx;
-    CBrush blueBrush(RGB(0, 0, 255));
-    CBrush navyBlueBrush(RGB(0, 0, 64));
-    CBrush *pOldBrush;
-    CPen bluePen(PS_SOLID, 2, RGB(0, 0, 255));
-    CPen redPen(PS_SOLID, 2, RGB(255, 0, 0));
-
-    // Calculate the are for the node
-    int centerx = Offset.x + (iWidth / 2);
-    CRect QRect = CRect(Offset.x + SIBLINGMARGIN, Offset.y, Offset.x + iWidth - SIBLINGMARGIN, Offset.y + QNODESIZE);
-
-    // If the nood is the root of the pertinent subtree, draw a gray background
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        QRect.InflateRect(3, 3);
-        pDC->Rectangle(QRect);
-        QRect.DeflateRect(3, 3);
-    }
-
-    pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the edges to the children
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE)
-            pDC->SelectObject(bluePen);
-        else if (pNode->EdgeColor == RED)
-            pDC->SelectObject(redPen);
-        else
-            pDC->SelectStockObject(BLACK_PEN);
-
-        childx = offx + (pNode->iWidth / 2);
-        pDC->MoveTo(centerx, Offset.y + PNODERAD);
-        pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-        offx += pNode->iWidth;
-    }
-
-    // Draw the node
-    if (LABEL == FULL) {
-        pOldBrush = pDC->SelectObject(&blueBrush);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == PARTIAL) {
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == SINGLY_PARTIAL) {
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        pDC->Rectangle(QRect.CenterPoint().x - 1, QRect.top, QRect.right, QRect.bottom);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.left, QRect.top, QRect.CenterPoint().x, QRect.bottom);
-        pDC->SelectStockObject(BLACK_PEN);
-        pDC->SelectStockObject(NULL_BRUSH);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == DOUBLY_PARTIAL) {
-        int t = QRect.Width() / 3;
-        pDC->SelectStockObject(NULL_PEN);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.left, QRect.top, QRect.left + t - 1, QRect.bottom);
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->Rectangle(QRect.left + t, QRect.top, QRect.right - t, QRect.bottom);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.right - t + 1, QRect.top, QRect.right, QRect.bottom);
-        pDC->SelectStockObject(BLACK_PEN);
-        pDC->SelectStockObject(NULL_BRUSH);
-        pDC->Rectangle(QRect);
-    } else {
-        // EMPTY
-        pOldBrush = (CBrush *) pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect);
-    }
-
-    // Draw the children
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-        offx += pNode->iWidth;
-    }
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = QRect.left - ARROWSIZE;
-        int arrowY = QRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // If we are debugging, display node address
-    if (DEBUG_PQTREE) {
-        char alfa[MAX_ALFA];
-        int tx = QRect.CenterPoint().x + PNODERAD * 2;
-        int ty = QRect.top + PNODERAD * 2;
-        CRect drawRect = CRect(tx, ty, tx + LEAFWIDTH, ty + LEVELHEIGHT);
-        CRect calcRect = CRect(drawRect);
-
-        sprintf_s(alfa, "(%p)\nc(%d)\nl(%d)", pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-        pDC->DrawText(CString(alfa), calcRect, DT_CALCRECT);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        calcRect.InflateRect(2, 2, 2, 2);
-        pDC->Rectangle(calcRect);
-        calcRect.DeflateRect(2, 2, 2, 2);
-        pDC->DrawText(CString(alfa), drawRect, 0);
-    }
-
-    pDC->SelectObject(pOldBrush);
-    blueBrush.DeleteObject();
-}
+    pl_Children.clear();
+}
\ No newline at end of file
diff --git a/libraries/graphSetPQ/Qnode.h b/libraries/graphSetPQ/Qnode.h
index b3d8818..2f6a980 100644
--- a/libraries/graphSetPQ/Qnode.h
+++ b/libraries/graphSetPQ/Qnode.h
@@ -1,16 +1,10 @@
 #pragma once
-#include "node.h"
+#include "Node.h"
 
 class CQnode : public CNode {
-    DECLARE_DYNAMIC(CQnode)
 
 public:
-    CQnode(void);
-    CQnode(CQnode *pNode);
-
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
+    CQnode();
 
     virtual ~CQnode(void);
 };
-- 
2.35.1

