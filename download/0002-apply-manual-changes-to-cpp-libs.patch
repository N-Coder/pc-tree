From c029012b8adf17d39de5a90c04b419777b050f78 Mon Sep 17 00:00:00 2001
From: Simon Dominik Niko Fink <simon.fink@uni-passau.de>
Date: Thu, 6 May 2021 17:23:52 +0200
Subject: [PATCH 2/3] apply manual changes to cpp libs

---
 libraries/bivocPQ/pqnode.h        |   13 +-
 libraries/bivocPQ/pqtree.h        |   82 ++-
 libraries/creislePQ/Leaf.cpp      |    2 +-
 libraries/creislePQ/Leaf.h        |   14 +-
 libraries/creislePQ/Node.cpp      |    4 +-
 libraries/creislePQ/Node.h        |   16 +-
 libraries/creislePQ/PQTree.cpp    |   41 +-
 libraries/creislePQ/PQTree.h      |   21 +-
 libraries/creislePQ/PQnode.cpp    |    6 +-
 libraries/creislePQ/PQnode.h      |   19 +-
 libraries/creislePQ/main.cpp      |  298 --------
 libraries/graphSetPQ/LeafNode.cpp |  141 +---
 libraries/graphSetPQ/LeafNode.h   |   19 +-
 libraries/graphSetPQ/Node.cpp     |   58 +-
 libraries/graphSetPQ/Node.h       |   43 +-
 libraries/graphSetPQ/PQtree.cpp   | 1088 +++++++----------------------
 libraries/graphSetPQ/PQtree.h     |   55 +-
 libraries/graphSetPQ/Pnode.cpp    |  371 +---------
 libraries/graphSetPQ/Pnode.h      |   13 +-
 libraries/graphSetPQ/Qnode.cpp    |  239 +------
 libraries/graphSetPQ/Qnode.h      |   10 +-
 libraries/gregablePQ/README       |   35 -
 libraries/gregablePQ/SConstruct   |   15 -
 libraries/gregablePQ/fuzztest.cc  |   77 --
 libraries/gregablePQ/gpl.txt      |  674 ------------------
 libraries/gregablePQ/pqnode.cc    |    3 +-
 libraries/gregablePQ/pqnode.h     |    5 +-
 libraries/gregablePQ/pqtest.cc    |  171 -----
 libraries/gregablePQ/pqtree.cc    |   46 +-
 libraries/gregablePQ/pqtree.h     |   12 +-
 libraries/zanettiPQR/Leaf.h       |   18 +-
 libraries/zanettiPQR/Node.h       |  104 +--
 libraries/zanettiPQR/PQRNode.h    |  159 +++--
 libraries/zanettiPQR/PQRTree.h    |  390 ++++-------
 34 files changed, 820 insertions(+), 3442 deletions(-)
 delete mode 100644 libraries/creislePQ/main.cpp
 delete mode 100644 libraries/gregablePQ/README
 delete mode 100644 libraries/gregablePQ/SConstruct
 delete mode 100644 libraries/gregablePQ/fuzztest.cc
 delete mode 100644 libraries/gregablePQ/gpl.txt
 delete mode 100644 libraries/gregablePQ/pqtest.cc

diff --git a/libraries/bivocPQ/pqnode.h b/libraries/bivocPQ/pqnode.h
index 5de5c4c..36cd3de 100644
--- a/libraries/bivocPQ/pqnode.h
+++ b/libraries/bivocPQ/pqnode.h
@@ -25,8 +25,7 @@
  *   Some of the comments and variable names are verbatim from the Booth   *
  *   and Lueker paper where this algorithm was first described.            *
  ***************************************************************************/
-#ifndef PQNODE_H
-#define PQNODE_H
+#pragma once
 
 /**
 Internal class used by pqtree to represent individual nodes in the pqtree.
@@ -34,12 +33,16 @@ Internal class used by pqtree to represent individual nodes in the pqtree.
 @author Virginia Tech
 */
 
+#include <csignal>
 #include <list>
 #include <map>
 #include <set>
 #include <vector>
+
 using namespace std;
 
+namespace bivoc {
+
 //declaration of enum types that can be used
 enum pqnode_types { leaf,
                     pnode,
@@ -161,7 +164,6 @@ public:
     void print(int numtabs = 0);
 };
 
-#endif
 
 //Due to the peculiar nature of templates, the implementation
 //details must also be included in the header file, hence the functions
@@ -305,6 +307,10 @@ const pqnode<T> &pqnode<T>::operator=(const pqnode<T> &toCopy) {
 //if last pointer is null, will return the first sibling
 template<class T>
 pqnode<T> *pqnode<T>::qNextChild(pqnode<T> *last) {
+    if (immediate_siblings.empty()) {
+        raise(SIGUSR1);
+    }
+
     if (*(immediate_siblings.begin()) == last) {
         if (immediate_siblings.size() == 1)
             return NULL;
@@ -523,3 +529,4 @@ void pqnode<T>::print(int numtabs) {
         }
     }
 }
+}
diff --git a/libraries/bivocPQ/pqtree.h b/libraries/bivocPQ/pqtree.h
index ac9af6b..8e68b03 100644
--- a/libraries/bivocPQ/pqtree.h
+++ b/libraries/bivocPQ/pqtree.h
@@ -23,7 +23,9 @@ PQ-Tree class based on the paper entitled "Testing for the Consecutive Onces Pro
 
 @author Virginia Tech
 */
+#pragma once
 
+#include "bigInt/bigint.h"
 #include "pqnode.h"
 #include "setTemplates.h"
 #include <list>
@@ -31,11 +33,11 @@ PQ-Tree class based on the paper entitled "Testing for the Consecutive Onces Pro
 #include <queue>
 #include <set>
 #include <vector>
-using namespace std;
 
-#ifndef PQTREE_H
-#define PQTREE_H
+using namespace std;
 
+namespace bivoc {
+using namespace Dodecahedron;
 //variable to initiate debugging output
 //simply leave this false
 bool debugOut = false;
@@ -64,7 +66,7 @@ private:
     //to fix, you can create an array of items so that each item hashes
     //to its leaf address in constant time, but this is a tradeoff to
     //conserve space
-    map<T, pqnode<T> *> leafAddress;
+    std::vector<pqnode<T> *> leafAddress;
 
     //a reference to a pseudonode that cannot be reached through the root
     //of the tree.  The pseudonode is a temporary node designed to handle
@@ -150,9 +152,12 @@ public:
 
     //returns the set of all elements on which a reduction was performed with
     set<T> getContained();
+
+    Bigint possibleOrders();
+
+    void cleanUp();
 };
 
-#endif
 
 //copy constructor
 template<class T>
@@ -164,6 +169,7 @@ pqtree<T>::pqtree(const pqtree<T> &toCopy) {
     invalid = toCopy.invalid;
     reductions = toCopy.reductions;
     pseudonode = NULL;
+    leafAddress.reserve(toCopy.leafAddress.capacity());
     leafAddress.clear();
     root->findLeaves(leafAddress);
 }
@@ -181,6 +187,7 @@ const pqtree<T> &pqtree<T>::operator=(const pqtree &toCopy) {
     off_the_top = toCopy.off_the_top;
     reductions = toCopy.reductions;
     leafAddress.clear();
+    leafAddress.reserve(toCopy.leafAddress.capacity());
     root->findLeaves(leafAddress);
 
     return this;
@@ -1105,15 +1112,17 @@ bool pqtree<T>::bubble(set<T> S) {
                 pseudonode->pertinent_leaf_count += (*i)->pertinent_leaf_count;
                 int count = 0;//count number of immediate siblings
                 int loop = 0;
-                for (typename set<pqnode<T> *>::iterator j = (*i)->immediate_siblings.begin(); j != (*i)->immediate_siblings.end() && loop < 2; j++) {
+                for (typename set<pqnode<T> *>::iterator j = (*i)->immediate_siblings.begin(); j != (*i)->immediate_siblings.end() && loop < 2;) {
                     loop++;
 
-                    if ((*j)->mark == blocked)
+                    auto jEl = *j;
+                    ++j;
+                    if (jEl->mark == blocked)
                         count++;
                     else {
-                        (*i)->immediate_siblings.erase(*j);
-                        (*j)->immediate_siblings.erase(*i);
-                        pseudonode->pseudo_neighbors[side] = *j;
+                        (*i)->immediate_siblings.erase(std::prev(j));
+                        jEl->immediate_siblings.erase(*i);
+                        pseudonode->pseudo_neighbors[side] = jEl;
                     }
                 }
                 (*i)->parent = pseudonode;
@@ -1237,6 +1246,7 @@ void pqtree<T>::cleanPseudo() {
 //basic constructor from an initial set
 template<class T>
 pqtree<T>::pqtree(set<T> S) {
+    leafAddress.reserve((*S.end()) + 1);
     //set up the root node as a P-Node initially
     root = new pqnode<T>;
     root->type = pnode;
@@ -1326,9 +1336,6 @@ bool pqtree<T>::reduce(set<T> S) {
         pseudonode = NULL;
     }
 
-    //reset all the temporary variables for the next round
-    root->reset();
-
     //store the reduction set for later lookup
     reductions.push_back(S);
 
@@ -1336,6 +1343,12 @@ bool pqtree<T>::reduce(set<T> S) {
     return true;
 }
 
+template<class T>
+void pqtree<T>::cleanUp() {
+    //reset all the temporary variables for the next round
+    root->reset();
+}
+
 template<class T>
 bool pqtree<T>::reduceAll(list<set<T>> L) {
     if (debugOut)
@@ -1421,3 +1434,46 @@ pqtree<T>::~pqtree() {
     delete root;
     //delete pseudonode;
 }
+
+template<class T>
+Bigint pqtree<T>::possibleOrders() {
+    Bigint orders(1);
+
+    std::queue<pqnode<T> *> queue;
+
+    queue.push(root);
+
+    while (!queue.empty()) {
+        pqnode<T> *nextNode = queue.front();
+        queue.pop();
+
+        if (nextNode->type == pqnode_types::pnode) {
+            int childCount = nextNode == root ? nextNode->child_count() - 1 : nextNode->child_count();
+            orders *= factorial(childCount);
+            for (pqnode<T> *child : nextNode->circular_link) {
+                if (child->type != pqnode_types::leaf) {
+                    queue.push(child);
+                }
+            }
+        } else if (nextNode->type == pqnode_types::qnode) {
+            orders *= 2;
+
+            pqnode<T> *nextChild = nextNode->endmost_children[0];
+            pqnode<T> *previousChild = nullptr;
+
+
+            while (nextChild != nullptr) {
+                if (nextChild->type != pqnode_types::leaf) {
+                    queue.push(nextChild);
+                }
+                pqnode<T> *tmp = nextChild;
+                nextChild = nextChild->qNextChild(previousChild);
+                previousChild = tmp;
+            }
+        }
+    }
+
+    return orders;
+}
+
+}
diff --git a/libraries/creislePQ/Leaf.cpp b/libraries/creislePQ/Leaf.cpp
index ed2b780..b13fba5 100644
--- a/libraries/creislePQ/Leaf.cpp
+++ b/libraries/creislePQ/Leaf.cpp
@@ -10,7 +10,7 @@ static int buildcount = 0;
 
 using std::cerr;
 using std::endl;
-
+using namespace creisle;
 
 Leaf::Leaf(Node *p, int v, std::list<Leaf *> &leaflist, int src /*-1*/)
     : Node() {
diff --git a/libraries/creislePQ/Leaf.h b/libraries/creislePQ/Leaf.h
index a0f0072..599fc85 100644
--- a/libraries/creislePQ/Leaf.h
+++ b/libraries/creislePQ/Leaf.h
@@ -1,12 +1,4 @@
-
-#ifndef __LEAF_H
-#define __LEAF_H
-
-//warning to ignore
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
-#pragma GCC diagnostic ignored "-Wc++98-compat"
-#pragma GCC diagnostic ignored "-Wc++98-compat-pedantic"
+#pragma once
 
 
 //dependencies
@@ -19,6 +11,8 @@ enum nodetype {pnode , qnode, leafnode};
 enum marking {empty, partial, full};
 */
 
+namespace creisle {
+
 class Leaf : public Node {
 private:
     int value;
@@ -48,4 +42,4 @@ public:
     int get_source();
 };
 
-#endif
+}
\ No newline at end of file
diff --git a/libraries/creislePQ/Node.cpp b/libraries/creislePQ/Node.cpp
index 88f1971..83881ef 100644
--- a/libraries/creislePQ/Node.cpp
+++ b/libraries/creislePQ/Node.cpp
@@ -4,7 +4,7 @@
 
 #include "Node.h"
 
-
+using namespace creisle;
 //this will be the parent class for P-nodes, C-nodes and Q-nodes
 //on the reduction step will ensure that we have a valid PQ tree
 Node::Node()//default constructor
@@ -46,7 +46,7 @@ marking Node::get_mark() const { return node_mark; }
 void Node::set_parent(Node *p) { parent = p; }
 
 //comparison to sort lists of marked nodes by marking so that they follow the form e...p...f
-bool compare_marking(Node *first, Node *second) {
+bool creisle::compare_marking(Node *first, Node *second) {
     marking a = first->get_mark();
     marking b = second->get_mark();
     if (a == b) {
diff --git a/libraries/creislePQ/Node.h b/libraries/creislePQ/Node.h
index 58c44d5..958c560 100644
--- a/libraries/creislePQ/Node.h
+++ b/libraries/creislePQ/Node.h
@@ -1,12 +1,4 @@
-
-#ifndef __NODE_H
-#define __NODE_H
-
-//warning to ignore
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
-#pragma GCC diagnostic ignored "-Wc++98-compat"
-#pragma GCC diagnostic ignored "-Wc++98-compat-pedantic"
+#pragma once
 
 //dependencies
 #include <cstdlib>
@@ -15,6 +7,8 @@
 #include <string>
 #include <vector>
 
+namespace creisle {
+
 enum nodetype { pnode,
                 qnode,
                 leafnode };
@@ -58,8 +52,8 @@ public:
 
 bool compare_marking(Node *, Node *);
 
+}
+
 namespace custom {
 bool contains(std::vector<int> vec, int v);
 };
-
-#endif
diff --git a/libraries/creislePQ/PQTree.cpp b/libraries/creislePQ/PQTree.cpp
index 4d9bd6a..abab255 100644
--- a/libraries/creislePQ/PQTree.cpp
+++ b/libraries/creislePQ/PQTree.cpp
@@ -10,10 +10,7 @@
  */
 
 #include "PQTree.h"
-
-//warning to ignore
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
+#include <queue>
 
 static bool follow = false;//use this to find bugs. prints out function names when a function is executed
 static bool debug = false;
@@ -25,6 +22,7 @@ static std::string string_marking[] = {"empty", "partial", "full"};
 using std::cerr;
 using std::cout;
 using std::endl;
+using namespace creisle;
 
 PQTree::PQTree() {
     if (leaks) { cerr << "PQTree++ " << ++buildcount << endl; }
@@ -156,12 +154,18 @@ PQnode *PQTree::reduce(std::vector<int> values) {
 bool PQTree::set_consecutive(std::vector<int> values) {
     if (follow) { printf("PQTree::set_consecutive(std::vector<int> values)\n"); }
     PQnode *subroot = reduce(values);
+    previousSubroot = subroot;
     if (subroot == NULL) { return false; }
 
-    subroot->unmark();
     return true;
 }
 
+void PQTree::cleanUp() {
+    if (previousSubroot != nullptr) {
+        previousSubroot->unmark();
+    }
+}
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * function: replace_full_with(Node *child)
  * input: a pointer to the child node we want to insert
@@ -475,3 +479,30 @@ std::string PQTree::convert_to_gml() {
     result += "]\n";
     return result;
 }
+
+Bigint PQTree::possibleOrders() {
+    Bigint orders(1);
+
+    std::queue<PQnode *> queue;
+    queue.push(root);
+
+    while (!queue.empty()) {
+        PQnode *nextNode = queue.front();
+        queue.pop();
+
+        if (nextNode->get_type() == pnode) {
+            int childCount = root == nextNode ? nextNode->children.size() - 1 : nextNode->children.size();
+            orders *= factorial(childCount);
+        } else if (nextNode->get_type() == qnode) {
+            orders *= 2;
+        }
+
+        for (Node *child : nextNode->children) {
+            if (child->get_type() != leafnode) {
+                queue.push(dynamic_cast<PQnode *>(child));
+            }
+        }
+    }
+
+    return orders;
+}
diff --git a/libraries/creislePQ/PQTree.h b/libraries/creislePQ/PQTree.h
index 769bd0b..3f10868 100644
--- a/libraries/creislePQ/PQTree.h
+++ b/libraries/creislePQ/PQTree.h
@@ -1,18 +1,14 @@
-
-#ifndef __PQTree_H
-#define __PQTree_H
-
-//warning to ignore
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
+#pragma once
 
 //dependencies
 #include "PQnode.h"
+#include "bigInt/bigint.h"
 
+namespace creisle {
+using namespace Dodecahedron;
 //forward dependencies
 class Node;
 
-
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Class PQTree
  * purpose: implementation of booth and lueker's (1976) PQ tree
@@ -23,6 +19,7 @@ class Node;
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 class PQTree {
 private:
+    PQnode *previousSubroot = nullptr;
     int stage;//use in keeping track of printouts
     Leaf *special_leaf;
     PQnode *root;              //pointer to the root of the PQ tree
@@ -65,7 +62,11 @@ public:
 
     //comparing
     bool equivalent(PQTree &);
-};
 
+    Bigint possibleOrders();
+
+
+    void cleanUp();
+};
 
-#endif
+}
\ No newline at end of file
diff --git a/libraries/creislePQ/PQnode.cpp b/libraries/creislePQ/PQnode.cpp
index c92966a..dae4d4b 100644
--- a/libraries/creislePQ/PQnode.cpp
+++ b/libraries/creislePQ/PQnode.cpp
@@ -6,11 +6,6 @@
 
 #include "PQnode.h"
 
-//warning to ignore
-
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
-
 static bool follow = false;
 static bool debug = false;
 static int builtcount = 0;
@@ -18,6 +13,7 @@ static int builtcount = 0;
 using std::cerr;
 using std::cout;
 using std::endl;
+using namespace creisle;
 
 PQnode::PQnode()
     : Node() {
diff --git a/libraries/creislePQ/PQnode.h b/libraries/creislePQ/PQnode.h
index 6a0548e..0a64a09 100644
--- a/libraries/creislePQ/PQnode.h
+++ b/libraries/creislePQ/PQnode.h
@@ -1,12 +1,4 @@
-
-
-#ifndef __PQNode_H
-#define __PQNode_H
-
-//warning to ignore
-#pragma GCC diagnostic ignored "-Wpadded"
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
-#pragma GCC diagnostic ignored "-Wc++98-compat"
+#pragma once
 
 //dependencies
 #include "Leaf.h"
@@ -19,9 +11,11 @@ enum print_option {option_none, option_marking, option_depth, option_src };
 enum nodetype {pnode , qnode, leafnode};
 enum marking {empty, partial, full};
 */
-
+namespace creisle {
 
 class PQnode : public Node {
+    friend class PQTree;
+
 private:
     std::list<Node *> children;//empty list of children
     bool flipped;
@@ -61,7 +55,7 @@ public:
     bool mark();
     void unmark();
     bool condense_and_replace(Node *, std::list<int> &);
-    bool link_child(Node *, direction_type dir = right);//DANGEROUS!
+    bool link_child(Node *, direction_type dir = direction_type::right);//DANGEROUS!
     void update_depth();
 
     //function for tree reduction
@@ -76,11 +70,10 @@ public:
     void print();
     std::string convert_to_gml(int &);
 };
+}
 
 namespace custom {
 void print(std::list<int>);
 void print(std::vector<int>);
 bool compare(std::string s1, std::string s2);
 };
-
-#endif
diff --git a/libraries/creislePQ/main.cpp b/libraries/creislePQ/main.cpp
deleted file mode 100644
index 2125b4f..0000000
--- a/libraries/creislePQ/main.cpp
+++ /dev/null
@@ -1,298 +0,0 @@
-
-
-/*
- * A test case that is designed to produce
- * example errors and failures
- *
- */
-
-#include "PQTree.h"
-#include <cppunit/extensions/HelperMacros.h>
-#include <cppunit/ui/text/TestRunner.h>
-#include <sstream>
-#include <stdlib.h>
-
-#pragma GCC diagnostic ignored "-Wc++11-extensions"
-#pragma GCC diagnostic ignored "-Wpadded"
-
-
-class PQTreeTests : public CppUnit::TestFixture {
-    CPPUNIT_TEST_SUITE(PQTreeTests);
-    CPPUNIT_TEST(testPlanar);
-    CPPUNIT_TEST(testConsectuive);
-    CPPUNIT_TEST(testConstructExpression);
-    CPPUNIT_TEST(testEquivalent);
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-    //assumes the input adjacency matrix starts numbering vertices at 1
-    bool testPlanar(std::vector<std::vector<int>> adj, PQTree **tp) {
-        PQTree *tree = new PQTree(adj[0], 1);
-
-        for (size_t i = 1; i < adj.size(); i++) {
-            int curr = (int) (i + 1);
-            std::vector<int> v = adj[i];
-            bool result = tree->reduce_and_replace(curr, v);
-            if (!result) {
-                fprintf(stderr, "error in building the and reducing the tree\n");
-                return false;
-            }
-        }
-        *tp = tree;
-        return true;
-    }
-
-    void testPlanar() {
-        //adjacency matrix of an st-numbered input graph
-        PQTree *tree = NULL;
-        std::vector<std::vector<int>> adj =
-                {
-                        {2, 3, 4, 5, 6},
-                        {3, 6, 7},
-                        {4, 7},
-                        {5, 7},
-                        {7},
-                        {7},
-                        {0}// 0 is not actually a node. but just so we can check the final reduction
-                };
-
-
-        bool result = testPlanar(adj, &tree);
-
-        std::string exp = "{ 0 }";
-
-        CPPUNIT_ASSERT_MESSAGE("Expected: " + exp + "\nFound: " + tree->print_expression() + "\n", custom::compare(exp, tree->print_expression()));
-        CPPUNIT_ASSERT(result);
-
-        delete tree;
-        tree = NULL;
-
-        std::vector<std::vector<int>> adj2 =
-                {
-                        {2, 3, 10},//1
-                        {3, 6, 8}, //2
-                        {4, 10},   //3
-                        {5, 6, 10},//4
-                        {6, 9},    //5
-                        {7, 9},    //6
-                        {8, 9},    //7
-                        {9},       //8
-                        {10},      //9
-                };
-        result = testPlanar(adj2, &tree);
-
-        exp = "{ 10  [ 10  10  10 ] }";
-        CPPUNIT_ASSERT(result);
-        CPPUNIT_ASSERT_MESSAGE("Expected: " + exp + "\nFound: " + tree->print_expression() + "\n", custom::compare(exp, tree->print_expression()));
-        delete tree;
-        tree = NULL;
-    }
-
-    void testConsectuive()//purpose: tests a consectutive ones matrix example
-    {
-        bool pass = true;
-        std::vector<std::vector<int>> mat =
-                {
-                        {2, 3, 4},//values that are one in our matrix
-                        {1, 2, 3},
-                        {4, 5},
-                        {2, 3},
-                        {3, 4},
-                        {1},
-                        {5}};
-        PQTree *tree = new PQTree("{1, 2, 3, 4, 5}");
-
-        for (size_t i = 0; i < mat.size(); ++i) {
-            if (!tree->set_consecutive(mat[i])) {
-                pass = false;
-                break;
-            }
-        }
-        delete tree;
-        CPPUNIT_ASSERT_MESSAGE("Consecutive ordering example failed\n ", pass);
-    }
-
-    void testConstructExpression()//test PQnode(std::vector<int> leaves, std::list<Leaf*> &leaflist, nodetype t = pnode); adds to the leaflist correctly
-    {
-        //mock a tre from an expression and see that the output matches
-        std::string expr = "[ 5  [ 2  3  { 3 4 } ] 1  { 2  3  { 4 5 } } ]";
-        size_t expr_count = 10;
-        PQTree *tree = new PQTree(expr);
-
-        std::string message = "expected " + expr + " but found " + tree->print_expression() + "\n";
-        CPPUNIT_ASSERT_MESSAGE(message, custom::compare(expr, tree->print_expression()));
-
-        size_t count = tree->get_leaflist_size();
-        delete tree;
-
-        CPPUNIT_ASSERT_EQUAL(expr_count, count);
-    }
-
-    void testEquivalent() {
-        PQTree a("{ 3 4 5 { 6 7 8 } 9 }");
-        PQTree b("{ 3 5 4 { 6 7 8 } 9 }");
-        PQTree c("[ 3 5 4 { 6 7 8 } 9 ]");
-        PQTree d("{ 3 5 4 [ 6 7 8 ] 9 }");
-
-        PQTree e("{ 3 5 { 7 8 9 } { 6 7 8 } 9 }");
-        PQTree f("{ 3 5 { 6 7 8 } { 8 7 9 } 9 }");
-        PQTree g("{ 3 5 [ 7 8 9 ] { 6 7 8 } 9 }");
-        PQTree h("{ 3 5 { 6 7 8 } [ 8 7 9 ] 9 }");
-        PQTree i("{ 3 5 { 6 7 8 } [ 9 7 8 ] 9 }");
-
-        PQTree j("[ 9 { 6 7 8 } 4 5 3]");
-
-        CPPUNIT_ASSERT_MESSAGE("pnode reordering, should be equivalent\n", a.equivalent(b));
-        CPPUNIT_ASSERT_MESSAGE("root qnode should NOT be equivalent\n", !b.equivalent(c));
-        CPPUNIT_ASSERT_MESSAGE("descendant qnode should NOT be equivalent\n", !b.equivalent(d));
-        CPPUNIT_ASSERT_MESSAGE("pnode reordering, should be equivalent. found e: " + e.print_expression() + " and f: " + f.print_expression() + "\n", e.equivalent(f));
-        CPPUNIT_ASSERT_MESSAGE("qnode reordering, should NOT be equivalent. found g: " + g.print_expression() + " and h: " + h.print_expression() + "\n", !g.equivalent(h));
-        CPPUNIT_ASSERT_MESSAGE("qnode flip, should be equivalent. found h: " + h.print_expression() + " and i: " + i.print_expression() + "\n", h.equivalent(i));
-        CPPUNIT_ASSERT_MESSAGE("root qnode flip, should be equivalent. found c: " + c.print_expression() + " and j: " + j.print_expression() + "\n", c.equivalent(j));
-    }
-};
-
-class LeafTests : public CppUnit::TestFixture {
-    CPPUNIT_TEST_SUITE(LeafTests);
-    CPPUNIT_TEST(testLeafList);
-    CPPUNIT_TEST(test_marking);
-    CPPUNIT_TEST(test_update_depth);
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-    void testLeafList()//tests adding leaves to ensure they add to the list you pass in correctly
-    {
-        std::list<Leaf *> lfs;
-        for (int i = 0; i < 5; i++) {
-            new Leaf(i, lfs);
-        }
-        size_t count = lfs.size();
-        CPPUNIT_ASSERT_EQUAL(count, (size_t) 5);
-        for (auto it = lfs.begin(); it != lfs.end(); ++it) {
-            delete *it;
-            *it = NULL;
-        }
-        lfs.clear();
-    }
-
-    void test_marking()//tests the marking functionality of the leaf class
-    {
-        std::list<Leaf *> lfs;
-        Leaf *lf = new Leaf(1, lfs);
-        lf->mark();
-        CPPUNIT_ASSERT(lf->get_mark() == full);
-        lf->unmark();
-        CPPUNIT_ASSERT(lf->get_mark() == empty);
-        delete lf;
-    }
-
-    void test_update_depth() {
-        std::list<Leaf *> lfs;
-        PQnode *parent = new PQnode();//depth will default to zero
-        Leaf *lf = new Leaf(1, lfs);  //depth defaults to zero
-        CPPUNIT_ASSERT_EQUAL(lf->get_depth(), 0);
-        parent->link_child(lf);//this will call update depth on the leaf node
-        CPPUNIT_ASSERT_EQUAL(lf->get_depth(), 1);
-        delete parent;
-    }
-};
-
-class PQnodeTests : public CppUnit::TestFixture {
-    CPPUNIT_TEST_SUITE(PQnodeTests);
-    CPPUNIT_TEST(test_marking);
-    CPPUNIT_TEST(test_reduce_qroot);
-    CPPUNIT_TEST(test_reduce_proot);
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-    void test_marking() {
-        //mock a node with one partial child and two full and two empty
-        std::vector<int> v = {2, 2, 3, 4};
-        std::list<Leaf *> lst;
-        PQnode *root = new PQnode(v, lst); // {2, 2, 3, 4}
-        PQnode *child = new PQnode(v, lst);// {2, 2, 3, 4}
-        root->link_child(child);           // {2, 2, 3, 4 {2, 2, 3, 4} }
-
-        for (std::list<Leaf *>::iterator itr = lst.begin(); itr != lst.end(); ++itr)//mark the value = 2 children as full
-        {
-            if ((*itr)->get_value() == 2) {
-                (*itr)->mark();
-            }
-        }
-
-        child->mark();//mark the child
-        root->mark(); //mark the root
-
-        CPPUNIT_ASSERT_EQUAL(child->get_mark(), partial);
-        CPPUNIT_ASSERT_EQUAL(root->get_mark(), partial);
-
-        delete root;
-    }
-
-    void test_reduce_qroot() {
-        std::vector<int> v = {5, 2, 3, 1};
-        std::list<Leaf *> lst;
-        PQnode *root = new PQnode(v, lst);// {5, 2, 3, 1}
-        std::vector<int> vv = {2, 1, 3, 4};
-        PQnode *child = new PQnode(vv, lst);// {2, 1, 3, 4}
-        root->link_child(child);            // {5, 2, 3, 1 {2, 1, 3, 4} }
-        root->set_type(qnode);              // [5, 2, 3, 1 {2, 1, 3, 4} ]
-
-        for (std::list<Leaf *>::iterator itr = lst.begin(); itr != lst.end(); ++itr)//mark the value = 2 children as full
-        {
-            if ((*itr)->get_value() == 1) {
-                (*itr)->mark();
-            }
-        }
-
-        child->mark(); //mark the child
-        root->mark();  //mark the root
-        root->reduce();//apply the reduction
-
-        std::string expected = "[ 5  2  3  1  1  { 2  3  4 } ]";
-        std::string message = "expected [ 5  2  3  1  1  { 2  3  4 } ] but found " + root->print_expression() + "\n";
-        CPPUNIT_ASSERT_MESSAGE(message, custom::compare(expected, root->print_expression()));
-
-        delete root;
-    }
-
-    void test_reduce_proot() {
-        std::vector<int> v = {5, 2, 3, 1};
-        std::list<Leaf *> lst;
-        PQnode *root = new PQnode(v, lst);// {5, 2, 3, 1}
-        std::vector<int> vv = {2, 1, 3, 4};
-        PQnode *child = new PQnode(vv, lst);// {2, 1, 3, 4}
-        root->link_child(child);            // {5, 2, 3, 1 {2, 1, 3, 4} }
-
-        for (std::list<Leaf *>::iterator itr = lst.begin(); itr != lst.end(); ++itr)//mark the value = 2 children as full
-        {
-            if ((*itr)->get_value() == 1) {
-                (*itr)->mark();
-            }
-        }
-
-        child->mark(); //mark the child
-        root->mark();  //mark the root
-        root->reduce();//apply the reduction
-
-        std::string expected = "{ 5  2  3  [ { 2  3  4 }  1  1 ] }";
-        std::string message = "expected " + expected + " but found " + root->print_expression() + "\n";
-        CPPUNIT_ASSERT_MESSAGE(message, custom::compare(expected, root->print_expression()));
-
-        delete root;
-    }
-};
-
-int main(int argc, char **argv) {
-
-    CppUnit::TextUi::TestRunner runner;
-    runner.addTest(PQTreeTests::suite());
-    runner.addTest(PQnodeTests::suite());
-    runner.addTest(LeafTests::suite());
-    runner.run();
-
-    //PQTree tree("{ 3 4 5 [ 3 4 5 [ 3 2 1 7 ]] { 8 9 10 }}");
-    //std::cout << "the potentional gml file is \n\n" << tree.convert_to_gml() << std::endl;
-
-    return 0;
-}
diff --git a/libraries/graphSetPQ/LeafNode.cpp b/libraries/graphSetPQ/LeafNode.cpp
index b659eec..ea89ef5 100644
--- a/libraries/graphSetPQ/LeafNode.cpp
+++ b/libraries/graphSetPQ/LeafNode.cpp
@@ -1,162 +1,37 @@
-#include ".\leafnode.h"
-#include "stdafx.h"
+#include "LeafNode.h"
 
-IMPLEMENT_DYNAMIC(CLeafnode, CNode)
-
-CLeafnode::CLeafnode(CVertex *pV, int Color) {
-    iWidth = 0;
+CLeafnode::CLeafnode() {
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
-    pNode = pV;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = Color;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 
     saved_st_N = 0;
 }
 
-CLeafnode::CLeafnode(CLeafnode *pNode) {
-    // constructor for copying
-    iWidth = pNode->iWidth;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    this->pNode = pNode->pNode;
-    saved_st_N = pNode->saved_st_N;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-}
-
-CLeafnode::~CLeafnode(void) {
-    if (pNode == NULL)
-        return;
-
-    POSITION dPos = pNode->pl_S.Find(this);
-    if (dPos)
-        pNode->pl_S.RemoveAt(dPos);
-
-    pNode = NULL;
-}
-
-int CLeafnode::CalculateWidth() {
-    iWidth = LEAFWIDTH;
-
-    return iWidth;
-}
-
-int CLeafnode::CalculateLevel(int level) {
-    iLevel = level;
-
-    return iLevel;
-}
-
-void CLeafnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    char alfa[MAX_ALFA];
-
-    // If the node is pertinent, draw it blue
-    // Choose the node depending of the type of node
-    if (LABEL == FULL)
-        pDC->SetTextColor(RGB(0, 0, 255));
-    else
-        pDC->SetTextColor(RGB(0, 0, 0));
-
-    // Draw vertex st-number
-    CRect drawRect = CRect(0, 10, LEAFWIDTH, LEVELHEIGHT);
-    drawRect.OffsetRect(Offset);
-    CRect calcRect = CRect(drawRect);
-
-    if (DEBUG_PQTREE)
-        sprintf_s(alfa, "%d (%p)\nc(%d)\nl(%d)", pNode->nST, pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-    else
-        sprintf_s(alfa, "%d", saved_st_N);
-    pDC->DrawText(CString(alfa), calcRect, DT_CENTER | DT_CALCRECT);
-
-    // If the nood is the root of the pertinent subtree, draw a gray background
-    int closer = (drawRect.Width() - calcRect.Width() > 0) ? ((drawRect.Width() - calcRect.Width()) / 2) : 0;
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        CRect ellipseRect = CRect(calcRect);
-        if (ellipseRect.Height() > ellipseRect.Width())
-            ellipseRect.InflateRect((ellipseRect.Height() - ellipseRect.Width()) / 2, 0,
-                                    (ellipseRect.Height() - ellipseRect.Width()) / 2, 0);
-        ellipseRect.OffsetRect(closer, 0);
-        pDC->Ellipse(ellipseRect);
-    }
 
-    // Draw the label for this Leaf node
-    pDC->SelectStockObject(NULL_BRUSH);
-    pDC->SetBkMode(TRANSPARENT);
-    pDC->DrawText(CString(alfa), drawRect, DT_CENTER);
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = calcRect.left + closer - 5;
-        int arrowY = calcRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // Cleaning
-    pDC->SetTextColor(RGB(0, 0, 0));
-}
-
-void CLeafnode::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CLeafnode::FindLeaves(std::list<CLeafnode *> *plQueue) {
     // This is not a leaf, add it to queue
-    plQueue->AddTail(this);
+    plQueue->push_back(this);
 }
 
 void CLeafnode::UnMatch() {
     LABEL = EMPTY;
     MARK = UNMARKED;
     bRoot = false;
-    bCurrent = false;
     bInPruned = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
 }
 
-void CLeafnode::ClearPointers() {
-    if (pNode == NULL)
-        return;
-
-    saved_st_N = pNode->nST;
-    pNode = NULL;
-}
-
-void CLeafnode::GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier) {
+void CLeafnode::GetFrontier(std::list<CNode *> *pFrontier) {
     // Include this leaf in the frontier
-    pFrontier->AddTail(this);
+    pFrontier->push_back(this);
 }
 
 
@@ -167,7 +42,7 @@ CNode *CLeafnode::SearchParent(CNode *pChild) {
 
 CNode *CLeafnode::SearchPertinentLeaf(int v) {
     // Check if this leaf is pertinent
-    if (pNode->nST == v)
+    if (saved_st_N == v)
         return this;
     else
         return NULL;
@@ -177,7 +52,7 @@ int CLeafnode::CountPertinentLeaves(int v) {
     int ret = 0;
 
     // if the leaf is pertinent, count it
-    if (pNode->nST == v)
+    if (saved_st_N == v)
         ret = 1;
     else
         ret = 0;
diff --git a/libraries/graphSetPQ/LeafNode.h b/libraries/graphSetPQ/LeafNode.h
index c76e8f7..d7d5975 100644
--- a/libraries/graphSetPQ/LeafNode.h
+++ b/libraries/graphSetPQ/LeafNode.h
@@ -1,28 +1,17 @@
 #pragma once
-#include "Vertex.h"
-#include "node.h"
+#include "Node.h"
 
 class CLeafnode : public CNode {
-    DECLARE_DYNAMIC(CLeafnode)
-
 public:
-    CVertex *pNode;
     int saved_st_N;
 
 public:
-    CLeafnode(CVertex *pV, int Color);
-    CLeafnode(CLeafnode *pNode);
+    CLeafnode();
 
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
-    virtual void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    virtual void FindLeaves(std::list<CLeafnode *> *plQueue);
     virtual void UnMatch();
-    virtual void ClearPointers();
-    virtual void GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier);
+    virtual void GetFrontier(std::list<CNode *> *pFrontier);
     virtual CNode *SearchParent(CNode *pChild);
     virtual CNode *SearchPertinentLeaf(int v);
     virtual int CountPertinentLeaves(int v);
-
-    virtual ~CLeafnode(void);
 };
diff --git a/libraries/graphSetPQ/Node.cpp b/libraries/graphSetPQ/Node.cpp
index ba9682f..8be195a 100644
--- a/libraries/graphSetPQ/Node.cpp
+++ b/libraries/graphSetPQ/Node.cpp
@@ -1,20 +1,11 @@
-#include ".\node.h"
-#include "Leafnode.h"
-#include "Pnode.h"
-#include "Qnode.h"
-#include "stdafx.h"
+#include "Node.h"
 
-IMPLEMENT_DYNAMIC(CNode, CObject)
-
-CNode::~CNode(void) {
+CNode::~CNode() {
 }
 
-void CNode::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CNode::FindLeaves(std::list<CLeafnode *> *plQueue) {
     // This is not a leaf, recurse to child to keep searching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->FindLeaves(plQueue);
     }
 }
@@ -24,54 +15,32 @@ void CNode::UnMatch() {
     LABEL = EMPTY;
     MARK = UNMARKED;
     bRoot = false;
-    bCurrent = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
 
     // This is not a leaf, recurse to child to keep unmatching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->UnMatch();
     }
 }
 
-void CNode::ClearPointers() {
-    // This is not a leaf, recurse to children
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
-        pNode->ClearPointers();
-    }
-}
-
-void CNode::GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier) {
+void CNode::GetFrontier(std::list<CNode *> *pFrontier) {
     // This node is not a leaf,  recurse on the children of this node to keep searching
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         pNode->GetFrontier(pFrontier);
     }
 }
 
 CNode *CNode::SearchParent(CNode *pChild) {
     // This is not a leaf, check if one the children is pChild
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
 
+    for (CNode *pNode : pl_Children) {
         if (pNode == pChild)
             return this;
     }
 
     // We couldn't fint pChild among children, search recursively
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         CNode *pParent = pNode->SearchParent(pChild);
 
         if (pParent != NULL)
@@ -84,10 +53,7 @@ CNode *CNode::SearchParent(CNode *pChild) {
 
 CNode *CNode::SearchPertinentLeaf(int v) {
     // This is not a leaf, search recursively
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
-
+    for (CNode *pNode : pl_Children) {
         CNode *pLeaf = pNode->SearchPertinentLeaf(v);
 
         if (pLeaf != NULL)
@@ -105,9 +71,7 @@ int CNode::CountPertinentLeaves(int v) {
     int nPertinentLeaves = 0;
 
     // This is not a leaf, search recursively
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_Children.GetNext(aPos);
+    for (CNode *pNode : pl_Children) {
         nPertinentLeaves = 0;
 
         // Count pertinent leaves recursively
diff --git a/libraries/graphSetPQ/Node.h b/libraries/graphSetPQ/Node.h
index e11a012..95102f2 100644
--- a/libraries/graphSetPQ/Node.h
+++ b/libraries/graphSetPQ/Node.h
@@ -1,11 +1,25 @@
 #pragma once
 
-class CNode : public CObject {
-    DECLARE_DYNAMIC(CNode);
+#include <list>
+
+// LABEL
+const int EMPTY = 0;
+const int FULL = 1;
+const int PARTIAL = 2;
+const int SINGLY_PARTIAL = 3;
+const int DOUBLY_PARTIAL = 4;
+
+// MARK
+const int UNMARKED = 0;
+const int QUEUED = 1;
+const int BLOCKED = 2;
+const int UNBLOCKED = 3;
+
+class CLeafnode;
+
+class CNode {
 
 public:
-    int iWidth;
-    int iLevel;
     bool bVirtual;// true only for virtual node, it's used to disable destructor of virtual node
 
     // FIELDS as described in Booth and Lueker
@@ -13,34 +27,21 @@ public:
     int MARK; // this is UNMARKED, QUEUED, BLOCKED or UNBLOCKED
     int PERTINENT_CHILD_COUNT;
     int PERTINENT_LEAF_COUNT;
-    bool bCurrent; // true for the current node being matched (to display an arrow in PQtree view)
     bool bRoot;    // true if the current node is the root of the pertinent subtree
     bool bInPruned;// true if this node is part of the pruned pertinent subtree
 
-    // For simultaneous embedding
-    int EdgeColor;
-
 public:
-    CTypedPtrList<CObList, CNode *> pl_Children;
+    std::list<CNode *> pl_Children;
     CNode *pParent;
     CNode *pLeftSibling;
     CNode *pRightSibling;
 
-    CNode *pOriginalNode;  // This pointers are to display the address of the original node
-    CNode *pOriginalParent;// from which a copy for PQTreeView was made, should not be used
-    CNode *pOriginalLeft;  // to deference the node.
-    CNode *pOriginalRight;
-
 public:
-    CNode(void){};
+    CNode(){};
     CNode(CNode *pNode){};
-    virtual int CalculateWidth() { return 0; };
-    virtual int CalculateLevel(int level) { return level; };
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets){};
-    virtual void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    virtual void FindLeaves(std::list<CLeafnode *> *plQueue);
     virtual void UnMatch();
-    virtual void ClearPointers();
-    virtual void GetFrontier(CTypedPtrList<CObList, CNode *> *pFrontier);
+    virtual void GetFrontier(std::list<CNode *> *pFrontier);
     virtual CNode *SearchParent(CNode *pChild);
     virtual CNode *SearchPertinentLeaf(int v);
     virtual int CountPertinentLeaves(int v);
diff --git a/libraries/graphSetPQ/PQtree.cpp b/libraries/graphSetPQ/PQtree.cpp
index 37bbb15..715f47d 100644
--- a/libraries/graphSetPQ/PQtree.cpp
+++ b/libraries/graphSetPQ/PQtree.cpp
@@ -1,74 +1,38 @@
 #include "PQtree.h"
-#include "GraphToolDoc.h"
-#include "Leafnode.h"
+#include "LeafNode.h"
 #include "Pnode.h"
 #include "Qnode.h"
-#include "stdafx.h"
+#include <algorithm>
+#include <queue>
+#include <variant>
 
-IMPLEMENT_DYNAMIC(CPQtree, CObject)
-
-CPQtree::CPQtree(CDocument *pDoc, CVertex *pStart) {
+CPQtree::CPQtree(int numLeaves) {
     // This constructor creates the tree with a first P-Node with its virtual edges
     // new nodes are added to pl_S
-    CPnode *pPnode = new CPnode(pStart, BLACK);
+    CPnode *pPnode = new CPnode();
 
     // root is the unique P-node
     pRoot = (CNode *) pPnode;
 
     // initialize variables
-    iLevels = 0;
-    iWidth = 0;
-    pVirtual = NULL;
-    pLastPertinentRoot = NULL;
-    bSets = false;
-
-    // set document
-    this->pDoc = pDoc;
-}
-
-CPQtree::CPQtree(CDocument *pDoc, CNode *pNode) {
-    // Root is the node given
-    pRoot = pNode;
-
-    // initialize variables
-    iLevels = 0;
-    iWidth = 0;
     pVirtual = NULL;
     pLastPertinentRoot = NULL;
     bSets = false;
 
-    // set document
-    this->pDoc = pDoc;
-}
-
+    for (int i = 0; i < numLeaves; i++) {
+        CLeafnode *newLeaf = new CLeafnode;
+        pPnode->pl_Children.push_back(newLeaf);
+        newLeaf->pParent = pRoot;
 
-CPQtree::CPQtree(CPQtree *pqTree) {
-    if (pqTree->pRoot != NULL) {
-        // This constructor creates a copy of the provided pqTree
-        if (pqTree->pRoot->IsKindOf(RUNTIME_CLASS(CPnode)))
-            pRoot = new CPnode((CPnode *) pqTree->pRoot);
-
-        else if (pqTree->pRoot->IsKindOf(RUNTIME_CLASS(CQnode)))
-            pRoot = new CQnode((CQnode *) pqTree->pRoot);
-
-        else
-            pRoot = new CLeafnode((CLeafnode *) pqTree->pRoot);
-    } else {
-        pRoot = NULL;
+        if (i != 0) {
+            pPnode->pl_Children.back()->pRightSibling = newLeaf;
+            newLeaf->pLeftSibling = pPnode->pl_Children.back();
+        }
     }
-
-    iLevels = pqTree->iLevels;
-    iWidth = pqTree->iWidth;
-    iHeight = pqTree->iHeight;
-    pVirtual = NULL;
-    pLastPertinentRoot = NULL;
-    bSets = false;
-
-    pDoc = pqTree->pDoc;
-    ClearPointers();
 }
 
-CPQtree::~CPQtree(void) {
+
+CPQtree::~CPQtree() {
     if (pRoot != NULL)
         delete pRoot;
 
@@ -91,31 +55,7 @@ void CPQtree::CountPertinentNodes(int v) {
     }
 }
 
-CRect CPQtree::Draw(CDC *pDC, CPoint Offset) {
-    if (pRoot == NULL)
-        return CRect(0, 0, 0, 0);
-
-    // Draw info message
-    CRect calcRect = CRect(0, 0, PQTREE_TEXTH, PQTREE_TEXTV);
-    pDC->SetTextColor(RGB(0, 0, 0));
-    calcRect.OffsetRect(Offset);
-    pDC->DrawText(sComment, calcRect, DT_SINGLELINE);
-
-    // Calculate nodes width (in pixels) and tree height (in # levels)
-    iWidth = pRoot->CalculateWidth();
-    iLevels = pRoot->CalculateLevel(1);
-
-    // Draw the tree beginning in the root
-    Offset.y += 30;
-    pRoot->Draw(pDC, Offset, bSets);
-
-    iHeight = LEVELHEIGHT * (iLevels + 1);
-
-    CRect size(0, 0, iWidth, iHeight);
-    return size;
-}
-
-void CPQtree::FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue) {
+void CPQtree::FindLeaves(std::list<CLeafnode *> *plQueue) {
     pRoot->FindLeaves(plQueue);
 }
 
@@ -123,399 +63,106 @@ void CPQtree::SetAllUnmatched() {
     pRoot->UnMatch();
 }
 
-void CPQtree::ClearPointers() {
-    if (pRoot != NULL)
-        pRoot->ClearPointers();
-}
-
-bool CPQtree::ArePertinentConsecutive(int v) {
-    // Get Frontier
-    CTypedPtrList<CObList, CNode *> Frontier;
-    pRoot->GetFrontier(&Frontier);
-
-    // Now check if pertinent leaves are consecutive
-    int State = 0;// little automata: 0 before pertinent nodes
-                  //					1 in pertinent nodes
-                  //					2 after pertinent nodes
-                  //					3 error
-    POSITION aPos = Frontier.GetHeadPosition();
-    while (aPos && State != 3) {
-        CLeafnode *pLeaf = (CLeafnode *) Frontier.GetNext(aPos);
-
-        switch (State) {
-            case 0: {
-                if (pLeaf->pNode->nST == v)// Begin of pertinent leaves
-                    State = 1;
-                break;
-            }
-            case 1: {
-                if (pLeaf->pNode->nST != v)// End of pertinent leaves
-                    State = 2;
-                break;
-            }
-            case 2: {
-                if (pLeaf->pNode->nST == v)// Pertinent leaf again?... error
-                    State = 3;
-                break;
-            }
-        }
-    }
-
-    if (State != 3)
-        return true;
-    else
-        return false;
-}
-
-void CPQtree::VertexAddition(CVertex *pV, CVertex *pU) {
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
-    TRACE("\nVertex addition over vertex %d\n", pV->nST);
-    CNode *pSavedLeftSibling = NULL;
-    CNode *pSavedRightSibling = NULL;
-
-    CNode *pParent;
-    bool bFullNode;
-    if (pLastPertinentRoot->LABEL == FULL) {
-        pParent = pLastPertinentRoot->pParent;
-        bFullNode = true;
-    } else {
-        pParent = pLastPertinentRoot;
-        bFullNode = false;
-    }
-
-    // Prune pertinent subtree and store the position
-    CNode *pSavedPrev = NULL;
-    bool bBlue = false;
-    bool bRed = false;
-    bool bBlack = false;
-    if (pParent != NULL) {
-        POSITION aPos = pParent->pl_Children.GetHeadPosition();
-        POSITION prevPos;
-        while (aPos) {
-            // Get next node on the list
-            prevPos = aPos;
-            CNode *pNode = pParent->pl_Children.GetNext(aPos);
-
-            // remove pertinent nodes
-            if (pNode->LABEL == FULL) {
-                if (pNode->EdgeColor == BLUE)
-                    bBlue = true;
-                else if (pNode->EdgeColor == RED)
-                    bRed = true;
-                else
-                    bBlack = true;
-
-                // remove this pertinent node
-                if (pNode->pLeftSibling != NULL)
-                    pNode->pLeftSibling->pRightSibling = pNode->pRightSibling;
-                if (pNode->pRightSibling != NULL)
-                    pNode->pRightSibling->pLeftSibling = pNode->pLeftSibling;
-
-                pSavedLeftSibling = pNode->pLeftSibling;
-                pSavedRightSibling = pNode->pRightSibling;
-
-                delete pNode;
-                pParent->pl_Children.RemoveAt(prevPos);
-            }
-        }
-    } else {
-        // the node itself is the pertinent subtree, delete it
-        if (pLastPertinentRoot == pRoot)
-            pRoot = NULL;
-        delete pLastPertinentRoot;
-        pLastPertinentRoot = NULL;
-    }
-
-    // Create a new P-node with all neighbors of v
-    int newColor;
-    if ((bBlue && bRed) || (bBlack))
-        newColor = BLACK;
-    else if (bBlue)
-        newColor = BLUE;
-    else
-        newColor = RED;
-    CPnode *pPnode = new CPnode(pV, newColor);
-
-    // Insert the new cut vertex on saved position
-    if (pPnode->pl_Children.GetCount() == 0) {
-        // nothing to insert;
-        delete pPnode;
-        pPnode = NULL;
-    } else {
-        if (pParent == NULL) {
-            // no place to insert
-            pRoot = pPnode;
-            pPnode->pParent = NULL;
-            pPnode->pLeftSibling = NULL;
-            pPnode->pRightSibling = NULL;
-        } else {
-            // Normal case
-            if (pSavedLeftSibling != NULL) {
-                POSITION insertPos = pParent->pl_Children.Find(pSavedLeftSibling);
-                pParent->pl_Children.InsertAfter(insertPos, pPnode);
-            } else {
-                pParent->pl_Children.AddHead(pPnode);
-            }
-            pPnode->pParent = pParent;
-            pPnode->pLeftSibling = pSavedLeftSibling;
-            pPnode->pRightSibling = pSavedRightSibling;
-            if (pPnode->pLeftSibling != NULL)
-                pPnode->pLeftSibling->pRightSibling = pPnode;
-            if (pPnode->pRightSibling != NULL)
-                pPnode->pRightSibling->pLeftSibling = pPnode;
-        }
-    }
-
-    // Check for special cases: an improper tree may be produced...
-
-    // The new P-node is empty
-    if (pPnode == NULL)
-        return;
-
-    // The new P-node contains only one child
-    if (pPnode->pl_Children.GetCount() == 1) {
-        // Do the insertion
-        if (pPnode->pParent == NULL) {
-            // pNode is now the root, no insertion needed
-            CNode *pChild = pPnode->pl_Children.GetHead();
-            pRoot = pChild;
-            pChild->pParent = NULL;
-            pChild->pLeftSibling = NULL;
-            pChild->pRightSibling = NULL;
-        } else {
-            // have to insert pNode on its GrandFather
-            CNode *pGrandFather = pPnode->pParent;
-            CNode *pChild = pPnode->pl_Children.GetHead();
-            if (pPnode->pLeftSibling != NULL) {
-                POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-                pGrandFather->pl_Children.InsertAfter(insertPos, pChild);
-            } else {
-                pGrandFather->pl_Children.AddHead(pChild);
-            }
-            pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
-            pChild->pParent = pGrandFather;
-            pChild->pLeftSibling = pPnode->pLeftSibling;
-            pChild->pRightSibling = pPnode->pRightSibling;
-            if (pPnode->pLeftSibling != NULL)
-                pPnode->pLeftSibling->pRightSibling = pChild;
-            if (pPnode->pRightSibling != NULL)
-                pPnode->pRightSibling->pLeftSibling = pChild;
-        }
-
-        pPnode->pl_Children.RemoveAll();
-        delete pPnode;
-    }
-
-    // A parent node with just one child
-    if (pParent != NULL) {
-        if (pParent->pl_Children.GetCount() == 1) {
-            CNode *pChild = pParent->pl_Children.GetHead();
-
-            // Do the insertion
-            if (pParent->pParent == NULL) {
-                // pChild is now the root, no insertion needed
-                pRoot = pChild;
-                pChild->pParent = NULL;
-            } else {
-                // have to insert pNode on its GrandFather
-                CNode *pGrandFather = pParent->pParent;
-                if (pParent->pLeftSibling != NULL) {
-                    POSITION insertPos = pGrandFather->pl_Children.Find(pParent->pLeftSibling);
-                    pGrandFather->pl_Children.InsertAfter(insertPos, pChild);
-                } else {
-                    pGrandFather->pl_Children.AddHead(pChild);
-                }
-                pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pParent));
-                pChild->pParent = pGrandFather;
-                pChild->pLeftSibling = pParent->pLeftSibling;
-                pChild->pRightSibling = pParent->pRightSibling;
-                if (pParent->pLeftSibling != NULL)
-                    pParent->pLeftSibling->pRightSibling = pChild;
-                if (pParent->pRightSibling != NULL)
-                    pParent->pRightSibling->pLeftSibling = pChild;
-            }
-
-            pParent->pl_Children.RemoveAll();
-            delete pParent;
-            pParent = NULL;
-        }
-    }
-
-    // A Q-node with less than 3 children
-    if (pParent != NULL) {
-        if (pParent->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            // If after removing pertinent subtree, parent node is a Q-node with <3 children... fix it
-            if (pParent->pl_Children.GetCount() == 2) {
-                // A Q-node with 2 children is actually a P-node
-                CNode *pNewPnode = new CPnode();
-
-                if (pParent->pParent == NULL) {
-                    // No insertion needed, since pParent was root of pqTree, now pNewPnode is the new root
-                    pRoot = pNewPnode;
-                } else {
-                    // Find the position of the Q-node
-                    POSITION aPos = pParent->pParent->pl_Children.Find(pParent);
-
-                    // insert new P-node in the place of Q-node
-                    pParent->pParent->pl_Children.InsertAfter(aPos, pNewPnode);
-                    pNewPnode->pParent = pParent->pParent;
-                    pNewPnode->pLeftSibling = pParent->pLeftSibling;
-                    pNewPnode->pRightSibling = pParent->pRightSibling;
-                    if (pNewPnode->pLeftSibling != NULL)
-                        pNewPnode->pLeftSibling->pRightSibling = pNewPnode;
-                    if (pNewPnode->pRightSibling != NULL)
-                        pNewPnode->pRightSibling->pLeftSibling = pNewPnode;
-
-                    // remove link to Q-node from parent
-                    pParent->pParent->pl_Children.RemoveAt(aPos);
-                }
-
-                // copy the children of Q-node into the new P-node
-                CNode *pChild1 = pParent->pl_Children.GetHead();
-                CNode *pChild2 = pParent->pl_Children.GetTail();
-                pNewPnode->pl_Children.AddTail(pChild1);
-                pNewPnode->pl_Children.AddTail(pChild2);
-                pChild1->pParent = pNewPnode;
-                pChild2->pParent = pNewPnode;
-                pChild1->pRightSibling = pChild2;
-                pChild2->pRightSibling = NULL;
-                pChild2->pLeftSibling = pChild1;
-                pChild1->pLeftSibling = NULL;
-
-                // remove unnecessary Q-node
-                pParent->pl_Children.RemoveAll();
-                delete pParent;
-            }
-        }
-    }
-}
-
-void CPQtree::CopyFullChildren(CVertex *pU, CNode *pNode) {
-    if (pNode->IsKindOf(RUNTIME_CLASS(CLeafnode)) && pNode->LABEL == FULL) {
-        CLeafnode *pChLeaf = (CLeafnode *) pNode;
-        pU->pl_Outlist.AddHead(pChLeaf->pNode);
-    } else {
-        POSITION chPos = pNode->pl_Children.GetHeadPosition();
-        while (chPos) {
-            CNode *pChNode = pNode->pl_Children.GetNext(chPos);
-            CopyFullChildren(pU, pChNode);
-        }
-    }
-}
-
-bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
-    CTypedPtrList<CObList, CNode *> pl_Blocked;
-    QUEUE.RemoveAll();
+bool CPQtree::Bubble(std::list<CLeafnode *> *pl_S) {
+    std::list<CNode *> pl_Blocked;
+    QUEUE.clear();
     BLOCK_COUNT = 0;
     BLOCKED_NODES = 0;
     OFF_THE_TOP = 0;
 
     // for X e S do place X onto QUEUE
-    POSITION aPos = pl_S->GetHeadPosition();
-    while (aPos) {
-        CNode *pNode = pl_S->GetNext(aPos);
-        QUEUE.AddTail(pNode);
+    for (CNode *pNode : *pl_S) {
+        QUEUE.push_back(pNode);
     }
 
-    while (QUEUE.GetCount() + BLOCK_COUNT + OFF_THE_TOP > 1) {
-        if (QUEUE.GetCount() == 0) {
+    while (QUEUE.size() + BLOCK_COUNT + OFF_THE_TOP > 1) {
+        if (QUEUE.empty()) {
             return false;
         }
 
         // remove X from the front of the QUEUE
-        CNode *pX = QUEUE.GetHead();
-        QUEUE.RemoveHead();
+        CNode *pX = QUEUE.front();
+        QUEUE.pop_front();
 
         // mark X blocked
         pX->MARK = BLOCKED;
-        pl_Blocked.AddTail(pX);
+        pl_Blocked.push_back(pX);
 
         // BS = {Y e INMEDIATE_SIBLINGS(X), MARK(Y)="blocked"}
         // US = {Y e INMEDIATE_SIBLINGS(X), MARK(Y)="blocked"}
-        CTypedPtrList<CObList, CNode *> pl_BS;
-        CTypedPtrList<CObList, CNode *> pl_US;
+        std::list<CNode *> pl_BS;
+        std::list<CNode *> pl_US;
 
         // Add left sibling to the proper list
         if (pX->pLeftSibling != NULL) {
             if (pX->pLeftSibling->MARK == BLOCKED)
-                pl_BS.AddTail(pX->pLeftSibling);
+                pl_BS.push_back(pX->pLeftSibling);
             else if (pX->pLeftSibling->MARK == UNBLOCKED)
-                pl_US.AddTail(pX->pLeftSibling);
+                pl_US.push_back(pX->pLeftSibling);
         }
 
         // Add right sibling to the proper list
         if (pX->pRightSibling != NULL) {
             if (pX->pRightSibling->MARK == BLOCKED)
-                pl_BS.AddTail(pX->pRightSibling);
+                pl_BS.push_back(pX->pRightSibling);
             else if (pX->pRightSibling->MARK == UNBLOCKED)
-                pl_US.AddTail(pX->pRightSibling);
+                pl_US.push_back(pX->pRightSibling);
         }
 
-        if (pl_US.GetCount() > 0) {
+        if (!pl_US.empty()) {
             // choose any Y e US
-            CNode *pY = pl_US.GetHead();
+            CNode *pY = pl_US.front();
 
             pX->pParent = pY->pParent;
             pX->MARK = UNBLOCKED;
         } else if (pX->pLeftSibling == NULL || pX->pRightSibling == NULL)// |SIBLINGS| < 2
         {
             pX->MARK = UNBLOCKED;
-            pl_Blocked.RemoveAt(pl_Blocked.Find(pX));
+            pl_Blocked.remove(pX);
         } else {
             // Deviation from paper algorithm, if the parent node is a P-node
             // then unblock the node
             if (pX->pParent != NULL) {
-                if (pX->pParent->IsKindOf(RUNTIME_CLASS(CPnode))) {
+                if (dynamic_cast<CPnode *>(pX->pParent)) {
                     pX->MARK = UNBLOCKED;
-                    pl_Blocked.RemoveAt(pl_Blocked.Find(pX));
+                    pl_Blocked.remove(pX);
                 }
             }
         }
 
         if (pX->MARK == UNBLOCKED) {
             // LIST := the maximal consecutive set of blocked siblings adjacent to X
-            CTypedPtrList<CObList, CNode *> pl_LIST, pl_LIST_R, pl_LIST_L;
+            std::list<CNode *> pl_LIST, pl_LIST_R, pl_LIST_L;
 
             CNode *pY = pX->pParent;
 
-            if (pl_BS.GetCount() > 0) {
+            if (!pl_BS.empty()) {
                 // search blocked nodes to the right
                 CNode *pPrev = pX->pLeftSibling;
                 while (pPrev != NULL && pPrev->MARK == BLOCKED) {
-                    pl_LIST_L.AddTail(pPrev);
+                    pl_LIST_L.push_back(pPrev);
                     pPrev = pPrev->pLeftSibling;
                 }
 
                 // search blocked nodes to the right
                 CNode *pNext = pX->pRightSibling;
                 while (pNext != NULL && pNext->MARK == BLOCKED) {
-                    pl_LIST_R.AddTail(pNext);
+                    pl_LIST_R.push_back(pNext);
                     pNext = pNext->pRightSibling;
                 }
 
                 // copy the list of maximum size
-                if (pl_LIST_R.GetCount() > pl_LIST_L.GetCount()) {
-                    POSITION lPos = pl_LIST_R.GetHeadPosition();
-                    while (lPos) {
-                        CNode *pCopy = pl_LIST_R.GetNext(lPos);
-                        pl_LIST.AddTail(pCopy);
+                if (pl_LIST_R.size() > pl_LIST_L.size()) {
+                    for (CNode *pCopy : pl_LIST_R) {
+                        pl_LIST.push_back(pCopy);
                     }
                 } else {
-                    POSITION lPos = pl_LIST_L.GetHeadPosition();
-                    while (lPos) {
-                        CNode *pCopy = pl_LIST_L.GetNext(lPos);
-                        pl_LIST.AddTail(pCopy);
+                    for (CNode *pCopy : pl_LIST_L) {
+                        pl_LIST.push_back(pCopy);
                     }
                 }
 
-                // for Z e LIST do
-                POSITION zPos = pl_LIST.GetHeadPosition();
-                while (zPos) {
-                    CNode *pZ = pl_LIST.GetNext(zPos);
-
+                for (CNode *pZ : pl_LIST) {
                     pZ->MARK = UNBLOCKED;
                     pZ->pParent = pY;
                     pZ->PERTINENT_CHILD_COUNT += 1;
@@ -528,15 +175,15 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
             } else {
                 pY->PERTINENT_CHILD_COUNT += 1;
                 if (pY->MARK == UNMARKED) {
-                    QUEUE.AddTail(pY);
+                    QUEUE.push_back(pY);
                     pY->MARK = QUEUED;
                 }
             }
 
-            BLOCK_COUNT = BLOCK_COUNT - (int) pl_BS.GetCount();
-            BLOCKED_NODES = BLOCKED_NODES - (int) pl_LIST.GetCount();
+            BLOCK_COUNT = BLOCK_COUNT - (int) pl_BS.size();
+            BLOCKED_NODES = BLOCKED_NODES - (int) pl_LIST.size();
         } else {
-            BLOCK_COUNT = BLOCK_COUNT + 1 - (int) pl_BS.GetCount();
+            BLOCK_COUNT = BLOCK_COUNT + 1 - (int) pl_BS.size();
             BLOCKED_NODES = BLOCKED_NODES += 1;
         }
     }
@@ -546,7 +193,7 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
 	{
 		if (pVirtual!=NULL)
 		{
-			pVirtual->pl_Children.RemoveAll();
+			pVirtual->pl_Children.clear();
 			delete pVirtual;
 		}
 		pVirtual = new CQnode();
@@ -580,35 +227,44 @@ bool CPQtree::Bubble(CTypedPtrList<CObList, CNode *> *pl_S) {
     return true;
 }
 
-bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
+void CPQtree::prepareReduction(std::list<CLeafnode *> *pl_S, int v) {
+    if (pl_S->size() <= 1) {
+        return;
+    }
+
+    for (CLeafnode *leaf : *pl_S) {
+        leaf->saved_st_N = v;
+    }
+
+    CountPertinentNodes(v);
+}
+
+bool CPQtree::Reduce(std::list<CLeafnode *> *pl_S, int v) {
+    if (pl_S->size() <= 1) {
+        return true;
+    }
+
     int nCount = 0;
     // Initialize queue to empty
-    QUEUE.RemoveAll();
+    QUEUE.clear();
 
     // for X e S do place X onto QUEUE
-    POSITION aPos = pl_S->GetHeadPosition();
-    TRACE("\n\nDisplaying set for %d: S = {", v);
-    while (aPos) {
-        CNode *pX = pl_S->GetNext(aPos);
-        QUEUE.AddTail(pX);
+    for (CNode *pX : *pl_S) {
+        QUEUE.push_back(pX);
         pX->PERTINENT_LEAF_COUNT = 1;
         nCount++;
-        if (aPos)
-            TRACE("%p, ", pX);
-        else
-            TRACE("%p} and the total is %d", pX, nCount);
     }
 
     // Safety for first match
     pLastPertinentRoot = pRoot;
 
-    while (QUEUE.GetCount() > 0) {
+    while (!QUEUE.empty()) {
         // remove X from the front of the QUEUE
-        CNode *pX = QUEUE.GetTail();
-        QUEUE.RemoveTail();
+        CNode *pX = QUEUE.back();
+        QUEUE.pop_back();
         CountNodeTypes(pX);
 
-        if ((pX->PERTINENT_LEAF_COUNT) < (pl_S->GetCount())) {
+        if ((pX->PERTINENT_LEAF_COUNT) < (pl_S->size())) {
             // By the way... X is not the ROOT(T, S)
             CNode *pY = pX->pParent;
 
@@ -616,7 +272,7 @@ bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
 
             if (pY->PERTINENT_CHILD_COUNT == 0) {
                 // place Y onto QUEUE
-                QUEUE.AddHead(pY);
+                QUEUE.push_front(pY);
             }
 
             // try to apply templates for X not being the ROOT(T, S)
@@ -647,56 +303,30 @@ bool CPQtree::Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v) {
     return true;
 }
 
-bool CPQtree::Template_L1(CNode *pX, bool bRoot, int v, CString sText) {
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
-    if (!pX->IsKindOf(RUNTIME_CLASS(CLeafnode)))
+bool CPQtree::Template_L1(CNode *pX, bool bRoot, int v) {
+    if (!dynamic_cast<CLeafnode *>(pX))
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN L1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template L1\n");
     CLeafnode *pLeafnode = (CLeafnode *) pX;
 
     // Pertinent leaves are marked full, or empty otherwise
-    if (pLeafnode->pNode->nST == v)
+    if (pLeafnode->saved_st_N == v)
         pLeafnode->LABEL = FULL;
     else
         pLeafnode->LABEL = EMPTY;
 
 
-    // Save PQ-tree for later viewing
-    pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pX->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN L1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_P1(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P1(CNode *pX, bool bRoot) {
     // The pattern is with X being a P-node and all children full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -705,41 +335,15 @@ bool CPQtree::Template_P1(CNode *pX, bool bRoot, CString sText) {
     if (mFull != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P1\n");
     pX->LABEL = FULL;
 
-    // Save PQ-tree for later viewing
     pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
-    // Pattern is with pX root of pertinent subtree and all children are either full or empty)
-    TRACE("\nTrying P2...\n");
-
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
+bool CPQtree::Template_P2(CNode *pX, bool bRoot) {
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -752,32 +356,18 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
     if (mFull + mEmpty != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree = new CPQtree(this);
     pX->bRoot = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P2 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P2\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
 
     // Move all full children to the new P node
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos;
+    auto it = pPnode->pl_Children.begin();
     CNode *pPrevFullNode = NULL;
-    while (aPos) {
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -792,10 +382,10 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
                     pTempNode->pLeftSibling->pRightSibling = pTempNode->pRightSibling;
                 if (pTempNode->pRightSibling != NULL)
                     pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
-                pPnode->pl_Children.RemoveAt(prevPos);
+                pPnode->pl_Children.erase(std::prev(it));
             } else {
                 // Add the node to the new P-node
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes on the previous position
@@ -803,7 +393,7 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
                     pTempNode->pLeftSibling->pRightSibling = pTempNode->pRightSibling;
                 if (pTempNode->pRightSibling != NULL)
                     pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
-                pPnode->pl_Children.RemoveAt(prevPos);
+                pPnode->pl_Children.erase(std::prev(it));
 
                 // update the linked list of nodes in the new position
                 pTempNode->pLeftSibling = pPrevFullNode;
@@ -817,37 +407,26 @@ bool CPQtree::Template_P2(CNode *pX, bool bRoot, CString sText) {
 
     // Add full subtree to the current node
     pNewFullPnode->pParent = pX;
-    CNode *pLeft = pX->pl_Children.GetTail();
+    CNode *pLeft = pX->pl_Children.back();
     if (pLeft != NULL)
         pLeft->pRightSibling = pNewFullPnode;
     pNewFullPnode->pLeftSibling = pLeft;
     pNewFullPnode->pRightSibling = NULL;
-    pPnode->pl_Children.AddTail(pNewFullPnode);
+    pPnode->pl_Children.push_back(pNewFullPnode);
 
     // Label the replacement tree
     pNewFullPnode->LABEL = FULL;
     pNewFullPnode->bRoot = true;
     pLastPertinentRoot = pNewFullPnode;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P2");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P3(CNode *pX, bool bRoot) {
     // Pattern is with pX NOT root of pertinent subtree and all children are either full or empty)
-    TRACE("\nTrying P3...\n");
-
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -860,32 +439,16 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
     if (mFull + mEmpty != mTotal)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P3 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P3\n");
-
     // Create a new Q-node and two P-nodes for full and empty subtrees
     CQnode *pNewQnode = new CQnode();
     CNode *pNewFullPnode = new CPnode();
     CNode *pNewEmptyPnode = new CPnode();
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    for (CNode *pTempNode : pPnode->pl_Children) {
         // Get next node on the list
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -900,7 +463,7 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -916,7 +479,7 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
                 delete pNewEmptyPnode;// we don't need a P-node for just one element
                 pNewEmptyPnode = pTempNode;
             } else {
-                pNewEmptyPnode->pl_Children.AddTail(pTempNode);
+                pNewEmptyPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewEmptyPnode;
 
                 // update the linked list of nodes
@@ -931,12 +494,12 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
 
     // Find the parent of current node
     CNode *pParent = pPnode->pParent;
-    POSITION savedPos;
+    std::list<CNode *>::iterator savedPos;
 
     // Insert the new Q-node
     if (pParent != NULL) {
-        savedPos = pParent->pl_Children.Find(pPnode);
-        pParent->pl_Children.InsertAfter(savedPos, pNewQnode);
+        savedPos = std::find(pParent->pl_Children.begin(), pParent->pl_Children.end(), pPnode);
+        pParent->pl_Children.insert(std::next(savedPos), pNewQnode);
     } else {
         // if there is no parent, then the node we are replacing was the root of the pqTree
         pRoot = pNewQnode;
@@ -952,14 +515,14 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
 
     // Remove previous P-node
     if (pParent != NULL)
-        pParent->pl_Children.RemoveAt(savedPos);
-    pPnode->pl_Children.RemoveAll();
+        pParent->pl_Children.erase(savedPos);
+    pPnode->pl_Children.clear();
     delete pPnode;
     pPnode = NULL;
 
     // Add subtrees to new Q-node
-    pNewQnode->pl_Children.AddTail(pNewEmptyPnode);
-    pNewQnode->pl_Children.AddTail(pNewFullPnode);
+    pNewQnode->pl_Children.push_back(pNewEmptyPnode);
+    pNewQnode->pl_Children.push_back(pNewFullPnode);
     pNewEmptyPnode->pParent = pNewQnode;
     pNewFullPnode->pParent = pNewQnode;
     pNewEmptyPnode->pLeftSibling = NULL;
@@ -977,27 +540,17 @@ bool CPQtree::Template_P3(CNode *pX, bool bRoot, CString sText) {
     //       there is at least one pertinent leaf which is not descendant of this
     //       Q-node, so this new children will be added. (maybe)
 
-    // Save PQ-tree for later viewing
-    pNewQnode->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pNewQnode->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P3");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P4(CNode *pX, bool bRoot) {
     // Pattern is with pX root of pertinent subtree and exactly one partial child, rest of children doesn't matter)
-    TRACE("\nTrying P4...\n");
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1006,33 +559,19 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
     if (mPartial != 1)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P4 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P4\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
     CNode *pPartial = NULL;
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -1048,7 +587,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -1060,7 +599,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
         } else if (pTempNode->LABEL == PARTIAL || pTempNode->LABEL == SINGLY_PARTIAL || pTempNode->LABEL == DOUBLY_PARTIAL) {
             // Find the Q-node (partial)
             pPartial = pTempNode;
@@ -1073,7 +612,7 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
         delete pNewFullPnode;
     } else {
         // Check if p-node will have only one child, and fix it
-        if (pPnode->pl_Children.GetCount() == 1) {
+        if (pPnode->pl_Children.size() == 1) {
             // p-node is the roor of the pqTree?
             if (pRoot == pPnode) {
                 // we don't need to insert anything, just make this node root of pqTree
@@ -1084,13 +623,13 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             } else {
                 // Before removing the p-node, insert the q-node in the parent of the p-node
                 CNode *pGrandFather = pPnode->pParent;
-                pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+                pGrandFather->pl_Children.remove(pPnode);
                 if (pPnode->pLeftSibling != NULL)
                     pPnode->pLeftSibling->pRightSibling = pPnode->pRightSibling;
                 if (pPnode->pRightSibling != NULL)
                     pPnode->pRightSibling->pLeftSibling = pPnode->pLeftSibling;
-                CNode *pUncle = pGrandFather->pl_Children.GetTail();
-                pGrandFather->pl_Children.AddTail(pPartial);
+                CNode *pUncle = pGrandFather->pl_Children.back();
+                pGrandFather->pl_Children.push_back(pPartial);
                 pPartial->pParent = pGrandFather;
                 pPartial->pLeftSibling = pUncle;
                 pPartial->pRightSibling = NULL;
@@ -1099,15 +638,15 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
             }
 
             // Now remove the p-node, otherwise will produce a linnear chain of nodes
-            pPnode->pl_Children.RemoveAll();
+            pPnode->pl_Children.clear();
             delete pPnode;
         } else {
             pPnode->LABEL = PARTIAL;
         }
 
         // Add full subtree to q-node
-        CNode *pLeft = pPartial->pl_Children.GetTail();
-        pPartial->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial->pl_Children.back();
+        pPartial->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial;
         pNewFullPnode->pLeftSibling = pLeft;
         pNewFullPnode->pRightSibling = NULL;
@@ -1121,24 +660,14 @@ bool CPQtree::Template_P4(CNode *pX, bool bRoot, CString sText) {
     pPartial->bRoot = true;
     pLastPertinentRoot = pPartial;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P4");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P5(CNode *pX, bool bRoot) {
     // Pattern is with pX NOT root of pertinent subtree and exactly one partial child
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1147,34 +676,19 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     if (mPartial != 1)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P5 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P5\n");
-
     // Create a new P-node for full subtree and one for empty subtree
     CNode *pNewFullPnode = new CPnode();
     CNode *pNewEmptyPnode = new CPnode();
     CNode *pPartial = NULL;
 
     // Move all full children to the new P nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
     CNode *pPrevEmptyNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // Check if we are going to move this subtree
         if (pTempNode->LABEL == FULL || pTempNode->LABEL == EMPTY) {
@@ -1192,7 +706,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
                     delete pNewFullPnode;
                     pNewFullPnode = pTempNode;
                 } else {
-                    pNewFullPnode->pl_Children.AddTail(pTempNode);
+                    pNewFullPnode->pl_Children.push_back(pTempNode);
                     pTempNode->pParent = pNewFullPnode;
 
                     // update the linked list of nodes
@@ -1210,7 +724,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
                     delete pNewEmptyPnode;
                     pNewEmptyPnode = pTempNode;
                 } else {
-                    pNewEmptyPnode->pl_Children.AddTail(pTempNode);
+                    pNewEmptyPnode->pl_Children.push_back(pTempNode);
                     pTempNode->pParent = pNewEmptyPnode;
 
                     // update the linked list of nodes
@@ -1223,7 +737,7 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
 
         } else if (pTempNode->LABEL == PARTIAL || pTempNode->LABEL == SINGLY_PARTIAL || pTempNode->LABEL == DOUBLY_PARTIAL) {
             // Find the Q-node (partial)
@@ -1240,12 +754,12 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
         // Before removing the p-node, insert the q-node in the parent of the p-node
         CNode *pGrandFather = pPnode->pParent;
         if (pPnode->pLeftSibling != NULL) {
-            POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-            pGrandFather->pl_Children.InsertAfter(insertPos, pPartial);
+            auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pPnode->pLeftSibling);
+            pGrandFather->pl_Children.insert(std::next(insertPos), pPartial);
         } else {
-            pGrandFather->pl_Children.AddHead(pPartial);
+            pGrandFather->pl_Children.push_front(pPartial);
         }
-        pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+        pGrandFather->pl_Children.remove(pPnode);
         pPartial->pParent = pGrandFather;
         pPartial->pLeftSibling = pPnode->pLeftSibling;
         pPartial->pRightSibling = pPnode->pRightSibling;
@@ -1256,13 +770,13 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Now remove the p-node
-    pPnode->pl_Children.RemoveAll();
+    pPnode->pl_Children.clear();
     delete pPnode;
 
     // Add full subtree to q-node if necessary
     if (mFull > 0) {
-        CNode *pLeft = pPartial->pl_Children.GetTail();
-        pPartial->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial->pl_Children.back();
+        pPartial->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial;
         pNewFullPnode->pLeftSibling = pLeft;
         pNewFullPnode->pRightSibling = NULL;
@@ -1274,8 +788,8 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
 
     // Add empty subtree to q-node if necessary
     if (mEmpty > 0) {
-        CNode *pRight = pPartial->pl_Children.GetHead();
-        pPartial->pl_Children.AddHead(pNewEmptyPnode);
+        CNode *pRight = pPartial->pl_Children.front();
+        pPartial->pl_Children.push_front(pNewEmptyPnode);
         pNewEmptyPnode->pParent = pPartial;
         pNewEmptyPnode->pLeftSibling = NULL;
         pNewEmptyPnode->pRightSibling = pRight;
@@ -1289,24 +803,15 @@ bool CPQtree::Template_P5(CNode *pX, bool bRoot, CString sText) {
     pPartial->bRoot = false;
     pLastPertinentRoot = pPartial;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P5");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_P6(CNode *pX, bool bRoot) {
     // Pattern is with pX root of pertinent subtree and exactly TWO partial children)
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a P-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CPnode)))
+    if (!dynamic_cast<CPnode *>(pX))
         return false;
 
     CPnode *pPnode = (CPnode *) pX;
@@ -1316,12 +821,9 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
         return false;
 
     // Find two singly partial nodes
-    POSITION aPos = pPnode->pl_Children.GetHeadPosition();
     CNode *pPartial1 = NULL;
     CNode *pPartial2 = NULL;
-    while (aPos) {
-        CNode *pSearchNode = pPnode->pl_Children.GetNext(aPos);
-
+    for (CNode *pSearchNode : pPnode->pl_Children) {
         if (pSearchNode->LABEL == SINGLY_PARTIAL) {
             if (pPartial1 == NULL)
                 pPartial1 = pSearchNode;
@@ -1334,31 +836,17 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     if (pPartial1 == NULL || pPartial2 == NULL)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN P6 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template P6\n");
 
     // Create a new P-node for full subtree
     CNode *pNewFullPnode = new CPnode();
 
     // Move all full children to the new P nodes
-    aPos = pPnode->pl_Children.GetHeadPosition();
-    POSITION prevPos = aPos;
     CNode *pPrevFullNode = NULL;
-    while (aPos) {
+    auto it = pPnode->pl_Children.begin();
+    while (it != pPnode->pl_Children.end()) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetNext(aPos);
+        CNode *pTempNode = *it;
+        ++it;
 
         // move it
         if (pTempNode->LABEL == FULL) {
@@ -1374,7 +862,7 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
                 delete pNewFullPnode;
                 pNewFullPnode = pTempNode;
             } else {
-                pNewFullPnode->pl_Children.AddTail(pTempNode);
+                pNewFullPnode->pl_Children.push_back(pTempNode);
                 pTempNode->pParent = pNewFullPnode;
 
                 // update the linked list of nodes
@@ -1386,15 +874,15 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
             }
 
             // remove the full node for the list
-            pPnode->pl_Children.RemoveAt(prevPos);
+            pPnode->pl_Children.erase(std::prev(it));
         }
     }
 
     // Add full subtree to q-node (partial of the left)
     CNode *pPrevNode;
     if (mFull > 0) {
-        CNode *pLeft = pPartial1->pl_Children.GetTail();
-        pPartial1->pl_Children.AddTail(pNewFullPnode);
+        CNode *pLeft = pPartial1->pl_Children.back();
+        pPartial1->pl_Children.push_back(pNewFullPnode);
         pNewFullPnode->pParent = pPartial1;
         pLeft->pRightSibling = pNewFullPnode;
         pNewFullPnode->pLeftSibling = pLeft;
@@ -1403,7 +891,7 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     } else {
         // Empty P-node
         delete pNewFullPnode;
-        pPrevNode = pPartial1->pl_Children.GetTail();
+        pPrevNode = pPartial1->pl_Children.back();
     }
 
     // Label the replacement tree
@@ -1414,14 +902,12 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     pLastPertinentRoot = pPartial1;
 
     // Copy partial2 to partial1 in reverse order
-    aPos = pPartial2->pl_Children.GetTailPosition();
-    while (aPos) {
+    for (auto rit = pPartial2->pl_Children.rbegin(); rit != pPartial2->pl_Children.rend(); ++rit) {
         // Get next node on the list
-        prevPos = aPos;
-        CNode *pTempNode = pPnode->pl_Children.GetPrev(aPos);
+        CNode *pTempNode = *rit;
 
-        // Add it to partial1
-        pPartial1->pl_Children.AddTail(pTempNode);
+        // Add rit to partial1
+        pPartial1->pl_Children.push_back(pTempNode);
         pTempNode->pParent = pPartial1;
 
         pTempNode->pLeftSibling = pPrevNode;
@@ -1433,17 +919,16 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Erase partial2
-    POSITION dPos = pPnode->pl_Children.Find(pPartial2);
-    pPnode->pl_Children.RemoveAt(dPos);
+    pPnode->pl_Children.remove(pPartial2);
     if (pPartial2->pLeftSibling != NULL)
         pPartial2->pLeftSibling->pRightSibling = pPartial2->pRightSibling;
     if (pPartial2->pRightSibling != NULL)
         pPartial2->pRightSibling->pLeftSibling = pPartial2->pLeftSibling;
-    pPartial2->pl_Children.RemoveAll();
+    pPartial2->pl_Children.clear();
     delete pPartial2;
 
     // Check for special case: A parent node with just one child
-    if (pPnode->pl_Children.GetCount() == 1) {
+    if (pPnode->pl_Children.size() == 1) {
         // p-node is the roor of the pqTree?
         if (pRoot == pPnode) {
             // we don't need to insert anything, just make this node root of pqTree
@@ -1455,12 +940,12 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
             // Before removing the p-node, insert the q-node in the parent of the p-node
             CNode *pGrandFather = pPnode->pParent;
             if (pPnode->pLeftSibling != NULL) {
-                POSITION insertPos = pGrandFather->pl_Children.Find(pPnode->pLeftSibling);
-                pGrandFather->pl_Children.InsertAfter(insertPos, pPartial1);
+                auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pPnode->pLeftSibling);
+                pGrandFather->pl_Children.insert(std::next(insertPos), pPartial1);
             } else {
-                pGrandFather->pl_Children.AddHead(pPartial1);
+                pGrandFather->pl_Children.push_front(pPartial1);
             }
-            pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pPnode));
+            pGrandFather->pl_Children.remove(pPnode);
             pPartial1->pParent = pGrandFather;
             pPartial1->pLeftSibling = pPnode->pLeftSibling;
             pPartial1->pRightSibling = pPnode->pRightSibling;
@@ -1471,29 +956,21 @@ bool CPQtree::Template_P6(CNode *pX, bool bRoot, CString sText) {
         }
 
         // Now remove the p-node, otherwise will produce a linnear chain of nodes
-        pPnode->pl_Children.RemoveAll();
+        pPnode->pl_Children.clear();
         delete pPnode;
     }
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
     pPartial1->bRoot = false;
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN P6");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_Q1(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q1(CNode *pX, bool bRoot) {
     // The pattern is with X being a Q-node and all children full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
 
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1503,40 +980,20 @@ bool CPQtree::Template_Q1(CNode *pX, bool bRoot, CString sText) {
         return false;
 
     // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q1 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q1\n");
     pX->LABEL = FULL;
 
     // Save PQ-tree for later viewing
     pX->bRoot = bRoot;
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q1");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
 
     return true;
 }
 
-bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q2(CNode *pX, bool bRoot) {
     // Pattern is a Q-node with 0 or 1 singly partial child, and not all children are labeled
     // identically (all full is Q1, and all empty is "Q0")
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1556,11 +1013,11 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     // Check node order:   a) Empty nodes -> Partial node -> Full nodes, or
     //					   b) Full nodes -> Partial node -> Empty nodes
 
-    CNode *pFirst = pQnode->pl_Children.GetHead();
+    CNode *pFirst = pQnode->pl_Children.front();
     bool bReversed = false;// this is to know how to insert nodes later
-    const WORD FORWARD = 0;
-    const WORD REVERSE = 1;
-    const WORD MIDDLE = 2;
+    const int FORWARD = 0;
+    const int REVERSE = 1;
+    const int MIDDLE = 2;
     int nScanning;
     int nState = 0;
     if (pFirst->LABEL == EMPTY) {
@@ -1574,9 +1031,10 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     }
 
     CNode *pPartial = NULL;
-    POSITION sPos = pQnode->pl_Children.GetHeadPosition();
-    while (sPos && nState != 4) {
-        CNode *pChild = pQnode->pl_Children.GetNext(sPos);
+    for (CNode *pChild : pQnode->pl_Children) {
+        if (nState == 4) {
+            break;
+        }
 
         // use this oportunity to get partial node
         if (pChild->LABEL == SINGLY_PARTIAL)
@@ -1683,43 +1141,36 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     if (nState == 4)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q2 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q2\n");
-
     // Manage the posibility of no partial node
     CNode *pPrevFullNode;
     if (pPartial == NULL) {
         pPartial = new CQnode();
         pPrevFullNode = NULL;
     } else {
-        pPrevFullNode = pPartial->pl_Children.GetTail();
+        pPrevFullNode = pPartial->pl_Children.back();
     }
 
     // Move all full children to the partial node
-    POSITION aPos, prevPos;
+    using forward_it = std::list<CNode *>::iterator;
+    using reverse_it = std::list<CNode *>::reverse_iterator;
+    std::variant<forward_it, reverse_it> aPos, prevPos;
     CNode *pTempNode;
-    if (!bReversed)
-        aPos = pQnode->pl_Children.GetHeadPosition();
-    else
-        aPos = pQnode->pl_Children.GetTailPosition();
-    while (aPos) {
+    if (!bReversed) {
+        aPos = pQnode->pl_Children.begin();
+    } else {
+        aPos = pQnode->pl_Children.rbegin();
+    }
+
+    while ((bReversed && std::get<reverse_it>(aPos) != pQnode->pl_Children.rend()) ||
+           (!bReversed && std::get<forward_it>(aPos) != pQnode->pl_Children.end())) {
         // Get next node on the list
         prevPos = aPos;
-        if (!bReversed)
-            pTempNode = pQnode->pl_Children.GetNext(aPos);
-        else
-            pTempNode = pQnode->pl_Children.GetPrev(aPos);
+        if (!bReversed) {
+            pTempNode = *(std::get<forward_it>(aPos)++);
+        } else {
+            pTempNode = *(std::get<reverse_it>(aPos)++);
+        }
+
 
         // Insertion for full or for empty node?
         if (pTempNode->LABEL == FULL) {
@@ -1730,7 +1181,7 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
                 pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
 
             // Insert the full node
-            pPartial->pl_Children.AddTail(pTempNode);
+            pPartial->pl_Children.push_back(pTempNode);
             pTempNode->pParent = pPartial;
 
             // update the linked list of nodes
@@ -1741,24 +1192,30 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
             pPrevFullNode = pTempNode;
 
             // remove the full node for the list
-            pQnode->pl_Children.RemoveAt(prevPos);
+            if (!bReversed) {
+                pQnode->pl_Children.erase(std::prev(std::get<forward_it>(aPos)));
+            } else {
+                aPos = std::make_reverse_iterator(pQnode->pl_Children.erase(std::get<reverse_it>(aPos).base()));
+            }
         }
     }
 
     // Move all empty children to the partial node
-    if (!bReversed)
-        aPos = pQnode->pl_Children.GetTailPosition();
-    else
-        aPos = pQnode->pl_Children.GetHeadPosition();
-    CNode *pNextEmptyNode = pPartial->pl_Children.GetHead();
-    POSITION nextPos;
-    while (aPos) {
+    if (!bReversed) {
+        aPos = pQnode->pl_Children.rbegin();
+    } else {
+        aPos = pQnode->pl_Children.begin();
+    }
+    CNode *pNextEmptyNode = pPartial->pl_Children.front();
+    while ((!bReversed && std::get<reverse_it>(aPos) != pQnode->pl_Children.rend()) ||
+           (bReversed && std::get<forward_it>(aPos) != pQnode->pl_Children.end())) {
         // Get next node on the list
-        nextPos = aPos;
-        if (!bReversed)
-            pTempNode = pQnode->pl_Children.GetPrev(aPos);
-        else
-            pTempNode = pQnode->pl_Children.GetNext(aPos);
+        if (!bReversed) {
+            pTempNode = *(std::get<reverse_it>(aPos)++);
+        } else {
+            pTempNode = *(std::get<forward_it>(aPos)++);
+        }
+
 
         // Insertion for full or for empty node?
         if (pTempNode->LABEL == EMPTY) {
@@ -1769,7 +1226,7 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
                 pTempNode->pRightSibling->pLeftSibling = pTempNode->pLeftSibling;
 
             // insert the empty node
-            pPartial->pl_Children.AddHead(pTempNode);
+            pPartial->pl_Children.push_front(pTempNode);
             pTempNode->pParent = pPartial;
 
             // update the linked list of nodes
@@ -1780,7 +1237,11 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
             pNextEmptyNode = pTempNode;
 
             // remove the empty node for the list
-            pQnode->pl_Children.RemoveAt(nextPos);
+            if (!bReversed) {
+                aPos = std::make_reverse_iterator(pQnode->pl_Children.erase(std::get<reverse_it>(aPos).base()));
+            } else {
+                pQnode->pl_Children.erase(std::prev(std::get<forward_it>(aPos)));
+            }
         }
     }
 
@@ -1793,12 +1254,12 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
         // Before removing the Q-node, insert the partial q-node in the parent
         CNode *pGrandFather = pQnode->pParent;
         if (pQnode->pLeftSibling != NULL) {
-            POSITION insertPos = pGrandFather->pl_Children.Find(pQnode->pLeftSibling);
-            pGrandFather->pl_Children.InsertAfter(insertPos, pPartial);
+            auto insertPos = std::find(pGrandFather->pl_Children.begin(), pGrandFather->pl_Children.end(), pQnode->pLeftSibling);
+            pGrandFather->pl_Children.insert(std::next(insertPos), pPartial);
         } else {
-            pGrandFather->pl_Children.AddHead(pPartial);
+            pGrandFather->pl_Children.push_front(pPartial);
         }
-        pGrandFather->pl_Children.RemoveAt(pGrandFather->pl_Children.Find(pQnode));
+        pGrandFather->pl_Children.remove(pQnode);
         pPartial->pParent = pGrandFather;
         pPartial->pLeftSibling = pQnode->pLeftSibling;
         pPartial->pRightSibling = pQnode->pRightSibling;
@@ -1809,33 +1270,23 @@ bool CPQtree::Template_Q2(CNode *pX, bool bRoot, CString sText) {
     }
 
     // Now remove the Q-node
-    pQnode->pl_Children.RemoveAll();
+    pQnode->pl_Children.clear();
     delete pQnode;
 
     // label new subtree
     pPartial->bRoot = bRoot;
     pPartial->LABEL = SINGLY_PARTIAL;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q2");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
-bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
+bool CPQtree::Template_Q3(CNode *pX, bool bRoot) {
     // Pattern is a Q-node with 0, 1 or 2 singly partial child,
     // Endmost subtrees must be empty or partial (otherwise Q2 would apply)
     // Middle subtree must be full
 
-    // Get appropiate pointer to document
-    ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CGraphToolDoc)));
-    CGraphToolDoc *pGDoc = (CGraphToolDoc *) pDoc;
-
     // X must be a Q-node
-    if (!pX->IsKindOf(RUNTIME_CLASS(CQnode)))
+    if (!dynamic_cast<CQnode *>(pX))
         return false;
 
     CQnode *pQnode = (CQnode *) pX;
@@ -1847,15 +1298,17 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
     // Check node order:  [EMPTY]->[PARTIAL]->[FULL]->[PARTIAL]->[EMPTY]
     //		      State:     0         1         2        3         4
 
-    CNode *pFirst = pQnode->pl_Children.GetHead();
+    CNode *pFirst = pQnode->pl_Children.front();
     int nState = 0;
     CNode *pPartial1 = NULL;
     CNode *pPartial2 = NULL;
     CNode *pFirstFull = NULL;
     CNode *pLastFull = NULL;
-    POSITION sPos = pQnode->pl_Children.GetHeadPosition();
-    while (sPos && nState != 5) {
-        CNode *pChild = pQnode->pl_Children.GetNext(sPos);
+
+    for (CNode *pChild : pQnode->pl_Children) {
+        if (nState == 5) {
+            break;
+        }
 
         // use this oportunity to get partial nodes
         if (pChild->LABEL == SINGLY_PARTIAL) {
@@ -1920,32 +1373,17 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
     if (nState == 5)
         return false;
 
-    // Save PQ-tree for later viewing
-    pX->bCurrent = true;
-    CPQtree *cpy_pqTree = new CPQtree(this);
-    pX->bCurrent = false;
-    if (sText.IsEmpty())
-        cpy_pqTree->sComment = CString("PATTERN Q3 Detected");
-    else
-        cpy_pqTree->sComment = sText;
-    cpy_pqTree->nIndent = 1;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree);
-
-    // REPLACEMENT
-    TRACE("\nApplying template Q3\n");
 
     // Move partial1 to the Q-node
     CNode *pLastNode = NULL;
     if (pPartial1 != NULL) {
-        POSITION insertPos = pQnode->pl_Children.Find(pPartial1);
-        POSITION aPos = pPartial1->pl_Children.GetHeadPosition();
+        auto insertPos = std::find(pQnode->pl_Children.begin(), pQnode->pl_Children.end(), pPartial1);
         CNode *pPrevNode = pPartial1->pLeftSibling;
-        while (aPos) {
+        for (CNode *pTempNode : pPartial1->pl_Children) {
             // Get next node on the list
-            CNode *pTempNode = pPartial1->pl_Children.GetNext(aPos);
 
             // Insert the node node
-            pQnode->pl_Children.InsertBefore(insertPos, pTempNode);
+            pQnode->pl_Children.insert(insertPos, pTempNode);
             pTempNode->pParent = pQnode;
 
             // update the linked list of nodes
@@ -1958,8 +1396,8 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
         pLastNode = pPrevNode;
 
         // remove partial1
-        pQnode->pl_Children.RemoveAt(insertPos);
-        pPartial1->pl_Children.RemoveAll();
+        pQnode->pl_Children.erase(insertPos);
+        pPartial1->pl_Children.clear();
         delete pPartial1;
     }
 
@@ -1972,16 +1410,15 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
 
     // Move partial2 to the Q-node
     if (pPartial2 != NULL) {
-        POSITION insertPos = pQnode->pl_Children.Find(pPartial2);
-        POSITION aPos = pPartial2->pl_Children.GetTailPosition();
+        auto insertPos = std::find(pQnode->pl_Children.begin(), pQnode->pl_Children.end(), pPartial2);
         CNode *pPrevNode = pLastNode;
         CNode *pTempNode = NULL;
-        while (aPos) {
+        for (auto rit = pPartial2->pl_Children.rbegin(); rit != pPartial2->pl_Children.rend(); ++rit) {
             // Get next node on the list
-            pTempNode = pPartial2->pl_Children.GetPrev(aPos);
+            pTempNode = *rit;
 
             // Insert the node node
-            pQnode->pl_Children.InsertBefore(insertPos, pTempNode);
+            pQnode->pl_Children.insert(insertPos, pTempNode);
             pTempNode->pParent = pQnode;
 
             // update the linked list of nodes
@@ -1996,8 +1433,8 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
             pPartial2->pRightSibling->pLeftSibling = pTempNode;
 
         // remove partial1
-        pQnode->pl_Children.RemoveAt(insertPos);
-        pPartial2->pl_Children.RemoveAll();
+        pQnode->pl_Children.erase(insertPos);
+        pPartial2->pl_Children.clear();
         delete pPartial2;
     }
 
@@ -2005,12 +1442,6 @@ bool CPQtree::Template_Q3(CNode *pX, bool bRoot, CString sText) {
     pQnode->bRoot = bRoot;
     pQnode->LABEL = DOUBLY_PARTIAL;
 
-    // Save PQ-tree for later viewing
-    CPQtree *cpy_pqTree2 = new CPQtree(this);
-    cpy_pqTree2->sComment = CString("Replacement for PATTERN Q3");
-    cpy_pqTree2->nIndent = 2;
-    pGDoc->pl_PQtrees.AddTail(cpy_pqTree2);
-
     return true;
 }
 
@@ -2022,13 +1453,10 @@ void CPQtree::CountNodeTypes(CNode *pX) {
     mPartial = 0;
     mTotal = 0;
 
-    if (pX->IsKindOf(RUNTIME_CLASS(CLeafnode)))
+    if (dynamic_cast<CLeafnode *>(pX))
         return;
 
-    POSITION aPos = pX->pl_Children.GetHeadPosition();
-    while (aPos) {
-        CNode *pChildNode = pX->pl_Children.GetNext(aPos);
-
+    for (CNode *pChildNode : pX->pl_Children) {
         if (pChildNode->LABEL == FULL)
             mFull++;
         else if (pChildNode->LABEL == EMPTY)
@@ -2039,3 +1467,29 @@ void CPQtree::CountNodeTypes(CNode *pX) {
         mTotal++;
     }
 }
+
+Bigint CPQtree::possibleOrders() {
+    Bigint orders(1);
+
+    std::queue<CNode *> queue;
+    queue.push(pRoot);
+
+    while (!queue.empty()) {
+        CNode *nextNode = queue.front();
+        queue.pop();
+
+        if (dynamic_cast<CPnode *>(nextNode) != nullptr) {
+            int childCount = nextNode == pRoot ? nextNode->pl_Children.size() - 1 : nextNode->pl_Children.size();
+            orders *= factorial(childCount);
+        } else if (dynamic_cast<CQnode *>(nextNode) != nullptr) {
+            orders *= 2;
+        } else {
+            continue;
+        }
+
+        for (CNode *child : nextNode->pl_Children) {
+            queue.push(child);
+        }
+    }
+    return orders;
+}
diff --git a/libraries/graphSetPQ/PQtree.h b/libraries/graphSetPQ/PQtree.h
index e34825f..e518ce8 100644
--- a/libraries/graphSetPQ/PQtree.h
+++ b/libraries/graphSetPQ/PQtree.h
@@ -1,27 +1,22 @@
 #pragma once
 
 #include "Node.h"
-#include "Vertex.h"
-
-class CPQtree : public CObject {
-    DECLARE_DYNAMIC(CPQtree)
+#include "bigInt/bigint.h"
+#include <list>
 
+class CLeafnode;
+using namespace Dodecahedron;
+class CPQtree {
 public:
     CNode *pRoot;
-    int iHeight;
-    int iWidth;
-    int iLevels;
     bool bSets;
 
-    CDocument *pDoc;
-    CString sComment;// Comment for PQtreeView
-    int nIndent;     // Indentation for PQtreeView
 
     // GLOBAL VARIABLES as described in Booth and Lueker
     int BLOCK_COUNT;
     int BLOCKED_NODES;
     int OFF_THE_TOP;
-    CTypedPtrList<CObList, CNode *> QUEUE;
+    std::list<CNode *> QUEUE;
     CNode *pVirtual;// virtual node to walk around blocked nodes in BUBBLE procedure
 
     int mFull;
@@ -33,37 +28,35 @@ public:
     CNode *pLastPertinentRoot;
 
 public:
-    CRect Draw(CDC *pDC, CPoint Offset);
-    void FindLeaves(CTypedPtrList<CObList, CNode *> *plQueue);
+    void FindLeaves(std::list<CLeafnode *> *plQueue);
     void SetAllUnmatched();
     void ClearPointers();
     bool ArePertinentConsecutive(int v);
 
-    void CopyFullChildren(CVertex *pU, CNode *pNode);
-
-    CPQtree(CDocument *pDoc, CVertex *pStart);
-    CPQtree(CDocument *pDoc, CNode *pNode);
+    CPQtree(int numLeaves);
+    CPQtree(CNode *pNode);
     CPQtree(CPQtree *pqTree);
-    ~CPQtree(void);
+    ~CPQtree();
 
 public:
-    bool Bubble(CTypedPtrList<CObList, CNode *> *pl_S);
-    bool Reduce(CTypedPtrList<CObList, CNode *> *pl_S, int v);
-    void VertexAddition(CVertex *pV, CVertex *pU = NULL);
+    bool Bubble(std::list<CLeafnode *> *pl_S);
+    void prepareReduction(std::list<CLeafnode *> *pl_s, int v);
+    bool Reduce(std::list<CLeafnode *> *pl_S, int v);
     void ReInitialize();
     void CountNodeTypes(CNode *pX);
     void CountPertinentNodes(int v);
+    Bigint possibleOrders();
 
     // templates
 public:
-    bool Template_L1(CNode *pX, bool bRoot, int v, CString sText = CString(""));
-    bool Template_P1(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P2(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P3(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P4(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P5(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_P6(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q1(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q2(CNode *pX, bool bRoot, CString sText = CString(""));
-    bool Template_Q3(CNode *pX, bool bRoot, CString sText = CString(""));
+    bool Template_L1(CNode *pX, bool bRoot, int v);
+    bool Template_P1(CNode *pX, bool bRoot);
+    bool Template_P2(CNode *pX, bool bRoot);
+    bool Template_P3(CNode *pX, bool bRoot);
+    bool Template_P4(CNode *pX, bool bRoot);
+    bool Template_P5(CNode *pX, bool bRoot);
+    bool Template_P6(CNode *pX, bool bRoot);
+    bool Template_Q1(CNode *pX, bool bRoot);
+    bool Template_Q2(CNode *pX, bool bRoot);
+    bool Template_Q3(CNode *pX, bool bRoot);
 };
diff --git a/libraries/graphSetPQ/Pnode.cpp b/libraries/graphSetPQ/Pnode.cpp
index 5cdce06..db914c2 100644
--- a/libraries/graphSetPQ/Pnode.cpp
+++ b/libraries/graphSetPQ/Pnode.cpp
@@ -1,387 +1,24 @@
 #include "Pnode.h"
-#include "Edge.h"
-#include "Leafnode.h"
 #include "Node.h"
-#include "Qnode.h"
-#include "stdafx.h"
 
-IMPLEMENT_DYNAMIC(CPnode, CNode)
 
 CPnode::CPnode() {
     // constructor creates an empty P-node
-    iWidth = 0;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = BLUE;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 }
 
-CPnode::CPnode(CVertex *pV, int Color) {
-    // constructor creates the P-node relative to pV, with all edges incident to pV
-    // as leaf nodes and children of the current node
-
-    iWidth = 0;
-    LABEL = EMPTY;
-    MARK = UNMARKED;
-    pParent = NULL;
-    bVirtual = false;
-    PERTINENT_LEAF_COUNT = 0;
-    PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
-    bRoot = false;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = Color;
-
-    // Pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
-
-    CElement *pElement;
-    CLeafnode *pLeafNode;
-    CLeafnode *pPrevLeafNode;
-    CVertex *pW;
-    POSITION aPos;
-
-    // iterate trough all edges incident to pV
-    aPos = pV->pl_Edges.GetHeadPosition();
-    pPrevLeafNode = NULL;
-    int leafColor;
-    while (aPos) {
-        pElement = pV->pl_Edges.GetNext(aPos);
-        if (pElement->IsKindOf(RUNTIME_CLASS(CEdge))) {
-            CEdge *pEdge = (CEdge *) pElement;
-            CEdge *pEdge2 = NULL;
-
-            // Create a leaf node for each edge incident to pV, but not for already processed vertices
-            pW = (pV == pEdge->pStart) ? pEdge->pEnd : pEdge->pStart;
-
-            // only vertices that are not yet processed (reversed order)
-            if (pW->nST < pV->nST) {
-                // Set the color of the edge (stored in the child)
-                //				if (pEdge->m_Graph==GRAPH1)
-                leafColor = BLUE;
-                //				else
-                //					leafColor = RED;
-
-                // Try to find the same edge on the other graph (a black edge)
-                bool bBlackBefore = false;
-                POSITION aPos2 = pV->pl_Edges.GetHeadPosition();// search from the beggining to current position
-                while (aPos2 && aPos2 != aPos) {
-                    CElement *pElement2 = pV->pl_Edges.GetNext(aPos2);
-                    if (pElement2->IsKindOf(RUNTIME_CLASS(CEdge))) {
-                        pEdge2 = (CEdge *) pElement2;
-
-                        if (pEdge != pEdge2 && pEdge->m_Graph != pEdge2->m_Graph && ((pEdge->pStart == pEdge2->pStart && pEdge->pEnd == pEdge2->pEnd) || (pEdge->pStart == pEdge2->pEnd && pEdge->pEnd == pEdge2->pStart))) {
-                            // This is a black edge
-                            bBlackBefore = true;
-                            break;
-                        }
-                    }
-                }
-
-                // Try to find the same edge on the other graph (a black edge)
-                bool bBlackAfter = false;
-                aPos2 = aPos;// search from current position to the end
-                while (aPos2) {
-                    CElement *pElement2 = pV->pl_Edges.GetNext(aPos2);
-                    if (pElement2->IsKindOf(RUNTIME_CLASS(CEdge))) {
-                        pEdge2 = (CEdge *) pElement2;
-
-                        if (pEdge != pEdge2 && pEdge->m_Graph != pEdge2->m_Graph && ((pEdge->pStart == pEdge2->pStart && pEdge->pEnd == pEdge2->pEnd) || (pEdge->pStart == pEdge2->pEnd && pEdge->pEnd == pEdge2->pStart))) {
-                            // This is a black edge
-                            bBlackAfter = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (!bBlackBefore) {
-
-                    // create a new leaf node or set the edge black
-                    if (bBlackAfter) {
-                        pLeafNode = new CLeafnode(pW, BLACK);
-                        pLeafNode->pParent = this;
-                    } else {
-                        pLeafNode = new CLeafnode(pW, leafColor);
-                        pLeafNode->pParent = this;
-                    }
-
-                    // update the linked list of nodes
-                    pLeafNode->pLeftSibling = (CNode *) pPrevLeafNode;
-                    if (pPrevLeafNode != NULL)
-                        pPrevLeafNode->pRightSibling = (CNode *) pLeafNode;
-                    pLeafNode->pRightSibling = NULL;
-                    pPrevLeafNode = pLeafNode;
-
-                    // Add the new node to linked lists
-                    pl_Children.AddTail(pLeafNode);
-                    pLeafNode->pNode->pl_S.AddTail(pLeafNode);
-                }
-            }
-        }
-    }
-}
-
-CPnode::CPnode(CPnode *pNode) {
-    iWidth = pNode->iWidth;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-
-    CNode *pTempNode;
-    CNode *pNewNode;
-    CNode *pPrevNode;
-
-    // This constructor creates a copy of the given pNode
-    POSITION aPos = pNode->pl_Children.GetHeadPosition();
-    pPrevNode = NULL;
-    while (aPos) {
-        pTempNode = (CNode *) pNode->pl_Children.GetNext(aPos);
-
-        if (pTempNode->IsKindOf(RUNTIME_CLASS(CPnode))) {
-            pNewNode = (CNode *) new CPnode((CPnode *) pTempNode);
-            pl_Children.AddTail((CPnode *) pNewNode);
-        } else if (pTempNode->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            pNewNode = (CNode *) new CQnode((CQnode *) pTempNode);
-            pl_Children.AddTail((CQnode *) pNewNode);
-        } else {
-            pNewNode = (CNode *) new CLeafnode((CLeafnode *) pTempNode);
-            pl_Children.AddTail((CLeafnode *) pNewNode);
-        }
-
-        // update the linked list of nodes
-        pNewNode->pLeftSibling = (CNode *) pPrevNode;
-        if (pPrevNode != NULL)
-            pPrevNode->pRightSibling = (CNode *) pNewNode;
-        pNewNode->pRightSibling = NULL;
-        pPrevNode = pNewNode;
+CPnode::~CPnode() {
+    for (CNode *node : pl_Children) {
+        delete node;
     }
-}
-
-CPnode::~CPnode(void) {
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        delete pl_Children.GetNext(aPos);
-    }
-
-    pl_Children.RemoveAll();
-}
-
-int CPnode::CalculateWidth() {
-    POSITION aPos;
-    CNode *pNode;
 
-    iWidth = 0;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        iWidth += pNode->CalculateWidth();
-    }
-
-    return iWidth;
-}
-
-int CPnode::CalculateLevel(int level) {
-    POSITION aPos;
-    CNode *pNode;
-
-    iLevel = level;
-    int maxLevel = level;
-    int newLevel;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        newLevel = pNode->CalculateLevel(level + 1);
-
-        if (newLevel > maxLevel) maxLevel = newLevel;
-    }
-
-    return maxLevel;
-}
-
-void CPnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    POSITION aPos;
-    CNode *pNode;
-    int offx;
-    int childx;
-    CBrush blueBrush(RGB(0, 0, 255));
-    CBrush lightBlueBrush(RGB(40, 190, 220));
-    CBrush *pOldBrush;
-    CPen bluePen(PS_SOLID, 2, RGB(0, 0, 255));
-    CPen redPen(PS_SOLID, 2, RGB(255, 0, 0));
-
-    // Calculate the area for the node
-    int centerx = Offset.x + (iWidth / 2);
-    CRect ellipseRect = CRect(centerx - PNODERAD, Offset.y, centerx + PNODERAD + 1, Offset.y + (PNODERAD * 2) + 1);
-
-    // If the node is the root of the pertinent subtree, draw a gray background
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        ellipseRect.InflateRect(5, 5);
-        pDC->Ellipse(ellipseRect);
-        ellipseRect.DeflateRect(5, 5);
-    }
-
-    pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the edges to the children: BLUE first
-    pDC->SelectObject(bluePen);
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the edges to the children: now BLACK ones
-    pDC->SelectStockObject(BLACK_PEN);
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLACK) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the edges to the children: now RED ones
-    pDC->SelectObject(redPen);
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == RED) {
-            childx = offx + (pNode->iWidth / 2);
-            pDC->MoveTo(centerx, Offset.y + PNODERAD);
-            pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Choose the node depending of the type of node
-    if (LABEL == FULL)
-        pOldBrush = pDC->SelectObject(&blueBrush);
-    else if (LABEL == PARTIAL || LABEL == SINGLY_PARTIAL || LABEL == DOUBLY_PARTIAL)
-        pOldBrush = pDC->SelectObject(&lightBlueBrush);
-    else
-        pOldBrush = (CBrush *) pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the node
-    pDC->SelectStockObject(BLACK_PEN);
-    pDC->Ellipse(ellipseRect);
-
-    // Draw the children: BLUE first
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the children: now BLACK ones
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLACK) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // Draw the children: now RED ones
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == RED) {
-            pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-            offx += pNode->iWidth;
-        }
-    }
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = ellipseRect.left - ARROWSIZE;
-        int arrowY = ellipseRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // If we are debugging, display node address
-    if (DEBUG_PQTREE) {
-        char alfa[MAX_ALFA];
-        int tx = ellipseRect.CenterPoint().x + PNODERAD * 2;
-        int ty = ellipseRect.top - PNODERAD;
-        CRect drawRect = CRect(tx, ty, tx + LEAFWIDTH, ty + LEVELHEIGHT);
-        CRect calcRect = CRect(drawRect);
-
-        sprintf_s(alfa, "(%p)\nc(%d)\nl(%d)", pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-        pDC->DrawText(CString(alfa), calcRect, DT_CALCRECT);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        calcRect.InflateRect(2, 2, 2, 2);
-        pDC->Rectangle(calcRect);
-        calcRect.DeflateRect(2, 2, 2, 2);
-        pDC->DrawText(CString(alfa), drawRect, 0);
-    }
+    pl_Children.clear();
 }
diff --git a/libraries/graphSetPQ/Pnode.h b/libraries/graphSetPQ/Pnode.h
index fc5698c..2c81d9f 100644
--- a/libraries/graphSetPQ/Pnode.h
+++ b/libraries/graphSetPQ/Pnode.h
@@ -1,19 +1,10 @@
 #pragma once
 
-#include "Vertex.h"
-#include "node.h"
+#include "Node.h"
 
 class CPnode : public CNode {
-    DECLARE_DYNAMIC(CPnode)
-
 public:
     CPnode();
-    CPnode(CVertex *pV, int Color);
-    CPnode(CPnode *pNode);
-
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
 
-    virtual ~CPnode(void);
+    virtual ~CPnode();
 };
diff --git a/libraries/graphSetPQ/Qnode.cpp b/libraries/graphSetPQ/Qnode.cpp
index 9ef5220..4d83bf4 100644
--- a/libraries/graphSetPQ/Qnode.cpp
+++ b/libraries/graphSetPQ/Qnode.cpp
@@ -1,254 +1,29 @@
-#include ".\qnode.h"
-#include "Constants.h"
-#include "Leafnode.h"
+#include "Qnode.h"
+#include "LeafNode.h"
 #include "Pnode.h"
-#include "stdafx.h"
 
-IMPLEMENT_DYNAMIC(CQnode, CNode)
 
 CQnode::CQnode() {
-    iWidth = 0;
     LABEL = EMPTY;
     MARK = UNMARKED;
     pParent = NULL;
     bVirtual = false;
     PERTINENT_LEAF_COUNT = 0;
     PERTINENT_CHILD_COUNT = 0;
-    bCurrent = false;
     bRoot = false;
     pLeftSibling = NULL;
     pRightSibling = NULL;
-    EdgeColor = BLUE;
-
-    // pointer debugging
-    pOriginalNode = NULL;
-    pOriginalParent = NULL;
-    pOriginalLeft = NULL;
-    pOriginalRight = NULL;
 }
 
-CQnode::CQnode(CQnode *pNode) {
-    // Constructor for copying
-
-    iWidth = pNode->iWidth;
-    pParent = pNode->pParent;
-    bVirtual = pNode->bVirtual;
-    PERTINENT_LEAF_COUNT = pNode->PERTINENT_LEAF_COUNT;
-    PERTINENT_CHILD_COUNT = pNode->PERTINENT_CHILD_COUNT;
-    bCurrent = pNode->bCurrent;
-    bRoot = pNode->bRoot;
-    LABEL = pNode->LABEL;
-    MARK = pNode->MARK;
-    pLeftSibling = NULL;
-    pRightSibling = NULL;
-    EdgeColor = pNode->EdgeColor;
-
-    // pointer debugging
-    pOriginalNode = pNode;
-    pOriginalParent = pNode->pParent;
-    pOriginalLeft = pNode->pLeftSibling;
-    pOriginalRight = pNode->pRightSibling;
-
-    CNode *pTempNode;
-    CNode *pNewNode;
-    CNode *pPrevNode;
-
-    // This constructor creates a copy of the given pNode
-    POSITION aPos = pNode->pl_Children.GetHeadPosition();
-    pPrevNode = NULL;
-    while (aPos) {
-        pTempNode = (CNode *) pNode->pl_Children.GetNext(aPos);
 
-        if (pTempNode->IsKindOf(RUNTIME_CLASS(CPnode))) {
-            pNewNode = (CNode *) new CPnode((CPnode *) pTempNode);
-            pl_Children.AddTail((CPnode *) pNewNode);
-        } else if (pTempNode->IsKindOf(RUNTIME_CLASS(CQnode))) {
-            pNewNode = (CNode *) new CQnode((CQnode *) pTempNode);
-            pl_Children.AddTail((CQnode *) pNewNode);
-        } else {
-            pNewNode = (CNode *) new CLeafnode((CLeafnode *) pTempNode);
-            pl_Children.AddTail((CLeafnode *) pNewNode);
-        }
-
-        // update the linked list of nodes
-        pNewNode->pLeftSibling = (CNode *) pPrevNode;
-        if (pPrevNode != NULL)
-            pPrevNode->pRightSibling = (CNode *) pNewNode;
-        pNewNode->pRightSibling = NULL;
-        pPrevNode = pNewNode;
-    }
-}
-
-CQnode::~CQnode(void) {
+CQnode::~CQnode() {
     if (bVirtual)
         return;// real parent will dispose the children
 
-    POSITION aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        delete pl_Children.GetNext(aPos);
-    }
-
-    pl_Children.RemoveAll();
-}
-
-int CQnode::CalculateWidth() {
-    POSITION aPos;
-    CNode *pNode;
-
-    iWidth = 0;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        iWidth += pNode->CalculateWidth();
-    }
-
-    return iWidth;
-}
-
-int CQnode::CalculateLevel(int level) {
-    POSITION aPos;
-    CNode *pNode;
-
-    iLevel = level;
-    int maxLevel = level;
-    int newLevel;
-
-    aPos = pl_Children.GetHeadPosition();
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        newLevel = pNode->CalculateLevel(level + 1);
 
-        if (newLevel > maxLevel) maxLevel = newLevel;
+    for (CNode *node : pl_Children) {
+        delete node;
     }
 
-    return maxLevel;
-}
-
-void CQnode::Draw(CDC *pDC, CPoint Offset, bool bSets) {
-    POSITION aPos;
-    CNode *pNode;
-    int offx;
-    int childx;
-    CBrush blueBrush(RGB(0, 0, 255));
-    CBrush navyBlueBrush(RGB(0, 0, 64));
-    CBrush *pOldBrush;
-    CPen bluePen(PS_SOLID, 2, RGB(0, 0, 255));
-    CPen redPen(PS_SOLID, 2, RGB(255, 0, 0));
-
-    // Calculate the are for the node
-    int centerx = Offset.x + (iWidth / 2);
-    CRect QRect = CRect(Offset.x + SIBLINGMARGIN, Offset.y, Offset.x + iWidth - SIBLINGMARGIN, Offset.y + QNODESIZE);
-
-    // If the nood is the root of the pertinent subtree, draw a gray background
-    if (bRoot) {
-        CBrush GrayBrush;
-        GrayBrush.CreateSolidBrush(RGB(220, 220, 220));
-        CBrush *pOldBrush = (CBrush *) pDC->SelectObject(GrayBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        QRect.InflateRect(3, 3);
-        pDC->Rectangle(QRect);
-        QRect.DeflateRect(3, 3);
-    }
-
-    pDC->SelectStockObject(WHITE_BRUSH);
-
-    // Draw the edges to the children
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        if (pNode->EdgeColor == BLUE)
-            pDC->SelectObject(bluePen);
-        else if (pNode->EdgeColor == RED)
-            pDC->SelectObject(redPen);
-        else
-            pDC->SelectStockObject(BLACK_PEN);
-
-        childx = offx + (pNode->iWidth / 2);
-        pDC->MoveTo(centerx, Offset.y + PNODERAD);
-        pDC->LineTo(childx, Offset.y + LEVELHEIGHT + PNODERAD);
-
-        offx += pNode->iWidth;
-    }
-
-    // Draw the node
-    if (LABEL == FULL) {
-        pOldBrush = pDC->SelectObject(&blueBrush);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == PARTIAL) {
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == SINGLY_PARTIAL) {
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->SelectStockObject(NULL_PEN);
-        pDC->Rectangle(QRect.CenterPoint().x - 1, QRect.top, QRect.right, QRect.bottom);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.left, QRect.top, QRect.CenterPoint().x, QRect.bottom);
-        pDC->SelectStockObject(BLACK_PEN);
-        pDC->SelectStockObject(NULL_BRUSH);
-        pDC->Rectangle(QRect);
-    } else if (LABEL == DOUBLY_PARTIAL) {
-        int t = QRect.Width() / 3;
-        pDC->SelectStockObject(NULL_PEN);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.left, QRect.top, QRect.left + t - 1, QRect.bottom);
-        pOldBrush = pDC->SelectObject(&navyBlueBrush);
-        pDC->Rectangle(QRect.left + t, QRect.top, QRect.right - t, QRect.bottom);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect.right - t + 1, QRect.top, QRect.right, QRect.bottom);
-        pDC->SelectStockObject(BLACK_PEN);
-        pDC->SelectStockObject(NULL_BRUSH);
-        pDC->Rectangle(QRect);
-    } else {
-        // EMPTY
-        pOldBrush = (CBrush *) pDC->SelectStockObject(WHITE_BRUSH);
-        pDC->Rectangle(QRect);
-    }
-
-    // Draw the children
-    aPos = pl_Children.GetHeadPosition();
-    offx = Offset.x;
-    while (aPos) {
-        pNode = pl_Children.GetNext(aPos);
-
-        pNode->Draw(pDC, CPoint(offx, Offset.y + LEVELHEIGHT), bSets);
-
-        offx += pNode->iWidth;
-    }
-
-    // If the node is the current one being matched, mark it with an arrow
-    if (bCurrent) {
-        int arrowX = QRect.left - ARROWSIZE;
-        int arrowY = QRect.CenterPoint().y;
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE * 3, arrowY);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY - ARROWSIZE);
-        pDC->MoveTo(arrowX, arrowY);
-        pDC->LineTo(arrowX - ARROWSIZE, arrowY + ARROWSIZE);
-    }
-
-    // If we are debugging, display node address
-    if (DEBUG_PQTREE) {
-        char alfa[MAX_ALFA];
-        int tx = QRect.CenterPoint().x + PNODERAD * 2;
-        int ty = QRect.top + PNODERAD * 2;
-        CRect drawRect = CRect(tx, ty, tx + LEAFWIDTH, ty + LEVELHEIGHT);
-        CRect calcRect = CRect(drawRect);
-
-        sprintf_s(alfa, "(%p)\nc(%d)\nl(%d)", pOriginalNode, PERTINENT_CHILD_COUNT, PERTINENT_LEAF_COUNT);
-        pDC->DrawText(CString(alfa), calcRect, DT_CALCRECT);
-        pDC->SelectStockObject(WHITE_BRUSH);
-        calcRect.InflateRect(2, 2, 2, 2);
-        pDC->Rectangle(calcRect);
-        calcRect.DeflateRect(2, 2, 2, 2);
-        pDC->DrawText(CString(alfa), drawRect, 0);
-    }
-
-    pDC->SelectObject(pOldBrush);
-    blueBrush.DeleteObject();
-}
+    pl_Children.clear();
+}
\ No newline at end of file
diff --git a/libraries/graphSetPQ/Qnode.h b/libraries/graphSetPQ/Qnode.h
index b3d8818..2f6a980 100644
--- a/libraries/graphSetPQ/Qnode.h
+++ b/libraries/graphSetPQ/Qnode.h
@@ -1,16 +1,10 @@
 #pragma once
-#include "node.h"
+#include "Node.h"
 
 class CQnode : public CNode {
-    DECLARE_DYNAMIC(CQnode)
 
 public:
-    CQnode(void);
-    CQnode(CQnode *pNode);
-
-    virtual int CalculateWidth();
-    virtual int CalculateLevel(int level);
-    virtual void Draw(CDC *pDC, CPoint Offset, bool bSets);
+    CQnode();
 
     virtual ~CQnode(void);
 };
diff --git a/libraries/gregablePQ/README b/libraries/gregablePQ/README
deleted file mode 100644
index 2ba498e..0000000
--- a/libraries/gregablePQ/README
+++ /dev/null
@@ -1,35 +0,0 @@
-A C++ implementation of Booth & Lueker's PQ-Tree algorithm.
-
-Kellog S. Booth, George S. Lueker, Testing for the consecutive ones property,
-interval graphs, and graph planarity using PQ-tree algorithms, Journal of
-Computer and Systems Sciences, 13(3) (1976) 335-379.
-
-IMPORTANT NOTE: This code currently is known to be buggy on some rare inputs.  A believed to be correct, but harder to use version of this code can be found as a library within BiVoC: https://bioinformatics.cs.vt.edu/~murali/papers/bivoc/
-
-Description of files:
-The main file for this library is pqtree.h.  It contains an API that can be
-used by client code for dealing with PQ-Trees.  There are two binaries:
-fuzztest and pqtest.
-
-pqtest runs the pqtree code for one example set of reductions on a single tree, printing the state of the tree at every step.  This illustrates how the pqtree is built.
-
-fuzztest generates a large random set of possible reductions and runs them
-against the library making sure that it never returns false or segfaults.
-
-Usage:
-Primarily, this is intended to be used as a library, not a binary.  But you can
-still compile and run the binaries |pqtest| and |fuzztest|.  My personal
-recommendation would be to compile with scons, http://scons.org/.  To do so,
-run:
-
-$ scons
-$ ./fuzztest
-$ ./pqtest
-
-Alternatively, I also handily include the tried and true MakeFile, so if you
-don't have scons on your system and don't feel like installing it, instead just
-run:
-
-$ make
-$ ./fuzztest
-$ ./pqtest
diff --git a/libraries/gregablePQ/SConstruct b/libraries/gregablePQ/SConstruct
deleted file mode 100644
index b23fb7b..0000000
--- a/libraries/gregablePQ/SConstruct
+++ /dev/null
@@ -1,15 +0,0 @@
-# Build file PQ-Tree library and unit test.  See pqtree.h for more
-# information on the library.  This file is a build rule file designed for use
-# with scons (http://www.scons.org/).
-#
-# Author: Greg Grothaus (ggrothau@gmail.com)
-
-
-Help("""
-Run: 'scons pqtest' to build the PQ-Tree library unit test.
-Run: 'scons -c' to clean up non-src files.
-""")
-
-env = Environment()
-env.Program('pqtest', ['pqnode.cc', 'pqtest.cc', 'pqtree.cc'])
-env.Program('fuzztest', ['pqnode.cc', 'fuzztest.cc', 'pqtree.cc'])
diff --git a/libraries/gregablePQ/fuzztest.cc b/libraries/gregablePQ/fuzztest.cc
deleted file mode 100644
index f1f1c84..0000000
--- a/libraries/gregablePQ/fuzztest.cc
+++ /dev/null
@@ -1,77 +0,0 @@
-// PQ-Tree fuzz test.  We basically repeatedly create a random sequence of
-// integers, choose random consecutive subseries out of the original series as
-// a reduction, then apply the reductions to a PQ Tree.  For now, we are just
-// looking to see that the library doesn't crash or return false.
-
-// This file is part of the PQ Tree library.
-//
-// The PQ Tree library is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by the
-// Free Software Foundation, either version 3 of the License, or (at your
-// option) any later version.
-//
-// The PQ Tree Library is distributed in the hope that it will be useful, but
-// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// for more details.
-//
-// You should have received a copy of the GNU General Public License along
-// with the PQ Tree Library.  If not, see <http://www.gnu.org/licenses/>.
-
-
-#include "pqtree.h"
-#include <cstdlib>
-#include <iostream>
-#include <set>
-#include <vector>
-
-int ITERATIONS = 10000;// Number of fuzztest iterations to run.
-int REDUCTIONS = 20;   // Number of reductions to apply on each run
-int TREE_SIZE = 10;    // Size of the PQ-Tree in each fuzztest.
-
-bool fuzztest() {
-    for (int i = 0; i < ITERATIONS; ++i) {
-        // Generate a tree:
-        set<int> items;
-        vector<int> frontier;
-        cout << "new tree: ";
-        for (int j = 0; j < TREE_SIZE; ++j) {
-            items.insert(j);
-            frontier.push_back(j);
-        }
-        PQTree tree(items);
-
-        // We pick a random ordering of the items.
-        random_shuffle(frontier.begin(), frontier.end());
-        for (int k = 0; k < TREE_SIZE; k++) {
-            cout << frontier[k] << " ";
-        }
-        cout << "\n";
-        for (int j = 0; j < REDUCTIONS; ++j) {
-            // Then we choose a random starting point in the list and a random length
-            int start = rand() % (TREE_SIZE - 2);
-            int size = min(rand() % 10 + 2, TREE_SIZE - start);
-
-            set<int> reduction;
-            for (int k = start; k < start + size; ++k) {
-                reduction.insert(frontier[k]);
-                cout << frontier[k] << " ";
-            }
-            cout << endl;
-            if (!tree.Reduce(reduction)) {
-                return false;
-            }
-            cout << tree.Print() << endl;
-        }
-    }
-    return true;
-}
-
-// Returns 0 if fuzztest succeeded, 1 if a failure was detected.
-int main(int argc, char **argv) {
-    if (!fuzztest()) {
-        cout << "failure\n";
-        return false;
-    }
-    return true;
-}
diff --git a/libraries/gregablePQ/gpl.txt b/libraries/gregablePQ/gpl.txt
deleted file mode 100644
index 94a9ed0..0000000
--- a/libraries/gregablePQ/gpl.txt
+++ /dev/null
@@ -1,674 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/libraries/gregablePQ/pqnode.cc b/libraries/gregablePQ/pqnode.cc
index 2095982..1a4304d 100644
--- a/libraries/gregablePQ/pqnode.cc
+++ b/libraries/gregablePQ/pqnode.cc
@@ -26,6 +26,7 @@
 #include "pqnode.h"
 
 using namespace std;
+using namespace gregable;
 
 PQNode::PQNode_types PQNode::Type() {
     return type_;
@@ -365,7 +366,7 @@ void PQNode::ReplaceCircularLink(PQNode *old_child, PQNode *new_child) {
 // functions.  Each is a depth-first walk of the entire tree looking for data
 // at the leaves.
 // TODO: Could probably be implemented better using function pointers.
-void PQNode::FindLeaves(map<int, PQNode *> &leafAddress) {
+void PQNode::FindLeaves(vector<PQNode *> &leafAddress) {
     if (type_ == leaf) {
         leafAddress[leaf_value_] = this;
     } else if (type_ == pnode) {
diff --git a/libraries/gregablePQ/pqnode.h b/libraries/gregablePQ/pqnode.h
index 40c1941..26df1e2 100644
--- a/libraries/gregablePQ/pqnode.h
+++ b/libraries/gregablePQ/pqnode.h
@@ -25,6 +25,7 @@
 #include <vector>
 using namespace std;
 
+namespace gregable {
 
 class PQNode {
     // PQNodes are not exposed by pqtrees, they are internally used only.
@@ -198,7 +199,7 @@ private:
     void LabelAsFull();
 
     // Walks the tree to build a map from values to leaf pointers.
-    void FindLeaves(map<int, PQNode *> &leafAddress);
+    void FindLeaves(vector<PQNode *> &leafAddress);
 
     // Walks the tree to find it's Frontier, returns one possible ordering.
     void FindFrontier(list<int> &ordering);
@@ -258,4 +259,6 @@ private:
     PQNode *prev_;
 };
 
+}
+
 #endif
diff --git a/libraries/gregablePQ/pqtest.cc b/libraries/gregablePQ/pqtest.cc
deleted file mode 100644
index c28e210..0000000
--- a/libraries/gregablePQ/pqtest.cc
+++ /dev/null
@@ -1,171 +0,0 @@
-// This file is part of the PQ Tree library.
-//
-// The PQ Tree library is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by the
-// Free Software Foundation, either version 3 of the License, or (at your
-// option) any later version.
-//
-// The PQ Tree Library is distributed in the hope that it will be useful, but
-// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// for more details.
-//
-// You should have received a copy of the GNU General Public License along
-// with the PQ Tree Library.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "pqnode.h"
-#include "pqtree.h"
-#include <assert.h>
-#include <iostream>
-#include <set>
-
-string ReadableType(PQNode::PQNode_types type) {
-    if (type == PQNode::leaf) {
-        return "leaf";
-    } else if (type == PQNode::pnode) {
-        return "P-Node";
-    } else if (type == PQNode::qnode) {
-        return "Q-Node";
-    }
-    return "unknown";
-}
-
-void ReduceBy(const set<int> &reduce_set, PQTree *tree) {
-    cout << "Reducing by set { ";
-    for (set<int>::iterator i = reduce_set.begin(); i != reduce_set.end(); ++i)
-        cout << *i << " ";
-    cout << "}" << endl;
-
-    assert(tree->Reduce(reduce_set));
-    cout << tree->Print() << endl;
-}
-
-void TestBed1() {
-    set<int> S;
-    for (int i = 1; i < 9; i++)
-        S.insert(i);
-    PQTree tree(S);
-
-    cout << "PQ Tree with 8 elements and no reductions" << endl;
-    cout << tree.Print() << endl;
-
-    S.clear();
-    S.insert(4);
-    S.insert(3);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(6);
-    S.insert(4);
-    S.insert(3);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(4);
-    S.insert(3);
-    S.insert(5);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(4);
-    S.insert(5);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(2);
-    S.insert(6);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(1);
-    S.insert(2);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(4);
-    S.insert(5);
-    ReduceBy(S, &tree);
-
-    // Lets actually explore the tree manually
-    cout << endl;
-    PQNode *root = tree.Root();
-    cout << "Root Type: " << ReadableType(root->Type()) << endl;
-    vector<PQNode *> children;
-    root->Children(&children);
-    for (int i = 0; i < children.size(); ++i) {
-        PQNode *child = children[i];
-        cout << "Child " << i + 1 << " Type: " << ReadableType(child->Type());
-        if (child->Type() == PQNode::leaf) {
-            cout << " Value: " << child->LeafValue() << endl;
-        } else {
-            cout << endl;
-            vector<PQNode *> grandchildren;
-            child->Children(&grandchildren);
-            for (int j = 0; j < grandchildren.size(); ++j) {
-                PQNode *grandchild = grandchildren[j];
-                cout << "GrandChild " << j + 1 << " Type: "
-                     << ReadableType(grandchild->Type());
-                if (grandchild->Type() == PQNode::leaf)
-                    cout << " Value: " << grandchild->LeafValue();
-                cout << endl;
-            }
-        }
-    }
-    cout << endl;
-
-    // Now, we perform a reduction that will fail.
-    cout << "Reducing by set {5, 3} - will fail" << endl;
-    S.clear();
-    S.insert(5);
-    S.insert(3);
-    cout << tree.Reduce(S) << endl;
-    cout << tree.Print() << endl;
-}
-
-void TestBed2() {
-    set<int> S;
-    for (int i = 0; i < 6; i++)
-        S.insert(i);
-    PQTree tree(S);
-
-    S.clear();
-    S.insert(4);
-    S.insert(1);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(3);
-    S.insert(0);
-    S.insert(2);
-    S.insert(5);
-    S.insert(4);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(0);
-    S.insert(2);
-    S.insert(5);
-    S.insert(4);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(2);
-    S.insert(5);
-    ReduceBy(S, &tree);
-
-    S.clear();
-    S.insert(0);
-    S.insert(2);
-    ReduceBy(S, &tree);
-}
-
-int main(int argc, char **argv) {
-    cout << "Test Bed 1:" << endl;
-    cout << "-----------------" << endl;
-    TestBed1();
-    cout << endl
-         << endl;
-    cout << "Test Bed 2:" << endl;
-    cout << "-----------------" << endl;
-    TestBed2();
-}
diff --git a/libraries/gregablePQ/pqtree.cc b/libraries/gregablePQ/pqtree.cc
index 5ae2640..796d0e0 100644
--- a/libraries/gregablePQ/pqtree.cc
+++ b/libraries/gregablePQ/pqtree.cc
@@ -17,6 +17,8 @@
 
 #include <assert.h>
 
+using namespace gregable;
+
 PQTree::PQTree(const PQTree &to_copy) {
     CopyFrom(to_copy);
 }
@@ -37,6 +39,7 @@ void PQTree::CopyFrom(const PQTree &to_copy) {
     reductions_ = to_copy.reductions_;
 
     leaf_address_.clear();
+    leaf_address_.reserve(to_copy.leaf_address_.capacity());
     root_->FindLeaves(leaf_address_);
 }
 
@@ -668,6 +671,7 @@ void PQTree::CleanPseudo() {
 // Basic constructor from an initial set.
 PQTree::PQTree(set<int> reduction_set) {
     // Set up the root node as a P-Node initially.
+    leaf_address_.reserve((*reduction_set.end()) + 1);
     root_ = new PQNode;
     root_->type_ = PQNode::pnode;
     invalid_ = false;
@@ -750,14 +754,17 @@ bool PQTree::Reduce(set<int> reduction_set) {
         return false;
     }
 
-    // Reset all the temporary variables for the next round.
-    root_->Reset();
 
     // Store the reduction set for later lookup.
     reductions_.push_back(reduction_set);
     return true;
 }
 
+void PQTree::cleanUp() {
+    // Reset all the temporary variables for the next round.
+    root_->Reset();
+}
+
 bool PQTree::ReduceAll(list<set<int>> L) {
     for (list<set<int>>::iterator S = L.begin(); S != L.end(); S++) {
         if (!Reduce(*S))
@@ -800,6 +807,41 @@ set<int> PQTree::GetContained() {
     return out;
 }
 
+Bigint PQTree::possibleOrders() {
+    Bigint orders(1);
+
+    std::queue<PQNode *> queue;
+
+    queue.push(root_);
+
+    while (!queue.empty()) {
+        PQNode *nextNode = queue.front();
+        queue.pop();
+
+        if (nextNode->type_ == PQNode::pnode) {
+            int childCount = nextNode == root_ ? nextNode->ChildCount() - 1 : nextNode->ChildCount();
+            orders *= factorial(childCount);
+            for (PQNode *child : nextNode->circular_link_) {
+                if (child->type_ != PQNode::leaf) {
+                    queue.push(child);
+                }
+            }
+        } else if (nextNode->type_ == PQNode::qnode) {
+            orders *= 2;
+            QNodeChildrenIterator it(nextNode);
+
+            while (!it.IsDone()) {
+                if (it.Current()->type_ != PQNode::leaf) {
+                    queue.push(it.Current());
+                }
+                it.Next();
+            }
+        }
+    }
+
+    return orders;
+}
+
 // Default destructor, Needs to delete the root.
 PQTree::~PQTree() {
     delete root_;
diff --git a/libraries/gregablePQ/pqtree.h b/libraries/gregablePQ/pqtree.h
index 4c8b694..4bab1ae 100644
--- a/libraries/gregablePQ/pqtree.h
+++ b/libraries/gregablePQ/pqtree.h
@@ -21,6 +21,7 @@ Booth and George S. Lueker in the Journal of Computer and System Sciences 13,
 // with the PQ Tree Library.  If not, see <http://www.gnu.org/licenses/>.
 
 
+#include "bigInt/bigint.h"
 #include "pqnode.h"
 #include "set_methods.h"
 #include <iostream>
@@ -34,7 +35,8 @@ using namespace std;
 
 #ifndef PQTREE_H
 #define PQTREE_H
-
+namespace gregable {
+using namespace Dodecahedron;
 class PQTree {
 private:
     // Root node of the PQTree
@@ -57,7 +59,7 @@ private:
     // increases the time complexity of the algorithm.  To fix, you can create an
     // array of items so that each item hashes to its leaf address in constant
     // time, but this is a tradeoff to conserve space.
-    map<int, PQNode *> leaf_address_;
+    vector<PQNode *> leaf_address_;
 
     // A reference to a pseudonode that cannot be reached through the root
     // of the tree.  The pseudonode is a temporary node designed to handle
@@ -146,6 +148,12 @@ public:
 
     // Returns the set of all elements on which a reduction was performed.
     set<int> GetContained();
+
+    Bigint possibleOrders();
+
+    void cleanUp();
 };
 
+}
+
 #endif
diff --git a/libraries/zanettiPQR/Leaf.h b/libraries/zanettiPQR/Leaf.h
index 4a4b0cc..1f81a08 100644
--- a/libraries/zanettiPQR/Leaf.h
+++ b/libraries/zanettiPQR/Leaf.h
@@ -14,24 +14,24 @@ struct Leaf : Node {
          */
     const int value;
 
+    int arrayIndex;
+
     /**
          * Initializes a new leaf.
          * 
          * @param i The leaf label.
          */
-    Leaf(int i) {
-        super();
-
-        this->value = i;
-    }
+    explicit Leaf(int i) : value(i){
+                                   //            std::cout << "creating " << this << ": Leaf " << value << std::endl;
+                           };
 
     // @Override
     /**
          * Returns a string representation of the leaf. It is simply the string
          * representation of the leaf label.
          */
-    std::string &toString() {
-        return Integer.toString(value);
+    std::string toString() {
+        return std::to_string(value);
     }
 
     // @Override
@@ -41,7 +41,9 @@ struct Leaf : Node {
 
     // @Override
     Bigint getPossibleOrders(bool root) {
-        return Bigint.ONE;
+        return 1;
     }
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/Node.h b/libraries/zanettiPQR/Node.h
index 8f7ef79..6b6a003 100644
--- a/libraries/zanettiPQR/Node.h
+++ b/libraries/zanettiPQR/Node.h
@@ -1,6 +1,14 @@
 #pragma once
 
 #include "Color.h"
+#include "NodeRef.hpp"
+#include <ogdf/basic/memory.h>
+
+#include <array>
+#include <bigInt/bigint.h>
+#include <set>
+
+using namespace Dodecahedron;
 
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
@@ -12,25 +20,25 @@ struct Node {
     /**
          * Stores the color of the node when it is defined.
          */
-    Color color;
+    Color color = Color::WHITE;
 
     /**
          * The parent of the node. It is only set if the parent is a P-node or
          * if this node is the representative node among all its siblings in
          * the union-find structure.
          */
-    Node *parent;
+    PQRNode *parent = nullptr;
     /**
          * If this is a non-representative child of a Q/R-node, 
          * points to a sibling node above it in the union-find tree.
          * Otherwise, points to itself.
          */
-    Node *representant;
+    NodeRef representant;
     /**
          * Rank of the node in the union-find tree. It is zero if the node is not
          * part of a union-find structure.
          */
-    int rank;
+    int rank = 0;
 
     /**
          * Holds the two immediate siblings of this node. This forms a symmetric 
@@ -39,36 +47,39 @@ struct Node {
          * list. "Previous" is the one the traversal came from, "next" is the
          * opposite.
          */
-    std::array<Node *, 2> sibling;
+    std::array<Node *, 2> sibling{nullptr, nullptr};
 
     /**
          * Marks whether the node has been visited during the reduction.
          */
-    bool visited;
+    bool visited = false;
     /**
          * The number of pertinent children of this.
          */
-    int pertinentChildCount;
+    int pertinentChildCount = 0;
     /**
          * the number of pertinent leaves in the subtree rooted by this.
          */
-    int pertinentLeafCount;
+    int pertinentLeafCount = 0;
 
-    Node() {
-        super();
-
-        this->color = Color::WHITE;
-
-        this->parent = nullptr;
-        this->representant = this;
-        this->rank = 0;
+    /**
+         * How many children in the Union Find data structure point to us.
+         */
+    int cNodeRefs = 0;
+#ifdef OGDF_DEBUG
+    std::set<void *> cNodeRefObjs;
+#endif
+    /**
+         * Whether the node has been deleted from the tree. Nodes can be removed from
+         * the tree but still be needed for the union-find tree structure. In this case
+         * they are removed from the tree, marked as deleted, but kept in the union-find
+         * tree.
+         */
+    bool deleted = false;
 
-        this->sibling = new Node[2];
+    Node() : representant(this) { representant = this; };
 
-        this->visited = false;
-        this->pertinentChildCount = 0;
-        this->pertinentLeafCount = 0;
-    }
+    virtual ~Node() = default;
 
     Color getColor() {
         return color;
@@ -81,13 +92,13 @@ struct Node {
          * @return The representative sibling of this node.
          */
     Node *find() {
-        if (this->representant != this) {
-            this->representant = this->representant->find();
+        if (representant != this) {
+            setRepresentant(this->representant->find());
         }
         return this->representant;
     }
 
-    Node *getParent() {
+    PQRNode *getParent() {
         if (this->representant == this) {
             return parent;
         } else {
@@ -95,37 +106,22 @@ struct Node {
         }
     }
 
-    void setColor(Color color) {
-        this->color = color;
+    void setColor(Color color);
 
-        if (color == Color::GRAY) {
-            this->getParent()->addGrayChild(this);
-        }
-        if (color == Color::BLACK) {
-            this->getParent()->addBlackChild(this);
-        }
-    }
-
-    void setParent(Node *parent) {
-        if (parent == nullptr) {
-            this->parent = nullptr;
-            this->representant = this;
-        } else if (parent->getType() == PQRType::P) {
-            this->parent = parent;
-            this->representant = this;
-        } else if (parent->getChildCount() == 0) {
-            this->parent = parent;
-            this->representant = this;
-        } else {
-            this->parent = nullptr;
-            this->representant = parent->getRepresentativeChild();
-        }
-    }
+    void setParent(PQRNode *parent);
 
     void setRepresentant(Node *v) {
         this->representant = v;
     }
 
+    /**
+         * Remove the node from its parent and mark it as deleted. Nodes are not
+         * actually destroyed because they might be part of a union-find tree.
+         */
+    void destroy(bool remove = true);
+
+    void maybeDeleteSelf();
+
     int getRank() {
         return this->rank;
     }
@@ -141,9 +137,9 @@ struct Node {
          * @return true if all the children of the node are colored black 
          * (of if the node is a leaf), false otherwise.
          */
-    bool areAllChildrenBlack();
+    virtual bool areAllChildrenBlack() = 0;
 
-    void cleanUp() {
+    virtual void cleanUp() {
         this->color = Color::WHITE;
         this->visited = false;
         this->pertinentChildCount = 0;
@@ -174,6 +170,10 @@ struct Node {
         this->pertinentLeafCount = n;
     }
 
-    Bigint getPossibleOrders(bool root);
+    virtual Bigint getPossibleOrders(bool root) = 0;
+
+    virtual std::string toString() = 0;
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/PQRNode.h b/libraries/zanettiPQR/PQRNode.h
index dfe884a..b6c76fc 100644
--- a/libraries/zanettiPQR/PQRNode.h
+++ b/libraries/zanettiPQR/PQRNode.h
@@ -4,6 +4,9 @@
 
 #include "Node.h"
 
+#include <deque>
+#include <sstream>
+
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
 
@@ -11,61 +14,51 @@ namespace cpp_zanetti {
 // import java.util.Iterator;
 // import java.util.std::deque;
 
+template<typename Node>
+Node *poll(std::deque<Node *> &queue) {
+    if (queue.empty()) return nullptr;
+    Node *val = queue.front();
+    queue.pop_front();
+    return val;
+}
+
 struct PQRNode : Node {
 
     /**
          * The first child of the node.
          */
-    Node *firstChild;
+    Node *firstChild = nullptr;
     /**
          * The last child of the node.
          */
-    Node *lastChild;
+    Node *lastChild = nullptr;
     /**
          * The child that is the representant of the union-find structure of 
          * this node's children. It is only set if this node has type Q or R.
          */
-    Node *representativeChild;
+    Node *representativeChild = nullptr;
     /**
          * Number of children of the node.
          */
-    int childCount;
+    int childCount = 0;
 
     /**
          * The type of the node --- P, Q or R.
          */
     PQRType type;
-    /**
-         * Whether the node has been deleted from the tree.
-         * Nodes can be removed from the tree but still be needed for the union-find
-         * tree structure. In this case they are removed from the tree, marked as
-         * deleted, but kept in the union-find tree.
-         */
-    bool deleted;
 
     /**
          * A list that stores the gray children of the node.
          */
-    const std::deque<Node> grayChildren;
+    std::deque<Node *> grayChildren;
     /**
          * A list that stores the black children of the node.
          */
-    const std::deque<Node> blackChildren;
-
-    PQRNode(PQRType type) {
-        super();
-
-        this->firstChild = nullptr;
-        this->lastChild = nullptr;
-        this->representativeChild = nullptr;
-        this->childCount = 0;
-
-        this->type = type;
-        this->deleted = false;
+    std::deque<Node *> blackChildren;
 
-        this->grayChildren = new std::deque<>();
-        this->blackChildren = new std::deque<>();
-    }
+    explicit PQRNode(PQRType type) : type(type){
+                                             //            std::cout << "creating " << this << ": " << (type == PQRType::P ? "P" : "Q") << " node" << std::endl;
+                                     };
 
     /**
          * Returns the type of the node.
@@ -85,10 +78,6 @@ struct PQRNode : Node {
         this->type = type;
     }
 
-    bool isDeleted() {
-        return deleted;
-    }
-
     int getChildCount() {
         return this->childCount;
     }
@@ -110,7 +99,7 @@ struct PQRNode : Node {
     }
 
     PQRNode *getGrayChild() {
-        return (PQRNode) poll(this->grayChildren);
+        return dynamic_cast<PQRNode *>(poll(this->grayChildren));
     }
 
     /**
@@ -295,18 +284,6 @@ struct PQRNode : Node {
         v->sibling[1] = nullptr;
     }
 
-    /**
-         * Remove the node from its parent and mark it as deleted. Nodes are not 
-         * actually destroyed because they might be part of a union-find tree.
-         */
-    void destroy() {
-        PQRNode *p = this->getParent();
-        if (p != nullptr) {
-            p->removeChild(this);
-        }
-        this->deleted = true;
-    }
-
     /**
          * Invert the order of the children of the node.
          */
@@ -415,7 +392,7 @@ struct PQRNode : Node {
         if (this->getChildCount() == 1) {
             this->removeChild(v);
             if (this->getParent() != nullptr) {
-                this->getParent().insertEnd(v);
+                dynamic_cast<PQRNode *>(this->getParent())->insertEnd(v);
             }
             this->destroy();
         }
@@ -430,7 +407,7 @@ struct PQRNode : Node {
     }
 
     bool mergeIntoLCA() {
-        PQRNode *r = this->getParent();
+        PQRNode *r = dynamic_cast<PQRNode *>(this->getParent());
 
         // Union
         Node *thisRep = this->getRepresentativeChild();
@@ -525,8 +502,8 @@ struct PQRNode : Node {
 
         // Update LCA child count and colored children lists
         r->childCount = r->childCount + this->childCount;
-        r->blackChildren.addAll(this->blackChildren);
-        r->grayChildren.addAll(this->grayChildren);
+        r->blackChildren.insert(r->blackChildren.end(), this->blackChildren.begin(), this->blackChildren.end());
+        r->grayChildren.insert(r->grayChildren.end(), this->grayChildren.begin(), this->grayChildren.end());
 
         // Destroy this node
         this->sibling[0] = nullptr;
@@ -536,7 +513,7 @@ struct PQRNode : Node {
     }
 
     void mergePNode() {
-        PQRNode *r = this->getParent();
+        PQRNode *r = dynamic_cast<PQRNode *>(this->getParent());
 
         // Determine darkest direction
         Node *lightestDir = this->sibling[0];
@@ -594,14 +571,15 @@ struct PQRNode : Node {
          * Operations to adjust the LCA         *
          * after repairing all gray children.         *
          **************************************
+         */
     bool adjust() {
-        switch (this.type) {
+        switch (this->type) {
             case PQRType::P:
-                this.joinBlackChildren();
+                this->joinBlackChildren();
                 break;
 
             case PQRType::Q:
-                if (!this.adjustQ()) return false;
+                if (!this->adjustQ()) return false;
                 break;
 
             default:
@@ -612,17 +590,17 @@ struct PQRNode : Node {
 
     bool adjustQ() {
         int whiteCount = 0;
-        for (Node         * b : this.blackChildren) {
-            if ((b.sibling[0] == nullptr) || (b.sibling[0].getColor() == Color::WHITE)) {
+        for (Node *b : this->blackChildren) {
+            if ((b->sibling[0] == nullptr) || (b->sibling[0]->getColor() == Color::WHITE)) {
                 whiteCount++;
             }
-            if ((b.sibling[1] == nullptr) || (b.sibling[1].getColor() == Color::WHITE)) {
+            if ((b->sibling[1] == nullptr) || (b->sibling[1]->getColor() == Color::WHITE)) {
                 whiteCount++;
             }
         }
 
         if (whiteCount > 2) {
-            this.type = PQRType::R;
+            this->type = PQRType::R;
             return false;
         } else {
             return true;
@@ -631,10 +609,10 @@ struct PQRNode : Node {
 
     // @Override
     void cleanUp() {
-        super.cleanUp();
+        Node::cleanUp();
 
-        this.grayChildren.clear();
-        this.blackChildren.clear();
+        this->grayChildren.clear();
+        this->blackChildren.clear();
     }
 
     /*
@@ -650,8 +628,8 @@ struct PQRNode : Node {
          * @see PQRTree.toString()
          */
     // @Override
-    std::string &toString() {
-        std::string &s = "";
+    std::string toString() {
+        std::stringstream s;
 
         switch (this->type) {
             case PQRType::P:
@@ -706,7 +684,7 @@ struct PQRNode : Node {
                 break;
         }
 
-        return s;
+        return s.str();
     }
 
     // @Override
@@ -737,19 +715,20 @@ struct PQRNode : Node {
 
     // @Override
     Bigint getPossibleOrders(bool root) {
-        Bigint orders = Bigint.ONE;
+        Bigint orders = 1;
         switch (type) {
-            case PQRType::P:
+            case PQRType::P: {
                 int num = root ? getChildCount() - 1 : getChildCount();
                 for (int i = 2; i <= num; i++) {
-                    orders = orders.multiply(Bigint.valueOf(i));
+                    orders *= i;
                 }
                 break;
+            }
             case PQRType::Q:
-                orders = orders.multiply(Bigint.valueOf(2));
+                orders *= 2;
                 break;
             case PQRType::R:
-                return Bigint.ZERO;
+                return 0;
             default:
                 break;
         }
@@ -759,7 +738,7 @@ struct PQRNode : Node {
         Node *prevChild = nullptr;
         int nextChild;
         while (child != nullptr) {
-            orders = orders.multiply(child->getPossibleOrders(false));
+            orders *= child->getPossibleOrders(false);
 
             // Get next child
             if (child->sibling[0] == prevChild) {
@@ -774,22 +753,29 @@ struct PQRNode : Node {
         return orders;
     }
 
-    template<> static struct ChildIterator {
-        Node *pred;
+    struct ChildIterator {
+        using iterator_category = std::forward_iterator_tag;
+        using value_type = PQRNode;
+        using pointer = PQRNode *;
+        using reference = PQRNode &;
+        using difference_type = std::ptrdiff_t;
+
+        Node *pred = nullptr;
         Node *next;
 
-        ChildIterator(Node *next) {
-            this->pred = nullptr;
-            this->next = next;
-        }
+        ChildIterator(Node *next, Node *pred = nullptr) : next(next), pred(pred) {}
 
         // @Override
         bool hasNext() {
             return next != nullptr;
         }
 
+        Node *operator*() const {
+            return pred;
+        }
+
         // @Override
-        Node *next() {
+        ChildIterator &operator++() {
             if (pred == next->sibling[0]) {
                 pred = next;
                 next = pred->sibling[1];
@@ -797,14 +783,27 @@ struct PQRNode : Node {
                 pred = next;
                 next = pred->sibling[0];
             }
-            return pred;
+            return *this;
+        }
+
+        bool operator==(const ChildIterator &rhs) const {
+            return pred == rhs.pred &&
+                   next == rhs.next;
+        }
+
+        bool operator!=(const ChildIterator &rhs) const {
+            return !(rhs == *this);
         }
     };
 
-    // @Override
-    Iterator<Node>;
-    iterator() {
-        return new ChildIterator(firstChild);
+    ChildIterator begin() const {
+        return ChildIterator(firstChild);
+    }
+
+    ChildIterator end() const {
+        return ChildIterator(nullptr, lastChild);
     }
+
+    OGDF_NEW_DELETE
 };
 }
diff --git a/libraries/zanettiPQR/PQRTree.h b/libraries/zanettiPQR/PQRTree.h
index 321ae87..34e4aef 100644
--- a/libraries/zanettiPQR/PQRTree.h
+++ b/libraries/zanettiPQR/PQRTree.h
@@ -4,6 +4,12 @@
 
 #include "PQRNode.h"
 
+#include <list>
+#include <queue>
+#include <set>
+#include <stack>
+#include <variant>
+
 namespace cpp_zanetti {
 // package java_evaluation.jppzanetti;
 
@@ -33,52 +39,64 @@ struct PQRTree {
     /**
          * An array of all the leaves.
          */
-    const std::vector<Leaf> leaf;
+    std::vector<Leaf *> leaf;
 
     /**
          * A list to hold all nodes that are visited during the reduction process.
          */
-    const std::deque<PQRNode> visitedNodes;
+    std::deque<NodeRef> visitedNodes;
 
     /**
          * Builds and returns an universal tree with n leaves.
-         * 
-         * @param n The number of leaves in the tree. 
+         *
+         * @param n The number of leaves in the tree.
          */
-    PQRTree(int n) {
-        super();
-
+    PQRTree(int n, std::vector<Leaf *> &newLeaves) {
         // Create root
         this->root = new PQRNode(PQRType::P);
 
-        // Create the leaf list
-        this->leaf = new std::vector<>(n);
-
         // Create and insert leaves
+        leaf.reserve(n);
         for (int i = 0; i < n; i++) {
-            this->leaf.push_back(i, new Leaf(i));
-            this->root->insertEnd(leaf.get(i));
+            Leaf *l = new Leaf(i);
+            l->arrayIndex = this->leaf.size();
+            this->leaf.push_back(l);
+            this->root->insertEnd(l);
+            newLeaves.push_back(l);
             // assert this.leaf.get(i).value == i;
         }
+    }
 
-        this->visitedNodes = new std::deque<>();
+    virtual ~PQRTree() {
+        std::vector<Node *> toDelete(leaf.begin(), leaf.end());
+        while (!toDelete.empty()) {
+            Node *l = toDelete.back();
+            toDelete.pop_back();
+            PQRNode *p = dynamic_cast<PQRNode *>(l->getParent());
+            l->destroy();
+            if (p != nullptr && p->childCount == 0) {
+                toDelete.push_back(p);
+            }
+        }
     }
 
     /**
          * Adds one constraint set to the tree, updating its structure as necessary.
-         * 
+         *
          * @param c An array of integers that must be consecutive.
          */
-    bool reduce(std::vector<Leaf *> &c) {
+    bool reduce(const std::vector<Leaf *> &c) {
         if (c.size() < 2) {
             return true;
         }
 
+        //OGDF_ASSERT(checkValid());
         PQRNode *r = this->bubble(c);
         r = this->repairGray(r);
         if (r == nullptr) return false;
         if (!r->adjust()) return false;
         this->uncolor(c);
+        //OGDF_ASSERT(checkValid());
         return true;
     }
 
@@ -90,19 +108,18 @@ struct PQRTree {
          *         This is the node that serves as the start for the updates to the
          *         tree.
          */
-    PQRNode *bubble(std::vector<Leaf *> &c) {
-        std::deque<Node> queue = new std::deque<>();
+    PQRNode *bubble(const std::vector<Leaf *> &c) {
+        std::deque<Node *> queue;
         int offTheTop = 0;
 
         // First phase: count the pertinent children of each node
-        for (int i : c) {
-            // assert this.leaf.get(i).value == i;
-            this->leaf.get(i).visit();
-            queue.push_back(this->leaf.get(i));
+        for (Leaf *l : c) {
+            l->visit();
+            queue.push_back(l);
         }
         while (queue.size() + offTheTop > 1) {
             Node *v = poll(queue);
-            PQRNode *p = v.getParent();
+            Node *p = v->getParent();
 
             if (p == nullptr) {
                 offTheTop = 1;
@@ -110,7 +127,7 @@ struct PQRTree {
                 if (!p->isVisited()) {
                     queue.push_back(p);
                     p->visit();
-                    this->visitedNodes.push_back(p);
+                    this->visitedNodes.emplace_back(nullptr, p);
                 }
                 p->setPertinentChildCount(p->getPertinentChildCount() + 1);
             }
@@ -118,16 +135,16 @@ struct PQRTree {
 
         // Second phase: color the nodes and find the LCA
         queue.clear();
-        for (int i : c) {
-            this->leaf.get(i).setPertinentLeafCount(1);
-            queue.push_back(this->leaf.get(i));
+        for (Leaf *l : c) {
+            l->setPertinentLeafCount(1);
+            queue.push_back(l);
         }
         while (!queue.empty()) {
             Node *v = poll(queue);
             Node *p = v->getParent();
 
             if (v->getPertinentLeafCount() == c.size()) {
-                return (PQRNode) v;
+                return (PQRNode *) v;
             }
 
             if (v->areAllChildrenBlack()) {
@@ -142,8 +159,8 @@ struct PQRTree {
                 queue.push_back(p);
             }
         }
-        throw new AssertionError();
-        //        return nullptr;
+        throw std::runtime_error("bubble didn't find apex");
+        //		return nullptr;
     }
 
     /**
@@ -193,25 +210,26 @@ struct PQRTree {
          * 
          * @param c The constraint just added.
          */
-    void uncolor(std::vector<Leaf *> &c) {
-        for (int i : c) {
-            this->leaf.get(i).cleanUp();
+    void uncolor(const std::vector<Leaf *> &c) {
+        for (Leaf *l : c) {
+            l->cleanUp();
 
-            PQRNode *p = this->leaf.get(i).getParent();
+            Node *p = l->getParent();
             if ((p != nullptr) && (p->isVisited())) {
                 p->cleanUp();
-                this->visitedNodes.push_back(p);
+                this->visitedNodes.emplace_back(nullptr, p);
             }
         }
         while (!this->visitedNodes.empty()) {
-            PQRNode *v = poll(this->visitedNodes);
+            Node *v = this->visitedNodes.front();
             v->cleanUp();
 
-            PQRNode *p = v->getParent();
+            Node *p = v->getParent();
             if ((p != nullptr) && (p->isVisited())) {
                 p->cleanUp();
-                this->visitedNodes.push_back(p);
+                this->visitedNodes.emplace_back(nullptr, p);
             }
+            this->visitedNodes.pop_front();
         }
     }
 
@@ -234,251 +252,90 @@ struct PQRTree {
          * @return The string representation of the tree.
          */
     // @Override
-    std::string &toString() {
+    std::string toString() {
         return root->toString();
     }
 
-    std::string &uniqueID() {
-        return uniqueID(true, true);
+    Bigint getPossibleOrders() {
+        return root->getPossibleOrders(true);
     }
 
-    Node *getNeighbor(Node *node, Node *neighbor) {
-        if (neighbor instanceof Leaf || neighbor == nullptr) {
-            return neighbor;
+    void deleteLeaf(Leaf *l, PQRNode *p) {
+        Node *c = p->firstChild;
+        if (p->representativeChild == l) {
+            p->setRepresentativeChild(c);
+            l->setParent(p);
+            c->setParent(p);
         }
-
-        PQRNode *n = (PQRNode) neighbor;
-        int deg = n->getChildCount();
-        if (n != root)
-            deg++;
-
-
-        if (deg != 2) {
-            return neighbor;
+        l->destroy(false);
+        if (leaf.size() > 1) {
+            auto last = leaf.end() - 1;
+            (*last)->arrayIndex = l->arrayIndex;
+            std::iter_swap(leaf.begin() + l->arrayIndex, last);
+            leaf.pop_back();
         } else {
-            List<Node> neighbors = new std::deque<>();
-            n->iterator().forEachRemaining(neighbors::add);
-            if (node != root)
-                neighbors.push_back(node->getParent());
-            // assert neighbors.size() == 2;
-
-            if (neighbors.get(0) == node) {
-                return getNeighbor(neighbor, neighbors.get(1));
-            } else {
-                // assert neighbors.get(1) == node;
-                return getNeighbor(neighbor, neighbors.get(0));
-            }
-        }
-    }
-
-    std::string &uniqueID(bool normalizeLeafIDs, bool includeInnerNodeOrder) {
-        if (root == nullptr) {
-            return "empty";
+            leaf.clear();
         }
-        std::stringstream sb = new std::stringstream();
-
-        List<Node> labelingQueue = new std::deque<>(leaf);
-        labelingQueue.sort(Comparator.comparingInt(a->a == nullptr ? Integer.MAX_VALUE : ((Leaf) a).value));
-        while (labelingQueue.get(labelingQueue.size() - 1) == nullptr)
-            labelingQueue.remove(labelingQueue.size() - 1);
-        Leaf *lastLeaf = (Leaf) labelingQueue.get(labelingQueue.size() - 1);
-
-        List<Node> fullNodeOrder = new std::deque<>();
-        HashMap<Node, Integer> order = new HashMap<>();
-        HashMap<Node, Integer> fullNeighborCount = new HashMap<>();
-        while (!labelingQueue.empty()) {
-            Node *node = labelingQueue.remove(0);
-            Node *parent = getNeighbor(node, node->getParent());
-
-            order.put(node, fullNodeOrder.size());
-            fullNodeOrder.push_back(node);
-
-            if (node == lastLeaf) continue;
-
-            if (node == root || parent == nullptr || order.containsKey(parent)) {
-                parent = nullptr;
-                for (Node *curr : (PQRNode) node) {
-                    if (!order.containsKey(curr)) {
-                        parent = (PQRNode) curr;
-                        break;
-                    }
-                }
-                if (parent == nullptr) {
-                    // assert labelingQueue.empty();
-                    continue;
-                }
-            }
-            // assert parent != nullptr;
-            // assert !order.containsKey(parent);
-
-            fullNeighborCount.put(parent, fullNeighborCount.getOrDefault(parent, 0) + 1);
-            int pDeg = parent; instanceof Leaf ? 1 : ((PQRNode) parent).getChildCount();
-            if (parent != root) pDeg++;
-            if (fullNeighborCount.get(parent) == pDeg - 1) {
-                labelingQueue.push_back(parent);
-            } else {
-                // assert fullNeighborCount.get(parent) < pDeg - 1;
+        if (p->getChildCount() == 1) {
+            PQRNode *pp = dynamic_cast<PQRNode *>(p->getParent());
+            pp->replaceChild(p, c);
+            if (pp->representativeChild == p) {
+                pp->setRepresentativeChild(c);
+                p->setParent(pp);
+                c->setParent(pp);
             }
+            p->destroy(false);
         }
-
-        List<Object> stack = new std::deque<>();
-        stack.push_back(fullNodeOrder.get(fullNodeOrder.size() - 1));
-        while (!stack.empty()) {
-            Object next = stack.remove(stack.size() - 1);
-
-            if (next instanceof std::string &) {
-                sb << (next);
-                continue;
-            } else if (next instanceof Leaf) {
-                if (normalizeLeafIDs)
-                    sb << (order.get(next));
-                else
-                    sb << (((Leaf) next).value);
-                continue;
-            }
-
-            PQRNode *node = (PQRNode) next;
-            List<Node> children = new std::deque<>();
-            node->iterator().forEachRemaining(child->children.push_back(getNeighbor(node, child)));
-            // assert children.size() == node.getChildCount();
-            if (node != root)
-                children.push_back(getNeighbor(node, node->getParent()));
-            int degree = children.size();
-
-            PQRNode *informedNeighbor = nullptr;
-            if (node != fullNodeOrder.get(fullNodeOrder.size() - 1)) {
-                for (int j = 0; order.get(children.get(0)) < order.get(node); j++) {
-                    // assert j <= node.getChildCount() + 1;
-                    children.push_back(children.remove(0));
-                }
-                informedNeighbor = (PQRNode) children.remove(0);
-                // assert order.get(informedNeighbor) > order.get(node);
-            }
-
-            if (includeInnerNodeOrder) sb << (order.get(node)) << (":");
-            if (node->getType() == PQRType::Q) {
-                sb << ("[");
-                stack.push_back("]");
-                if (node == fullNodeOrder.get(fullNodeOrder.size() - 1)) {
-                    Node *minChild = Collections.min(children, Comparator.comparingInt(order::get));
-                    for (int j = 0; children.get(0) != minChild; j++) {
-                        // assert j <= node.getChildCount() + 1;
-                        children.push_back(children.remove(0));
-                    }
-                    Node *second = children.get(1);
-                    if (order.get(second) > order.get(children.get(children.size() - 1))) {
-                        children.push_back(children.remove(0));
-                        Collections.reverse(children);
-                    }
-                    second = children.get(1);
-                    // assert (children.get(0) == minChild);
-                    // assert (order.get(second) < order.get(children.get(children.size() - 1)));
-                } else {
-                    if (order.get(children.get(0)) > order.get(children.get(children.size() - 1))) {
-                        Collections.reverse(children);
-                    }
-                }
-            } else {
-                if (node->getType() == PQRType::R) {
-                    sb << ("XXX{");
-                    stack.push_back("}XXX");
-                } else if (degree <= 3) {
-                    sb << ("[");
-                    stack.push_back("]");
-                } else {
-                    sb << ("(");
-                    stack.push_back(")");
-                }
-                children.sort(Comparator.comparingInt(order::get));
-            }
-
-            // assert (node == fullNodeOrder.get(fullNodeOrder.size() - 1)) == (lastLeaf.getParent() == node);
-            // assert (order.get(children.get(0)) < order.get(children.get(children.size() - 1)));
-
-            bool space = false;
-            for (Node *child : children) {
-                if (space)
-                    stack.push_back(", ");
-                stack.push_back(child);
-                space = true;
-            }
-        }
-
-        return sb.toString();
     }
 
-    Bigint getPossibleOrders() {
-        return root->getPossibleOrders(true);
-    }
-
-    void mergeAndReplaceLeaves(int[] oldLeaves, int[] newLeaves) {
-        //        {
-        //            PQRNode         * parent = leaf.get(oldLeaves[0]).getParent();
-        //            System.out.println("replace " + Arrays.toString(oldLeaves) + " with " + Arrays.toString(newLeaves) + " on parent " + parent.getType() + " " + parent);
-        //        }
-        for (int i = 0; i < oldLeaves.size() - 1; i++) {
-            Leaf *l = leaf.get(oldLeaves[i]);
-            leaf.set(oldLeaves[i], nullptr);
-            //            System.out.println("remove " + i + " = " + l.toString());
-            PQRNode *p = l->getParent();
+    void mergeAndReplaceLeaves(const std::vector<Leaf *> &oldLeaves, const std::vector<int> &newLeafIDs, std::vector<Leaf *> &newLeaves) {
+        Leaf *remainingLeaf = oldLeaves.back();
+        for (Leaf *l : oldLeaves) {
+            if (l == remainingLeaf) continue;
+            PQRNode *p = dynamic_cast<PQRNode *>(l->getParent());
             p->removeChild(l);
-            if (p->getChildCount() == 1) {
-                PQRNode *pp = p->getParent();
-                //                System.out.println("flatten deg-1 " + p + " into " + pp);
-                pp->replaceChild(p, p->firstChild);
-                p->firstChild->parent = pp;
-                p->firstChild->representant = p->firstChild;
-                //                System.out.println("\t" + pp);
-                //            } else {
-                //                System.out.println("\t" + p);
-            }
+            deleteLeaf(l, p);
         }
 
-        Leaf *remainingLeaf = leaf.get(oldLeaves[oldLeaves.size() - 1]);
-        leaf.set(oldLeaves[oldLeaves.size() - 1], nullptr);
         Node *newNode;
-        if (newLeaves.size() > 1) {
+        if (newLeafIDs.size() > 1) {
             newNode = new PQRNode(PQRType::P);
-            for (int i : newLeaves) {
-                while (i >= leaf.size()) {
-                    leaf.push_back(nullptr);
-                }
-                leaf.set(i, new Leaf(i));
-                ((PQRNode) newNode).insertEnd(leaf.get(i));
+            newLeaves.reserve(newLeafIDs.size());
+            for (int i : newLeafIDs) {
+                Leaf *l = new Leaf(i);
+                l->arrayIndex = leaf.size();
+                leaf.push_back(l);
+                newLeaves.push_back(l);
+                ((PQRNode *) newNode)->insertEnd(l);
             }
         } else {
-            int i = newLeaves[0];
-            newNode = new Leaf(i);
-            while (i >= leaf.size()) {
-                leaf.push_back(nullptr);
-            }
-            this->leaf.set(i, (Leaf) newNode);
+            int i = newLeafIDs[0];
+            Leaf *l = new Leaf(i);
+            l->arrayIndex = leaf.size();
+            newLeaves.push_back(l);
+            leaf.push_back(l);
+            newNode = l;
         }
-        PQRNode *parent = remainingLeaf->getParent();
-        //        System.out.println("replace " + remainingLeaf + " => " + newNode + " in " + parent);
+        PQRNode *parent = dynamic_cast<PQRNode *>(remainingLeaf->getParent());
         parent->replaceChild(remainingLeaf, newNode);
-        //        System.out.println("\t" + parent);
+        deleteLeaf(remainingLeaf, parent);
 
         fixParent(parent, newNode);
-        visitedNodes.clear();
     }
 
     void fixParent(PQRNode *parent, Node *newNode) {
         while (parent->getType() == PQRType::Q || parent->getChildCount() == 1) {
             if (parent->getChildCount() == 1) {
-                PQRNode *newParent = parent->getParent();
-                //                System.out.println("flatten deg-1 " + parent + " into " + newParent);
+                PQRNode *newParent = dynamic_cast<PQRNode *>(parent->getParent());
                 newParent->replaceChild(parent, newNode);
+                parent->destroy(false);
                 parent = newParent;
             } else if (parent->getChildCount() == 2) {
-                //                System.out.println("convert deg-2 " + parent + " into P");
                 parent->setType(PQRType::P);
-                parent->representativeChild = newNode;
-                newNode->parent = parent;
-                newNode->representant = newNode;
+                parent->setRepresentativeChild(newNode);
+                newNode->setParent(parent);
                 Node *sib = newNode->sibling[0] != nullptr ? newNode->sibling[0] : newNode->sibling[1];
-                sib->parent = parent;
-                sib->representant = newNode;
+                sib->setParent(parent);
             } else {
                 fixTree(parent, 0);
                 break;
@@ -493,37 +350,28 @@ struct PQRTree {
         Node *curr = parent->firstChild;
         int count = 0;
         while (curr != nullptr) {
-            if (parent->getType() == PQRType::P) {
-                curr->parent = parent;
-                curr->representant = curr;
-                curr->rank = 0;
+            curr->setParent(parent);
+            if (dynamic_cast<PQRNode *>(curr) && depth > 0) {
+                fixTree((PQRNode *) curr, depth - 1);
             } else {
-                curr->parent = nullptr;
-                curr->representant = parent->firstChild;
-                curr->rank = 1;
+                curr->cleanUp();
             }
-            if (curr instanceof PQRNode && depth > 0) {
-                fixTree((PQRNode) curr, depth - 1);
-            } else {
-                if (curr instanceof Leaf) {
-                    // assert leaf.get(((Leaf) curr).value) == curr;
+            if (pred == nullptr) {
+                if (parent->getType() == PQRType::Q) {
+                    parent->setRepresentativeChild(parent->firstChild);
+                    parent->firstChild->setParent(parent);
+                    parent->firstChild->rank = 0;
+                } else {
+                    parent->setRepresentativeChild(nullptr);
                 }
-                curr->cleanUp();
             }
             Node *next = curr->sibling[0] == pred ? curr->sibling[1] : curr->sibling[0];
             pred = curr;
             curr = next;
             count++;
         }
-        // assert pred == parent.lastChild;
-        // assert count == parent.getChildCount();
-        if (parent->getType() == PQRType::Q) {
-            parent->firstChild->parent = parent;
-            parent->firstChild->rank = 0;
-            parent->representativeChild = parent->firstChild;
-        } else {
-            parent->representativeChild = nullptr;
-        }
+        OGDF_ASSERT(pred == parent->lastChild);
+        OGDF_ASSERT(count == parent->childCount);
     }
 };
 }
-- 
2.30.2

